<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ktrain.core API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ktrain.core</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from . import utils as U
from .graph.predictor import LinkPredictor, NodePredictor
from .graph.preprocessor import LinkPreprocessor, NodePreprocessor
from .imports import *
from .lroptimize.lrfinder import *
from .tabular.predictor import TabularPredictor
from .tabular.preprocessor import TabularPreprocessor
from .text.ner.predictor import NERPredictor
from .text.ner.preprocessor import NERPreprocessor
from .text.predictor import TextPredictor
from .text.preprocessor import (
    BERTPreprocessor,
    TextPreprocessor,
    TransformersPreprocessor,
)
from .vision.predictor import ImagePredictor
from .vision.preprocessor import ImagePreprocessor


class Learner(ABC):
    &#34;&#34;&#34;
    ```
    Abstract class used to tune and train Keras models. The fit method is
    an abstract method and must be implemented by subclasses.
    ```

    &#34;&#34;&#34;

    def __init__(self, model, workers=1, use_multiprocessing=False):
        if not isinstance(model, keras.Model):
            raise ValueError(&#34;model must be of instance keras.Model&#34;)
        self.model = model
        self.lr_finder = LRFinder(self.model)
        self.workers = workers
        self.use_multiprocessing = use_multiprocessing
        self.history = None

        # save original weights of model
        try:
            new_file, weightfile = tempfile.mkstemp()
            self.model.save_weights(weightfile)
            self._original_weights = weightfile
        except Exception as e:
            warnings.warn(&#34;Could not save original model weights: %s&#34; % (e))
            self._original_weights = None

    @property
    def _monitor_metrics(self):
        &#34;&#34;&#34;
        ```
        monitor metrics
        ```
        &#34;&#34;&#34;
        metrics = [&#34;loss&#34;]
        try:
            m = U.metrics_from_model(self.model)
            if isinstance(m, list):
                metrics.extend(m)
        except:
            pass
        if self.val_data is not None:
            for m in metrics[:]:
                metrics.append(&#34;val_%s&#34; % (m))
        return metrics

    def get_weight_decay(self):
        &#34;&#34;&#34;
        ```
        Get current weight decay rate
        ```
        &#34;&#34;&#34;
        if type(self.model.optimizer).__name__ == &#34;AdamWeightDecay&#34;:
            return self.model.optimizer.weight_decay_rate
        else:
            return None

    def set_weight_decay(self, wd=U.DEFAULT_WD):
        &#34;&#34;&#34;
        ```
        Sets global weight decay via AdamWeightDecay optimizer
        Args:
          wd(float): weight decay
        Returns:
          None
        ```
        &#34;&#34;&#34;
        self._recompile(wd=wd)
        return

    def evaluate(
        self,
        test_data=None,
        print_report=True,
        save_path=&#34;ktrain_classification_report.csv&#34;,
        class_names=[],
    ):
        &#34;&#34;&#34;
        ```
        alias for self.validate().
        Returns confusion matrix and optionally prints
        a classification report.
        This is currently only supported for binary and multiclass
        classification, not multilabel classification.

        By default, this uses val_data, as supplied to ktrain.get_learner().
        Other validation or test data can be optionally be supplied as argument via &lt;test_data&gt; argument.
        Supply class_names to include labels instead of intenger class integer values in classification report.
        Args:
          test_data(Dataset|np.ndarray): test or validation data.  If None, self.val_data is used.
          print_report(bool): If True, classification report will be printed. If False, report will be saved to CSV
                              at save_path. Not applicable to regression models.
                              Not applicable to regression models.
          save_path(str): Classification report will be saved to this file path/name if print_report=False
                          Not applicable to regression models.
          class_names(list): list of class names to be used in classification report instead of
                             class integer IDs.
        ```
        &#34;&#34;&#34;
        return self.validate(
            val_data=test_data,
            print_report=print_report,
            save_path=save_path,
            class_names=class_names,
        )

    def validate(
        self,
        val_data=None,
        print_report=True,
        save_path=&#34;ktrain_classification_report.csv&#34;,
        class_names=[],
    ):
        &#34;&#34;&#34;
        ```
        Returns confusion matrix and optionally prints
        a classification report.
        This is currently only supported for binary and multiclass
        classification, not multilabel classification.

        By default, this uses val_data, as supplied to ktrain.get_learner().
        Other validation or test data can be optionally be supplied as argument.
        Supply class_names to include labels instead of intenger class integer values in classification report.
        Args:
          val_data(Dataset|np.ndarray): validation data.  If None, self.val_data is used.
          print_report(bool): If True, classification report will be printed. If False, report will be saved to CSV
                              at save path. Not applicable to regression models.
          save_path(str): Classification report will be saved to this file path/name if print_report=False
          class_names(list): list of class names to be used in classification report instead of
                             class integer IDs.
        ```
        &#34;&#34;&#34;
        if val_data is not None:
            val = val_data
        else:
            val = self.val_data

        classification, multilabel = U.is_classifier(self.model)
        if not classification:
            # warnings.warn(&#39;learner.validate is only for classification problems. &#39;
            #&#39;For regression, etc., use learner.predict and learner.ground_truth &#39;
            #&#39;to manually validate.&#39;)
            # return
            pass

        if U.is_multilabel(val) or multilabel:
            warnings.warn(&#34;multilabel confusion matrices not yet supported&#34;)
            return
        y_pred = self.predict(val_data=val)
        y_true = self.ground_truth(val_data=val)
        y_pred = np.squeeze(y_pred)
        y_true = np.squeeze(y_true)

        # regression evaluation
        if not classification:
            from sklearn.metrics import mean_absolute_error, mean_squared_error

            regout = []
            metrics = U.metrics_from_model(self.model)
            for m in metrics:
                if m in [&#34;mae&#34;, &#34;mean_absolute_error&#34;]:
                    regout.append((m, mean_absolute_error(y_true, y_pred)))
                elif m in [&#34;mse&#34;, &#34;mean_squared_error&#34;]:
                    regout.append((m, mean_squared_error(y_true, y_pred)))
            if not regout:
                warnings.warn(
                    &#34;%s is not supported by validate/evaluate - falling back to MAE&#34;
                )
                regout.append((&#34;mae&#34;, mean_absolute_error(y_true, y_pred)))
            return regout

        if len(y_pred.shape) == 1:
            y_pred = np.where(y_pred &gt; 0.5, 1, 0)
            y_true = np.where(y_true &gt; 0.5, 1, 0)
        else:
            y_pred = np.argmax(y_pred, axis=1)
            y_true = np.argmax(y_true, axis=1)
        if print_report or save_path is not None:
            if class_names:
                try:
                    class_names = [str(s) for s in class_names]
                except:
                    pass
                report = classification_report(
                    y_true,
                    y_pred,
                    target_names=class_names,
                    output_dict=not print_report,
                )
            else:
                report = classification_report(
                    y_true, y_pred, output_dict=not print_report
                )
            if print_report:
                print(report)
            else:
                df = pd.DataFrame(report).transpose()
                df.to_csv(save_path)
                print(&#34;classification report saved to: %s&#34; % (save_path))
            cm_func = confusion_matrix
        cm = confusion_matrix(y_true, y_pred)
        return cm

    def _check_val(self, val_data):
        if val_data is not None:
            val = val_data
        else:
            val = self.val_data
        if val is None:
            raise Exception(
                &#34;val_data must be supplied to get_learner or view_top_losses&#34;
            )
        return val

    def top_losses(self, n=4, val_data=None, preproc=None):
        &#34;&#34;&#34;
        ```
        Computes losses on validation set sorted by examples with top losses
        Args:
          n(int or tuple): a range to select in form of int or tuple
                          e.g., n=8 is treated as n=(0,8)
          val_data:  optional val_data to use instead of self.val_data
          preproc (Preprocessor): A TextPreprocessor or ImagePreprocessor.
                                  For some data like text data, a preprocessor
                                  is required to undo the pre-processing
                                   to correctly view raw data.
        Returns:
            list of n tuples where first element is either
            filepath or id of validation example and second element
            is loss.
        ```
        &#34;&#34;&#34;

        # check validation data and arguments
        if val_data is not None:
            val = val_data
        else:
            val = self.val_data
        if val is None:
            raise Exception(&#34;val_data must be supplied to get_learner or top_losses&#34;)
        if type(n) == type(42):
            n = (0, n)

        # multilabel = True if U.is_multilabel(val) else False
        classification, multilabel = U.is_classifier(self.model)

        # get predicictions and ground truth
        y_pred = self.predict(val_data=val)
        y_true = self.ground_truth(val_data=val)
        y_true = y_true.astype(&#34;float32&#34;)

        # adjust y_true for regression problems
        if (
            not classification
            and len(y_true.shape) == 1
            and (len(y_pred.shape) == 2 and y_pred.shape[1] == 1)
        ):
            y_true = np.expand_dims(y_true, -1)

        # compute loss
        # this doesn&#39;t work in tf.keras 1.14
        # losses = self.model.loss_functions[0](tf.convert_to_tensor(y_true), tf.convert_to_tensor(y_pred))
        # if U.is_tf_keras():
        # L = self.model.loss_functions[0].fn
        # else:
        # L = self.model.loss_functions[0]
        L = U.loss_fn_from_model(self.model)
        losses = L(tf.convert_to_tensor(y_true), tf.convert_to_tensor(y_pred))
        if DISABLE_V2_BEHAVIOR:
            losses = tf.Session().run(losses)
        else:
            losses = losses.numpy()

        class_names = [] if preproc is None else preproc.get_classes()
        if preproc is None:
            class_fcn = lambda x: &#34;%s&#34; % (x)
        else:
            class_fcn = lambda x: class_names[x]

        # regression output modifications
        if not classification:
            if len(y_pred.shape) == 2 and y_pred.shape[1] == 1:
                y_pred = np.squeeze(y_pred)
                y_pred = np.around(y_pred, 2)
            if len(y_true.shape) == 2 and y_true.shape[1] == 1:
                y_true = np.squeeze(y_true)
                y_true = np.around(y_true, 2)

        # sort by loss and prune correct classifications, if necessary
        if classification and not multilabel:
            y_pred = np.squeeze(y_pred)
            y_true = np.squeeze(y_true)
            if len(y_pred.shape) == 1:
                y_p = np.where(y_pred &gt; 0.5, 1, 0)
                y_t = np.where(y_true &gt; 0.5, 1, 0)
            else:
                y_p = np.argmax(y_pred, axis=1)
                y_t = np.argmax(y_true, axis=1)
            tups = [
                (i, x, class_fcn(y_t[i]), class_fcn(y_p[i]))
                for i, x in enumerate(losses)
                if y_p[i] != y_t[i]
            ]
        else:
            tups = [
                (i, x, y_true[i], np.around(y_pred[i], 2)) for i, x in enumerate(losses)
            ]
        tups.sort(key=operator.itemgetter(1), reverse=True)

        # prune by given range
        tups = tups[n[0] : n[1]] if n is not None else tups
        return tups

    def view_top_losses(self, n=4, preproc=None, val_data=None):
        &#34;&#34;&#34;
        ```
        View observations with top losses in validation set.
        Musta be overridden by Learner subclasses.
        ```
        &#34;&#34;&#34;
        raise NotImplementedError(
            &#34;view_top_losses must be overriden by Learner subclass&#34;
        )

    def _make_model_folder(self, fpath):
        if os.path.isfile(fpath):
            raise ValueError(
                f&#34;There is an existing file named {fpath}. &#34;
                + &#34;Please use dfferent value for fpath.&#34;
            )
        elif os.path.exists(fpath):
            # warnings.warn(&#39;model is being saved to folder that already exists: %s&#39; % (fpath))
            pass
        elif not os.path.exists(fpath):
            os.makedirs(fpath)

    def save_model(self, fpath):
        &#34;&#34;&#34;
        ```
        a wrapper to model.save
        Args:
          fpath(str): path to folder in which to save model
        Returns:
          None
        ```
        &#34;&#34;&#34;
        self._make_model_folder(fpath)
        self.model.save(os.path.join(fpath, U.MODEL_NAME), save_format=&#34;h5&#34;)
        return

    def load_model(self, fpath, custom_objects=None, **kwargs):
        &#34;&#34;&#34;
        ```
        loads model from folder.
        Note: **kwargs included for backwards compatibility only, as TransformerTextClassLearner.load_model was removed in v0.18.0.
        Args:
          fpath(str): path to folder containing model
          custom_objects(dict): custom objects required to load model.
                                For models included with ktrain, this is populated automatically
                                and can be disregarded.

        ```
        &#34;&#34;&#34;
        self.model = _load_model(
            fpath, train_data=self.train_data, custom_objects=custom_objects
        )
        return

    def _is_adamlike(self):
        &#34;&#34;&#34;
        ```
        checks whether optimizer attached to model is an
        &#34;Adam-like&#34; optimizer with beta_1 parameter.
        ```
        &#34;&#34;&#34;
        return self.model is not None and hasattr(self.model.optimizer, &#34;beta_1&#34;)

    def _recompile(self, wd=None):
        metrics = U.metrics_from_model(self.model)
        if (
            wd is not None
            and wd &gt; 0
            and type(self.model.optimizer).__name__ != &#34;AdamWeightDecay&#34;
        ):
            warnings.warn(
                &#34;recompiling model to use AdamWeightDecay as opimizer with weight decay of %s&#34;
                % (wd)
            )
            optimizer = U.get_default_optimizer(wd=wd)
        elif wd is not None and wd &gt; 0:
            optimizer = U.get_default_optimizer(wd=wd)
        elif wd is not None and wd == 0:
            optimizer = U.DEFAULT_OPT
        else:  # wd is None -&gt; don&#39;t modify optimizer
            optimizer = self.model.optimizer
        self.model.compile(optimizer=optimizer, loss=self.model.loss, metrics=metrics)

        return

    def set_model(self, model):
        &#34;&#34;&#34;
        ```
        replace model in this Learner instance
        ```
        &#34;&#34;&#34;
        if not isinstance(model, keras.Model):
            raise ValueError(&#34;model must be of instance keras.Model&#34;)
        self.model = model
        self.history = None
        return

    def freeze(self, freeze_range=None):
        &#34;&#34;&#34;
        ```
        If freeze_range is None, makes all layers trainable=False except last Dense layer.
        If freeze_range is given, freezes the first &lt;freeze_range&gt; layers and
        unfrezes all remaining layers.
        NOTE:      Freeze method does not currently work with
                   multi-GPU models.  If you are using the load_imagemodel method,
                   please use the freeze_layers argument of load_imagemodel
                   to freeze layers.
        Args:
            freeze_range(int): number of layers to freeze
        Returns:
            None
        ```
        &#34;&#34;&#34;

        if freeze_range is None:
            # freeze everything except last Dense layer
            # first find last dense layer
            dense_id = None
            for i, layer in reversed(list(enumerate(self.model.layers))):
                if isinstance(layer, keras.layers.Dense):
                    dense_id = i
                    break
            if dense_id is None:
                raise Exception(&#34;cannot find Dense layer in this model&#34;)
            for i, layer in enumerate(self.model.layers):
                if i &lt; dense_id:
                    layer.trainable = False
                else:
                    layer.trainable = True
        else:
            # freeze all layers up to and including layer_id
            if type(freeze_range) != type(1) or freeze_range &lt; 1:
                raise ValueError(&#34;freeze_range must be integer &gt; 0&#34;)
            for i, layer in enumerate(self.model.layers):
                if i &lt; freeze_range:
                    layer.trainable = False
                else:
                    layer.trainable = True
        self._recompile()
        return

    def unfreeze(self, exclude_range=None):
        &#34;&#34;&#34;
        ```
        Make every layer trainable except those in exclude_range.
        unfreeze is simply a proxy method to freeze.
        NOTE:      Unfreeze method does not currently work with
                   multi-GPU models.  If you are using the load_imagemodel method,
                   please use the freeze_layers argument of load_imagemodel
                   to freeze layers.
        ```
        &#34;&#34;&#34;
        # make all layers trainable
        for i, layer in enumerate(self.model.layers):
            layer.trainable = True
        if exclude_range:
            for i, layer in enumerate(self.model.layers[:exclude_range]):
                layer.trainable = False
        self._recompile()
        return

    def reset_weights(self, verbose=1):
        &#34;&#34;&#34;
        ```
        Re-initializes network with original weights
        ```
        &#34;&#34;&#34;

        if os.path.isfile(self._original_weights):
            self.model.load_weights(self._original_weights)
            self.history = None
            U.vprint(&#34;Model weights have been reset.&#34;, verbose=verbose)
        else:
            warnings.warn(
                &#34;Weights have not been reset because the original weights file &#34;
                + &#34;(%s) no longer exists.&#34; % (self._original_weights)
            )
        return

    def lr_find(
        self,
        start_lr=1e-7,
        lr_mult=1.01,
        max_epochs=None,
        class_weight=None,
        stop_factor=4,
        show_plot=False,
        suggest=False,
        restore_weights_only=False,
        verbose=1,
    ):
        &#34;&#34;&#34;
        ```
        Plots loss as learning rate is increased.  Highest learning rate
        corresponding to a still falling loss should be chosen.

        If you find the LR finder is running for more epochs than you&#39;d prefer,
        you can set max_epochs (e.g., max_epochs=5) to estimate LR with a
        smaller sample size.

        If lr_mult is supplied and max_epochs is None, LR will increase until loss diverges.
        Reasonable values of lr_mult are between 1.01 and 1.05.

        If max_epochs is supplied, lr_mult argument is ignored and computed automatically.

        Reference: https://arxiv.org/abs/1506.01186

        Args:
            start_lr (float): smallest lr to start simulation
            lr_mult (float): multiplication factor to increase LR.
                             Ignored if max_epochs is supplied.
            max_epochs (int):  maximum number of epochs to simulate.
                               lr_mult is ignored if max_epoch is supplied.
                               Default is None. Set max_epochs to an integer
                               (e.g., 5) if lr_find is taking too long
                               and running for more epochs than desired.
            class_weight(dict): class_weight parameter passed to model.fit
                                for imbalanced datasets.
            stop_factor(int): factor used to determine threhsold that loss
                              must exceed to stop training simulation.
                              Increase this if loss is erratic and lr_find
                              exits too early.
            show_plot (bool):  If True, automatically invoke lr_plot
            restore_weights_only(bool): If True, when training simulation is complete,
                                        the model weights only are restored, but not
                                        the original optimizer weights.
                                        In at least a few cases, this seems to improve performance
                                        when actual training begins. Further investigation is needed,
                                        so it is False by default.
            verbose (bool): specifies how much output to print
        Returns:
            None
        ```
        &#34;&#34;&#34;
        # dep_fix: bug in TF 2.2 and 2.3
        if version.parse(tf.__version__) &gt; version.parse(&#34;2.1&#34;) and version.parse(
            tf.__version__
        ) &lt; version.parse(&#34;2.4&#34;):
            if max_epochs is None:
                raise ValueError(
                    &#34;Due to a bug in TensorFlow 2.2 and 2.3, the max_epochs argument is temporarily required. &#34;
                    + &#34;Please re-run with max_epochs (e.g., max_epochs=5). \n&#34;
                    + &#34;More info: https://github.com/tensorflow/tensorflow/issues/41174#issuecomment-656330268&#34;
                )

        U.vprint(
            &#34;simulating training for different learning rates... this may take a few moments...&#34;,
            verbose=verbose,
        )
        # save current weights and temporarily restore original weights
        # dep_fix: temporarily use save_model instead of save_weights as default due to https://github.com/tensorflow/tensorflow/issues/41116
        _weights_only = True
        if restore_weights_only:
            new_file, weightfile = tempfile.mkstemp()
            self.model.save_weights(weightfile)
        else:
            temp_folder = tempfile.mkdtemp()
            self.save_model(temp_folder)

        # compute steps_per_epoch
        num_samples = U.nsamples_from_data(self.train_data)
        bs = (
            self.train_data.batch_size
            if hasattr(self.train_data, &#34;batch_size&#34;)
            else self.batch_size
        )
        if U.is_iter(self.train_data):
            use_gen = True
            steps_per_epoch = num_samples // bs
        else:
            use_gen = False
            steps_per_epoch = np.ceil(num_samples / bs)

        # check steps_per_epoch
        if steps_per_epoch &lt;= 64 and max_epochs is None:
            warnings.warn(
                &#34;max_epochs is being set to 5 since steps per epoch is small. &#34;
                + &#34;If you wish to estimate LR using more epochs, set max_epochs manually.&#34;
            )
            max_epochs = 5

        try:
            # track and plot learning rates
            self.lr_finder = LRFinder(self.model, stop_factor=stop_factor)
            self.lr_finder.find(
                self._prepare(self.train_data),
                steps_per_epoch,
                use_gen=use_gen,
                start_lr=start_lr,
                lr_mult=lr_mult,
                max_epochs=max_epochs,
                class_weight=class_weight,
                workers=self.workers,
                use_multiprocessing=self.use_multiprocessing,
                batch_size=self.batch_size,
                verbose=verbose,
            )
        except KeyboardInterrupt:
            # re-load current weights
            # self.model.load_weights(weightfile)
            self.load_model(temp_folder)
            return

        # re-load current weights
        # dep_fix: temporarily use load_model instead of load_weights as default due to https://github.com/tensorflow/tensorflow/issues/41116
        if restore_weights_only:
            self.model.load_weights(weightfile)
        else:
            self.load_model(temp_folder)

        # instructions to invoker
        U.vprint(&#34;\n&#34;, verbose=verbose)
        U.vprint(&#34;done.&#34;, verbose=verbose)
        if show_plot:
            U.vprint(
                &#34;Visually inspect loss plot and select learning rate associated with falling loss&#34;,
                verbose=verbose,
            )
            self.lr_plot(suggest=suggest)
        else:
            U.vprint(
                &#34;Please invoke the Learner.lr_plot() method to visually inspect &#34;
                &#34;the loss plot to help identify the maximal learning rate &#34;
                &#34;associated with falling loss.&#34;,
                verbose=verbose,
            )
        return

    def lr_estimate(self):
        &#34;&#34;&#34;
        ```
        Return numerical estimates of lr using two different methods:
          1. lr associated with minum numerical gradient (None if gradient computation fails)
          2. lr associated with minimum loss divided by 10
          3. lr associated with longest valley
        Since none of these methods are fool-proof and can
        potentially return bad estimates, it is recommended that you
        examine the plot generated by lr_plot to estimate the learning rate.
        Returns:
          tuple: tuple of the form (float, float)
        ```
        &#34;&#34;&#34;
        if self.lr_finder is None or not self.lr_finder.find_called():
            raise ValueError(&#34;Please call lr_find first.&#34;)
        return self.lr_finder.estimate_lr()

    def lr_plot(
        self, n_skip_beginning=10, n_skip_end=5, suggest=False, return_fig=False
    ):
        &#34;&#34;&#34;
        ```
        Plots the loss vs. learning rate to help identify
        The maximal learning rate associated with a falling loss.
        The nskip_beginning and n_skip_end arguments can be used
        to &#34;zoom in&#34; on the plot.
        Args:
            n_skip_beginning(int): number of batches to skip on the left.
            n_skip_end(int):  number of batches to skip on the right.
            suggest(bool): will highlight numerical estimate
                           of best lr if True - methods adapted from fastai
            return_fig(bool): If True, return matplotlib.figure.Figure
        Returns:
          matplotlib.figure.Figure if return_fig else None
        ```
        &#34;&#34;&#34;
        # dep_fix: bug in TF 2.2 and 2.3
        if version.parse(tf.__version__) &gt; version.parse(&#34;2.1&#34;) and version.parse(
            tf.__version__
        ) &lt; version.parse(&#34;2.4&#34;):
            if n_skip_end == 5:
                n_skip_end = 10

        if self.lr_finder is None or not self.lr_finder.find_called():
            raise ValueError(&#34;Please call lr_find first.&#34;)
        return self.lr_finder.plot_loss(
            n_skip_beginning=n_skip_beginning,
            n_skip_end=n_skip_end,
            suggest=suggest,
            return_fig=return_fig,
        )

    def plot(self, plot_type=&#34;loss&#34;, return_fig=False):
        &#34;&#34;&#34;
        ```
        plots training history
        Args:
          plot_type (str):  A valid value in tf.keras History.  Either a built-in value  {&#39;loss&#39;, &#39;lr&#39;, &#39;momentum&#39;} or
                            other values previously specified by user.  For instance, if &#39;mae&#39; and/or &#39;mse&#39; is previously specified as metrics
                            when creating model, then these values can also be specified.
          return_fig(bool):  If True, return matplotlib.figure.Figure
        Return:
          matplotlib.figure.Figure if return_fig else None
        ```
        &#34;&#34;&#34;
        if self.history is None:
            raise Exception(&#34;No training history - did you train the model yet?&#34;)
        if not isinstance(plot_type, str):
            raise ValueError(&#34;plot_type must be str/string&#34;)

        fig = None
        if plot_type == &#34;loss&#34;:
            plt.plot(self.history.history[&#34;loss&#34;])
            if &#34;val_loss&#34; in self.history.history:
                plt.plot(self.history.history[&#34;val_loss&#34;])
                legend_items = [&#34;train&#34;, &#34;validation&#34;]
            else:
                legend_items = [&#34;train&#34;]
            plt.title(&#34;Model Loss&#34;)
            plt.ylabel(&#34;loss&#34;)
            plt.xlabel(&#34;epoch&#34;)
            plt.legend(legend_items, loc=&#34;upper left&#34;)
        elif plot_type == &#34;lr&#34;:
            if &#34;lr&#34; not in self.history.history:
                raise ValueError(
                    &#34;no lr in history: are you sure you used autofit or fit_onecycle to train?&#34;
                )
            plt.plot(self.history.history[&#34;lr&#34;])
            plt.title(&#34;LR Schedule&#34;)
            plt.ylabel(&#34;lr&#34;)
            plt.xlabel(&#34;iterations&#34;)
        elif plot_type == &#34;momentum&#34;:
            if &#34;momentum&#34; not in self.history.history:
                raise ValueError(
                    &#34;no momentum history: are you sure you used autofit or fit_onecycle to train?&#34;
                )
            plt.plot(self.history.history[&#34;momentum&#34;])
            plt.title(&#34;Momentum Schedule&#34;)
            plt.ylabel(&#34;momentum&#34;)
            plt.xlabel(&#34;iterations&#34;)
        else:
            if plot_type not in self.history.history:
                raise ValueError(
                    f&#34;no {plot_type} in history: are you sure {plot_type} exists in history?&#34;
                )
            plt.plot(self.history.history[plot_type])

            val_key = f&#34;val_{plot_type}&#34;
            if val_key in self.history.history:
                plt.plot(self.history.history[val_key])
                legend_items = [&#34;train&#34;, &#34;validation&#34;]
            else:
                warnings.warn(
                    f&#34;Validation value for {plot_type} wasn&#39;t found in history&#34;
                )
                legend_items = [&#34;train&#34;]

            plt.title(f&#34;History of {plot_type}&#34;)
            plt.ylabel(plot_type)
            plt.xlabel(&#34;epoch&#34;)
            plt.legend(legend_items, loc=&#34;upper left&#34;)
        fig = plt.gcf()
        plt.show()
        if return_fig:
            return fig
        return

    def print_layers(self, show_wd=False):
        &#34;&#34;&#34;
        ```
        prints the layers of the model along with indices
        ```
        &#34;&#34;&#34;
        if show_wd:
            warnings.warn(
                &#34;set_weight_decay now uses AdamWeightDecay instead of kernel_regularizers.&#34;
            )
        for i, layer in enumerate(self.model.layers):
            if show_wd and hasattr(layer, &#34;kernel_regularizer&#34;):
                reg = layer.kernel_regularizer
                if hasattr(reg, &#34;l2&#34;):
                    wd = reg.l2
                elif hasattr(reg, &#34;l1&#34;):
                    wd = reg.l1
                else:
                    wd = None
                print(&#34;%s (trainable=%s, wd=%s) : %s&#34; % (i, layer.trainable, wd, layer))
            else:
                print(&#34;%s (trainable=%s) : %s&#34; % (i, layer.trainable, layer))
        return

    def layer_output(self, layer_id, example_id=0, use_val=False):
        # should implemented in subclass
        raise NotImplementedError

    def set_lr(self, lr):
        K.set_value(self.model.optimizer.lr, lr)
        return

    def _check_cycles(self, n_cycles, cycle_len, cycle_mult):
        if type(n_cycles) != type(1) or n_cycles &lt; 1:
            raise ValueError(&#34;n_cycles must be &gt;= 1&#34;)
        if type(cycle_mult) != type(1) or cycle_mult &lt; 1:
            raise ValueError(&#34;cycle_mult must by &gt;= 1&#34;)
        if cycle_len is not None:
            if type(cycle_len) != type(1) or cycle_len &lt; 1:
                raise ValueError(&#34;cycle_len must either be None or &gt;= 1&#34;)

        # calculate number of epochs
        if cycle_len is None:
            epochs = n_cycles
        else:
            epochs = 0
            tmp_cycle_len = cycle_len
            for i in range(n_cycles):
                epochs += tmp_cycle_len
                tmp_cycle_len *= cycle_mult
        return epochs

    def _cb_sgdr(
        self, max_lr, steps_per_epoch, cycle_len, cycle_mult, lr_decay=1.0, callbacks=[]
    ):
        if callbacks and &#34;SGDRScheduler&#34; in [type(cb).__name__ for cb in callbacks]:
            return callbacks
        # configuration
        min_lr = 1e-9
        if max_lr &lt;= min_lr:
            min_lr = max_lr / 10

        #  use learning_rate schedule
        if cycle_len is not None:
            if not isinstance(callbacks, list):
                callbacks = []
            from .lroptimize.sgdr import SGDRScheduler

            schedule = SGDRScheduler(
                min_lr=min_lr,
                max_lr=max_lr,
                steps_per_epoch=steps_per_epoch,
                lr_decay=lr_decay,
                cycle_length=cycle_len,
                mult_factor=cycle_mult,
            )
            callbacks.append(schedule)
        if not callbacks:
            callbacks = None
        return callbacks

    def _cb_checkpoint(self, folder, callbacks=[]):
        if callbacks and &#34;ModelCheckpoint&#34; in [type(cb).__name__ for cb in callbacks]:
            return callbacks
        if folder is not None:
            os.makedirs(folder, exist_ok=True)
            if not isinstance(callbacks, list):
                callbacks = []
            # filepath=os.path.join(folder, &#34;weights-{epoch:02d}-{val_loss:.2f}.hdf5&#34;)
            filepath = os.path.join(folder, &#34;weights-{epoch:02d}.hdf5&#34;)
            callbacks.append(
                keras.callbacks.ModelCheckpoint(
                    filepath, save_best_only=False, save_weights_only=True
                )
            )
        if not callbacks:
            callbacks = None
        return callbacks

    def _cb_earlystopping(self, early_stopping, callbacks=[]):
        if callbacks and &#34;EarlyStopping&#34; in [type(cb).__name__ for cb in callbacks]:
            return callbacks
        if early_stopping:
            if not isinstance(callbacks, list):
                callbacks = []
            # if StrictVersion(keras.__version__) &gt;= StrictVersion(&#39;2.2.3&#39;):
            try:
                callbacks.append(
                    keras.callbacks.EarlyStopping(
                        monitor=&#34;val_loss&#34;,
                        min_delta=0,
                        patience=early_stopping,
                        restore_best_weights=True,
                        verbose=0,
                        mode=&#34;auto&#34;,
                    )
                )
            except TypeError:
                warnings.warn(
                    &#34;&#34;&#34;
                              The early_stopping=True argument relies on EarlyStopping.restore_best_weights,
                              which is only supported on Keras 2.2.3 or greater.
                              For now, we are falling back to EarlyStopping.restore_best_weights=False.
                              Please use checkpoint_folder option in fit() to restore best weights.&#34;&#34;&#34;
                )
                callbacks.append(
                    keras.callbacks.EarlyStopping(
                        monitor=&#34;val_loss&#34;,
                        min_delta=0,
                        patience=early_stopping,
                        verbose=0,
                        mode=&#34;auto&#34;,
                    )
                )

        if not callbacks:
            callbacks = None
        return callbacks

    def _prepare(self, data, train=True):
        &#34;&#34;&#34;
        ```
        Subclasses can override this method if data
        needs to be specially-prepared prior to invoking fit methods
        Args:
          data:  dataset
          train(bool):  If True, prepare for training. Otherwise, prepare for evaluation.
        ```
        &#34;&#34;&#34;
        if data is None:
            return None

        if hasattr(data, &#34;to_tfdataset&#34;):
            return data.to_tfdataset(train=train)
        else:
            return data

    @abstractmethod
    def fit(self, lr, n_cycles, cycle_len=None, cycle_mult=1, batch_size=U.DEFAULT_BS):
        pass

    def fit_onecycle(
        self,
        lr,
        epochs,
        checkpoint_folder=None,
        cycle_momentum=True,
        max_momentum=0.95,
        min_momentum=0.85,
        class_weight=None,
        callbacks=[],
        steps_per_epoch=None,
        verbose=1,
    ):
        &#34;&#34;&#34;
        ```
        Train model using a version of Leslie Smith&#39;s 1cycle policy.
        This method can be used with any optimizer. Thus,
        cyclical momentum is not currently implemented.

        Args:
            lr (float): (maximum) learning rate.
                       It is recommended that you estimate lr yourself by
                       running lr_finder (and lr_plot) and visually inspect plot
                       for dramatic loss drop.
            epochs (int): Number of epochs.  Number of epochs
            checkpoint_folder (string): Folder path in which to save the model weights
                                        for each epoch.
                                        File name will be of the form:
                                        weights-{epoch:02d}-{val_loss:.2f}.hdf5
            cycle_momentum (bool):    If True and optimizer is Adam, Nadam, or Adamax, momentum of
                                      optimzer will be cycled between 0.95 and 0.85 as described in
                                      https://arxiv.org/abs/1803.09820.
                                      Only takes effect if Adam, Nadam, or Adamax optimizer is used.
            max_momentum(float): Maximum momentum to use if cycle_momentum=True
            min_momentum(float): minimum momentum to use if cycle_momentum=True
            class_weight (dict):       Optional dictionary mapping class indices (integers) to a weight (float)
            callbacks (list): list of Callback instances to employ during training
            steps_per_epoch(int):    Steps per epoch. If None, then, math.ceil(num_samples/batch_size) is used.
                                     Ignored unless training dataset is generator.
            verbose (bool):  verbose mode
        ```
        &#34;&#34;&#34;
        if not self._is_adamlike() and cycle_momentum:
            warnings.warn(
                &#34;cyclical momentum has been disabled because &#34;
                + &#39;optimizer is not &#34;Adam-like&#34; with beta_1 param&#39;
            )
            cycle_momentum = False

        num_samples = U.nsamples_from_data(self.train_data)
        if steps_per_epoch is None:
            steps_per_epoch = math.ceil(num_samples / self.batch_size)

        # setup callbacks for learning rates and early stopping
        if not callbacks:
            kcallbacks = []
        else:
            kcallbacks = callbacks[:]
        if cycle_momentum:
            max_momentum = max_momentum
            min_momentum = min_momentum
        else:
            max_momentum = None
            min_momentum = None

        from .lroptimize.triangular import CyclicLR

        clr = CyclicLR(
            base_lr=lr / 10,
            max_lr=lr,
            step_size=math.ceil((steps_per_epoch * epochs) / 2),
            reduce_on_plateau=0,
            max_momentum=max_momentum,
            min_momentum=min_momentum,
            verbose=verbose,
        )
        kcallbacks.append(clr)

        # start training
        policy = &#34;onecycle&#34;
        U.vprint(&#34;\n&#34;, verbose=verbose)
        U.vprint(
            &#34;begin training using %s policy with max lr of %s...&#34; % (policy, lr),
            verbose=verbose,
        )
        hist = self.fit(
            lr,
            epochs,
            early_stopping=None,
            checkpoint_folder=checkpoint_folder,
            verbose=verbose,
            class_weight=class_weight,
            callbacks=kcallbacks,
            steps_per_epoch=steps_per_epoch,
        )
        hist.history[&#34;lr&#34;] = clr.history[&#34;lr&#34;]
        hist.history[&#34;iterations&#34;] = clr.history[&#34;iterations&#34;]
        if cycle_momentum:
            hist.history[&#34;momentum&#34;] = clr.history[&#34;momentum&#34;]
        self.history = hist
        return hist

    def autofit(
        self,
        lr,
        epochs=None,
        early_stopping=None,
        reduce_on_plateau=None,
        reduce_factor=2,
        cycle_momentum=True,
        max_momentum=0.95,
        min_momentum=0.85,
        monitor=&#34;val_loss&#34;,
        checkpoint_folder=None,
        class_weight=None,
        callbacks=[],
        steps_per_epoch=None,
        verbose=1,
    ):
        &#34;&#34;&#34;
        ```
        Automatically train model using a default learning rate schedule shown to work well
        in practice.  By default, this method currently employs a triangular learning
        rate policy (https://arxiv.org/abs/1506.01186).
        During each epoch, this learning rate policy varies the learning rate from lr/10 to lr
        and then back to a low learning rate that is near-zero.
        If epochs is None, then early_stopping and reduce_on_plateau are atomatically
        set to 5 and 2, respectively.

        Args:
            lr (float): optional initial learning rate.  If missing,
                       lr will be estimated automatically.
                       It is recommended that you estimate lr yourself by
                       running lr_finder (and lr_plot) and visually inspect plot
                       for dramatic loss drop.
            epochs (int): Number of epochs.  If None, training will continue until
                          validation loss no longer improves after 5 epochs.
            early_stopping (int):     If not None, training will automatically stop after this many
                                      epochs of no improvement in validation loss.
                                      Upon completion, model will be loaded with weights from epoch
                                      with lowest validation loss.
                                      NOTE: If reduce_on_plateau is also enabled, then
                                      early_stopping must be greater than reduce_on_plateau.
                                      Example: early_stopping=6, reduce_on_plateau=3.
            reduce_on_plateau (int):  If not None, will lower learning rate when
                                      when validation loss fails to improve after
                                      the specified number of epochs.
                                      NOTE: If early_stopping is enabled, then
                                      reduce_on_plateu must be less than early_stopping.
                                      Example: early_stopping=6, reduce_on_plateau=3.
            reduce_factor (int):      Learning reate is reduced by this factor on plateau.
                                      Only takes effect if reduce_on_plateau &gt; 0.
            cycle_momentum (bool):    If True and optimizer is Adam, Nadam, or Adamax, momentum of
                                      optimzer will be cycled between 0.95 and 0.85 as described in
                                      https://arxiv.org/abs/1803.09820.
                                      Only takes effect if Adam, Nadam, or Adamax optimizer is used.
            max_momentum(float):  maximum momentum to use when cycle_momentum=True
            min_momentum(float): minimum momentum to use when cycle_momentum=True
            checkpoint_folder (string): Folder path in which to save the model weights
                                        for each epoch.
                                        File name will be of the form:
                                        weights-{epoch:02d}-{val_loss:.2f}.hdf5
            monitor (str):              what metric to monitor for early_stopping
                                        and reduce_on_plateau. Defaults to &#39;val_loss&#39;.
                                        Only used if early_stopping or reduce_on_plateau
                                        is enabled.
            class_weight (dict):       Optional dictionary mapping class indices (integers) to a weight (float)
            callbacks (list): list of Callback instances to employ during training
            steps_per_epoch(int):    Steps per epoch. If None, then, math.ceil(num_samples/batch_size) is used.
                                     Ignored unless training dataset is generator.
            verbose (bool):  verbose mode
        ```
        &#34;&#34;&#34;
        # check optimizer
        if not self._is_adamlike() and cycle_momentum:
            warnings.warn(
                &#34;cyclical momentum has been disabled because &#34;
                + &#39;optimizer is not &#34;Adam-like&#34; with beta_1 param&#39;
            )
            cycle_momentum = False

        # setup learning rate policy
        num_samples = U.nsamples_from_data(self.train_data)
        if steps_per_epoch is None:
            steps_per_epoch = math.ceil(num_samples / self.batch_size)
        step_size = math.ceil(steps_per_epoch / 2)

        # handle missing epochs
        if epochs is None:
            epochs = 1024
            if not early_stopping:
                early_stopping = U.DEFAULT_ES
                U.vprint(
                    &#34;early_stopping automatically enabled at patience=%s&#34;
                    % (U.DEFAULT_ES),
                    verbose=verbose,
                )
            if not reduce_on_plateau:
                reduce_on_plateau = U.DEFAULT_ROP
                U.vprint(
                    &#34;reduce_on_plateau automatically enabled at patience=%s&#34;
                    % (U.DEFAULT_ROP),
                    verbose=verbose,
                )
        if (
            reduce_on_plateau
            and early_stopping
            and (reduce_on_plateau &gt; early_stopping)
        ):
            warnings.warn(
                &#34;reduce_on_plateau=%s and is greater than &#34; % (reduce_on_plateau)
                + &#34;early_stopping=%s.  &#34; % (early_stopping)
                + &#34;Either reduce reduce_on_plateau or set early_stopping &#34;
                + &#34;to be higher.&#34;
            )

        # check monitor
        if reduce_on_plateau is not None or early_stopping is not None:
            if monitor.startswith(&#34;val_&#34;) and self.val_data is None:
                raise ValueError(
                    &#34;monitor is %s but no val_data was supplied.\nChange monitor or supply val_data to get_learner function.&#34;
                    % monitor
                )
            if monitor != &#34;val_loss&#34; and monitor not in self._monitor_metrics:
                raise ValueError(
                    &#34;monitor must be one of {%s}&#34; % (self._monitor_metrics)
                )

        # setup callbacks for learning rates and early stopping
        if not callbacks:
            kcallbacks = []
        else:
            kcallbacks = callbacks[:]
        if cycle_momentum:
            max_momentum = max_momentum
            min_momentum = min_momentum
        else:
            max_momentum = None
            min_momentum = None

        from .lroptimize.triangular import CyclicLR

        clr = CyclicLR(
            base_lr=lr / 10,
            max_lr=lr,
            step_size=step_size,
            verbose=verbose,
            monitor=monitor,
            reduce_on_plateau=reduce_on_plateau,
            reduce_factor=reduce_factor,
            max_momentum=max_momentum,
            min_momentum=min_momentum,
        )
        kcallbacks.append(clr)
        if early_stopping:
            kcallbacks.append(
                keras.callbacks.EarlyStopping(
                    monitor=monitor,
                    min_delta=0,
                    patience=early_stopping,
                    restore_best_weights=True,
                    verbose=1,
                    mode=&#34;auto&#34;,
                )
            )

        # start training
        U.vprint(&#34;\n&#34;, verbose=verbose)
        policy = &#34;triangular learning rate&#34;
        U.vprint(
            &#34;begin training using %s policy with max lr of %s...&#34; % (policy, lr),
            verbose=verbose,
        )
        hist = self.fit(
            lr,
            epochs,
            early_stopping=early_stopping,
            checkpoint_folder=checkpoint_folder,
            verbose=verbose,
            class_weight=class_weight,
            callbacks=kcallbacks,
            steps_per_epoch=steps_per_epoch,
        )
        hist.history[&#34;lr&#34;] = clr.history[&#34;lr&#34;]
        hist.history[&#34;iterations&#34;] = clr.history[&#34;iterations&#34;]
        if cycle_momentum:
            hist.history[&#34;momentum&#34;] = clr.history[&#34;momentum&#34;]
        self.history = hist
        return hist

    def ground_truth(self, val_data=None):
        if val_data is not None:
            val = val_data
        else:
            val = self.val_data
        if not val:
            raise Exception(&#34;val_data must be supplied to get_learner or ground_truth&#34;)
        return U.y_from_data(val)

    def predict(self, val_data=None):
        &#34;&#34;&#34;
        ```
        Makes predictions on validation set
        ```
        &#34;&#34;&#34;
        if val_data is not None:
            val = val_data
        else:
            val = self.val_data
        if val is None:
            raise Exception(&#34;val_data must be supplied to get_learner or predict&#34;)
        if U.is_iter(val):
            if hasattr(val, &#34;reset&#34;):
                val.reset()
            steps = np.ceil(U.nsamples_from_data(val) / val.batch_size)
            # *_generator methods are deprecated from TF 2.1.0
            # result = self.model.predict_generator(self._prepare(val, train=False),
            # steps=steps)
            result = self.model.predict(self._prepare(val, train=False), steps=steps)
            return result
        else:
            return self.model.predict(val[0], batch_size=self.eval_batch_size)


class ArrayLearner(Learner):
    &#34;&#34;&#34;
    ```
    Main class used to tune and train Keras models
    using Array data.  An objects of this class should be instantiated
    via the ktrain.get_learner method instead of directly.
    Main parameters are:


    model (Model):        A compiled instance of keras.engine.training.Model
    train_data (ndarray): A tuple of (x_train, y_train), where x_train and
                          y_train are numpy.ndarrays.
    val_data (ndarray):   A tuple of (x_test, y_test), where x_test and
                          y_test are numpy.ndarrays.
    ```
    &#34;&#34;&#34;

    def __init__(
        self,
        model,
        train_data=None,
        val_data=None,
        batch_size=U.DEFAULT_BS,
        eval_batch_size=U.DEFAULT_BS,
        workers=1,
        use_multiprocessing=False,
    ):
        super().__init__(
            model, workers=workers, use_multiprocessing=use_multiprocessing
        )
        self.train_data = train_data
        self.val_data = val_data
        self.batch_size = batch_size
        self.eval_batch_size = eval_batch_size
        return

    def fit(
        self,
        lr,
        n_cycles,
        cycle_len=None,
        cycle_mult=1,
        lr_decay=1,
        checkpoint_folder=None,
        early_stopping=None,
        verbose=1,
        class_weight=None,
        callbacks=[],
        steps_per_epoch=None,
    ):
        &#34;&#34;&#34;
        ```
        Trains the model. By default, fit is simply a wrapper for model.fit.
        When cycle_len parameter is supplied, an SGDR learning rate schedule is used.
        Trains the model.

        lr (float): learning rate
        n_cycles (int):  n_cycles
        cycle_len (int): If not None, decay learning rate over &lt;cycle_len&gt;
                         epochs until restarting/resetting learning rate to &lt;lr&gt;.
                         If None, lr remains constant
        cycle_mult (int): Increase cycle_len by factor of cycle_mult.
                          This will gradually elongate the cycle.
                          Has no effect if cycle_len is None.
        lr_decay(float): rate of decay of learning rate each cycle
        checkpoint_folder (string): Folder path in which to save the model weights
                                   for each epoch.
                                   File name will be of the form:
                                   weights-{epoch:02d}-{val_loss:.2f}.hdf5
        early_stopping (int):     If not None, training will automatically stop after this many
                                  epochs of no improvement in validation loss.
                                  Upon completion, model will be loaded with weights from epoch
                                  with lowest validation loss.
        callbacks (list):         list of Callback instances to employ during training
        class_weight (dict):       Optional dictionary mapping class indices (integers) to a weight (float)
        steps_per_epoch(int):    Steps per epoch. If None, then, math.ceil(num_samples/batch_size) is used.
                                 Ignored unless training dataset is generator (and in ArrayLearner instances).
        verbose (bool):           whether or not to show progress bar
        ```
        &#34;&#34;&#34;

        # check early_stopping
        if self.val_data is None and early_stopping is not None:
            raise ValueError(
                &#34;early_stopping monitors val_loss but validation data not set&#34;
            )

        # setup data
        x_train = self.train_data[0]
        y_train = self.train_data[1]
        validation = None
        if self.val_data:
            validation = (self.val_data[0], self.val_data[1])
        # setup learning rate schedule
        epochs = self._check_cycles(n_cycles, cycle_len, cycle_mult)
        self.set_lr(lr)

        # set call backs
        kcallbacks = callbacks if callbacks else None
        kcallbacks = self._cb_sgdr(
            lr,
            np.ceil(len(x_train) / self.batch_size),
            cycle_len,
            cycle_mult,
            lr_decay,
            callbacks=kcallbacks,
        )
        kcallbacks = self._cb_checkpoint(checkpoint_folder, callbacks=kcallbacks)
        kcallbacks = self._cb_earlystopping(early_stopping, callbacks=kcallbacks)
        sgdr = (
            [cb for cb in kcallbacks if type(cb).__name__ == &#34;SGDRScheduler&#34;]
            if kcallbacks
            else None
        )
        sgdr = sgdr[0] if sgdr else None

        # train model
        with warnings.catch_warnings():
            warnings.filterwarnings(&#34;ignore&#34;, message=&#34;.*Check your callbacks.*&#34;)
            hist = self.model.fit(
                self._prepare(x_train),
                self._prepare(y_train, train=False),
                batch_size=self.batch_size,
                epochs=epochs,
                validation_data=validation,
                verbose=verbose,
                shuffle=True,
                class_weight=class_weight,
                callbacks=kcallbacks,
            )

        if sgdr is not None:
            hist.history[&#34;lr&#34;] = sgdr.history[&#34;lr&#34;]
        self.history = hist

        if early_stopping:
            U.vprint(
                &#34;Weights from best epoch have been loaded into model.&#34;, verbose=verbose
            )
            # loss, acc = self.model.evaluate(self.val_data[0], self.val_data[1])
            # U.vprint(&#39;\n&#39;, verbose=verbose)
            # U.vprint(&#39;Early stopping due to no further improvement.&#39;, verbose=verbose)
            # U.vprint(&#39;final loss:%s, final score:%s&#39; % (loss, acc), verbose=verbose)

        return hist

    def layer_output(self, layer_id, example_id=0, use_val=False):
        &#34;&#34;&#34;
        ```
        Prints output of layer with index &lt;layer_id&gt; to help debug models.
        Uses first example (example_id=0) from training set, by default.
        ```
        &#34;&#34;&#34;

        inp = self.model.layers[0].input
        outp = self.model.layers[layer_id].output
        f_out = K.function([inp], [outp])
        if not use_val:
            example = self.train_data[0][example_id]
        else:
            example = self.val_data[0][example_id]
        layer_out = f_out(
            [
                np.array(
                    [
                        example,
                    ]
                )
            ]
        )[0]
        return layer_out

    def view_top_losses(self, n=4, preproc=None, val_data=None):
        &#34;&#34;&#34;
        ```
        Views observations with top losses in validation set.
        Typically over-ridden by Learner subclasses.
        Args:
         n(int or tuple): a range to select in form of int or tuple
                          e.g., n=8 is treated as n=(0,8)
         preproc (Preprocessor): A TextPreprocessor or ImagePreprocessor.
                                 For some data like text data, a preprocessor
                                 is required to undo the pre-processing
                                 to correctly view raw data.
          val_data:  optional val_data to use instead of self.val_data
        Returns:
            list of n tuples where first element is either
            filepath or id of validation example and second element
            is loss.
        ```
        &#34;&#34;&#34;
        val = self._check_val(val_data)

        # get top losses and associated data
        tups = self.top_losses(n=n, val_data=val, preproc=preproc)

        # get multilabel status and class names
        classes = preproc.get_classes() if preproc is not None else None
        # iterate through losses
        for tup in tups:
            # get data
            idx = tup[0]
            loss = tup[1]
            truth = tup[2]
            pred = tup[3]

            obs = val[0][idx]
            join_char = &#34; &#34;
            if preproc is not None:
                obs = preproc.undo(obs)
            if preproc is not None and isinstance(preproc, TextPreprocessor):
                if preproc.is_nospace_lang():
                    join_char = &#34;&#34;
            if type(obs) == str:
                obs = join_char.join(obs.split()[:512])
            print(&#34;----------&#34;)
            print(
                &#34;id:%s | loss:%s | true:%s | pred:%s)\n&#34;
                % (idx, round(loss, 2), truth, pred)
            )
            print(obs)
        return


class GenLearner(Learner):
    &#34;&#34;&#34;
    ```
    Main class used to tune and train Keras models
    using a Keras generator (e.g., DirectoryIterator).
    Objects of this class should be instantiated using the
    ktrain.get_learner function, rather than directly.

    Main parameters are:

    model (Model): A compiled instance of keras.engine.training.Model
    train_data (Iterator): a Iterator instance for training set
    val_data (Iterator):   A Iterator instance for validation set
    ```
    &#34;&#34;&#34;

    def __init__(
        self,
        model,
        train_data=None,
        val_data=None,
        batch_size=U.DEFAULT_BS,
        eval_batch_size=U.DEFAULT_BS,
        workers=1,
        use_multiprocessing=False,
    ):
        super().__init__(
            model, workers=workers, use_multiprocessing=use_multiprocessing
        )
        self.train_data = train_data
        self.val_data = val_data
        self.batch_size = batch_size
        self.eval_batch_size = eval_batch_size
        if self.train_data:
            self.train_data.batch_size = batch_size
        if self.val_data:
            self.val_data.batch_size = eval_batch_size
        return

    def fit(
        self,
        lr,
        n_cycles,
        cycle_len=None,
        cycle_mult=1,
        lr_decay=1.0,
        checkpoint_folder=None,
        early_stopping=None,
        class_weight=None,
        callbacks=[],
        steps_per_epoch=None,
        verbose=1,
    ):
        &#34;&#34;&#34;
        ```
        Trains the model. By default, fit is simply a wrapper for model.fit (for generators/sequences).
        When cycle_len parameter is supplied, an SGDR learning rate schedule is used.

        lr (float): learning rate
        n_cycles (int):  n_cycles
        cycle_len (int): If not None, decay learning rate over &lt;cycle_len&gt;
                         epochs until restarting/resetting learning rate to &lt;lr&gt;.
                         If None, lr remains constant
        cycle_mult (int): Increase cycle_len by factor of cycle_mult.
                          This will gradually elongate the cycle.
                          Has no effect if cycle_len is None.
        lr_decay (float): rate of decay of learning reach each cycle.
                          Has no effect if cycle_len is None
        checkpoint_folder (string): Folder path in which to save the model weights
                                   for each epoch.
                                   File name will be of the form:
                                   weights-{epoch:02d}-{val_loss:.2f}.hdf5
        early_stopping (int):     If not None, training will automatically stop after this many
                                  epochs of no improvement in validation loss.
                                  Upon completion, model will be loaded with weights from epoch
                                  with lowest validation loss.
        class_weight (dict):       Optional dictionary mapping class indices (integers) to a weight (float)
        callbacks (list):         list of Callback instances to employ during training
        steps_per_epoch(int):    Steps per epoch. If None, then, math.ceil(num_samples/batch_size) is used.
        verbose (boolean):       whether or not to print progress bar
        ```
        &#34;&#34;&#34;
        # check early_stopping
        if self.val_data is None and early_stopping is not None:
            raise ValueError(
                &#34;early_stopping monitors val_loss but validation data not set&#34;
            )

        # handle callbacks
        num_samples = U.nsamples_from_data(self.train_data)
        train_bs = (
            self.train_data.batch_size
            if hasattr(self.train_data, &#34;batch_size&#34;)
            else self.batch_size
        )
        if steps_per_epoch is None:
            steps_per_epoch = math.ceil(num_samples / train_bs)
        validation_steps = None
        if self.val_data is not None:
            val_bs = (
                self.val_data.batch_size
                if hasattr(self.val_data, &#34;batch_size&#34;)
                else self.batch_size
            )
            validation_steps = math.ceil(U.nsamples_from_data(self.val_data) / val_bs)

        epochs = self._check_cycles(n_cycles, cycle_len, cycle_mult)
        self.set_lr(lr)

        # set call backs
        kcallbacks = callbacks if callbacks else None
        kcallbacks = self._cb_sgdr(
            lr, steps_per_epoch, cycle_len, cycle_mult, lr_decay, callbacks=kcallbacks
        )
        kcallbacks = self._cb_checkpoint(checkpoint_folder, callbacks=kcallbacks)
        kcallbacks = self._cb_earlystopping(early_stopping, callbacks=kcallbacks)
        sgdr = (
            [cb for cb in kcallbacks if type(cb).__name__ == &#34;SGDRScheduler&#34;]
            if kcallbacks
            else None
        )
        sgdr = sgdr[0] if sgdr else None
        # if kcallbacks: print([type(cb).__name__ for cb in kcallbacks])

        # MNIST times per epoch on Titan V
        # workers=4, usemp=True 9 sec.
        # workers=1, usemp=True 12 sec.
        # workers=1, usemp=False 16 sec.
        # workers=4, usemp=False 30+ sec.
        # print(self.workers)
        # print(self.use_multiprocessing)

        # train model
        with warnings.catch_warnings():
            warnings.filterwarnings(&#34;ignore&#34;, message=&#34;.*Check your callbacks.*&#34;)
            fit_fn = self.model.fit
            hist = fit_fn(
                self._prepare(self.train_data),
                steps_per_epoch=steps_per_epoch,
                validation_steps=validation_steps,
                epochs=epochs,
                validation_data=self._prepare(self.val_data, train=False),
                workers=self.workers,
                use_multiprocessing=self.use_multiprocessing,
                verbose=verbose,
                shuffle=True,
                class_weight=class_weight,
                callbacks=kcallbacks,
            )
        if sgdr is not None:
            hist.history[&#34;lr&#34;] = sgdr.history[&#34;lr&#34;]
        self.history = hist

        if early_stopping:
            U.vprint(
                &#34;Weights from best epoch have been loaded into model.&#34;, verbose=verbose
            )
            # loss, acc = self.model.evaluate_generator(self.val_data)
            # U.vprint(&#39;\n&#39;, verbose=verbose)
            # U.vprint(&#39;Early stopping due to no further improvement.&#39;, verbose=verbose)
            # U.vprint(&#39;final loss:%s, final score:%s&#39; % (loss, acc), verbose=verbose)
        return hist

    def layer_output(self, layer_id, example_id=0, batch_id=0, use_val=False):
        &#34;&#34;&#34;
        ```
        Prints output of layer with index &lt;layer_id&gt; to help debug models.
        Uses first example (example_id=0) from first batch from training set, by default.
        ```
        &#34;&#34;&#34;

        inp = self.model.layers[0].input
        outp = self.model.layers[layer_id].output
        f_out = K.function([inp], [outp])
        if not use_val:
            example = self.train_data[0][batch_id][example_id]
        else:
            example = self.val_data[0][batch_id][example_id]
        layer_out = f_out(
            [
                np.array(
                    [
                        example,
                    ]
                )
            ]
        )[0]
        return layer_out

    # def view_top_losses(self, n=4, preproc=None, val_data=None):
    #    &#34;&#34;&#34;
    #    Views observations with top losses in validation set.
    #    Musta be overridden by Learner subclasses.
    #    &#34;&#34;&#34;
    #    raise NotImplementedError(&#39;view_top_losses must be overriden by GenLearner subclass&#39;)
    def view_top_losses(self, n=4, preproc=None, val_data=None):
        &#34;&#34;&#34;
        ```
        Views observations with top losses in validation set.
        Typically over-ridden by Learner subclasses.
        Args:
         n(int or tuple): a range to select in form of int or tuple
                          e.g., n=8 is treated as n=(0,8)
         preproc (Preprocessor): A TextPreprocessor or ImagePreprocessor.
                                 For some data like text data, a preprocessor
                                 is required to undo the pre-processing
                                 to correctly view raw data.
          val_data:  optional val_data to use instead of self.val_data
        Returns:
            list of n tuples where first element is either
            filepath or id of validation example and second element
            is loss.
        ```
        &#34;&#34;&#34;
        val = self._check_val(val_data)

        # get top losses and associated data
        tups = self.top_losses(n=n, val_data=val, preproc=preproc)

        # get multilabel status and class names
        classes = preproc.get_classes() if preproc is not None else None
        # iterate through losses
        for tup in tups:
            # get data
            idx = tup[0]
            loss = tup[1]
            truth = tup[2]
            pred = tup[3]

            print(&#34;----------&#34;)
            print(
                &#34;id:%s | loss:%s | true:%s | pred:%s)\n&#34;
                % (idx, round(loss, 2), truth, pred)
            )
        return


# ------------------------------------------------------------------------------
# Predictor functions
# ------------------------------------------------------------------------------


def get_predictor(model, preproc, batch_size=U.DEFAULT_BS):
    &#34;&#34;&#34;
    ```
    Returns a Predictor instance that can be used to make predictions on
    unlabeled examples.  Can be saved to disk and reloaded as part of a
    larger application.

    Args
        model (Model):        A compiled instance of keras.engine.training.Model
        preproc(Preprocessor):   An instance of TextPreprocessor,ImagePreprocessor,
                                 or NERPreprocessor.
                                 These instances are returned from the data loading
                                 functions in the ktrain vision and text modules:

                                 ktrain.vision.images_from_folder
                                 ktrain.vision.images_from_csv
                                 ktrain.vision.images_from_array
                                 ktrain.text.texts_from_folder
                                 ktrain.text.texts_from_csv
                                 ktrain.text.ner.entities_from_csv
        batch_size(int):    batch size to use.  default:32
    ```
    &#34;&#34;&#34;

    # check arguments
    if not isinstance(model, keras.Model):
        raise ValueError(&#34;model must be of instance keras.Model&#34;)
    if not isinstance(
        preproc,
        (
            ImagePreprocessor,
            TextPreprocessor,
            NERPreprocessor,
            NodePreprocessor,
            LinkPreprocessor,
            TabularPreprocessor,
        ),
    ):
        raise ValueError(&#34;preproc must be instance of ktrain.preprocessor.Preprocessor&#34;)
    if isinstance(preproc, ImagePreprocessor):
        return ImagePredictor(model, preproc, batch_size=batch_size)
    elif isinstance(preproc, TextPreprocessor):
        # elif type(preproc).__name__ == &#39;TextPreprocessor&#39;:
        return TextPredictor(model, preproc, batch_size=batch_size)
    elif isinstance(preproc, NERPreprocessor):
        return NERPredictor(model, preproc, batch_size=batch_size)
    elif isinstance(preproc, NodePreprocessor):
        return NodePredictor(model, preproc, batch_size=batch_size)
    elif isinstance(preproc, LinkPreprocessor):
        return LinkPredictor(model, preproc, batch_size=batch_size)
    elif isinstance(preproc, TabularPreprocessor):
        return TabularPredictor(model, preproc, batch_size=batch_size)

    else:
        raise Exception(&#34;preproc of type %s not currently supported&#34; % (type(preproc)))


def load_predictor(fpath, batch_size=U.DEFAULT_BS, custom_objects=None):
    &#34;&#34;&#34;
    ```
    Loads a previously saved Predictor instance
    Args
      fpath(str): predictor path name (value supplied to predictor.save)
                  From v0.16.x, this is always the path to a folder.
                  Pre-v0.16.x, this is the base name used to save model and .preproc instance.
      batch_size(int): batch size to use for predictions. default:32
      custom_objects(dict): custom objects required to load model.
                            This is useful if you compiled the model with a custom loss function, for example.
                            For models included with ktrain as is, this is populated automatically
                            and can be disregarded.
    ```
    &#34;&#34;&#34;

    # load the preprocessor
    preproc = None
    try:
        preproc_name = os.path.join(fpath, U.PREPROC_NAME)
        with open(preproc_name, &#34;rb&#34;) as f:
            preproc = pickle.load(f)
    except:
        try:
            preproc_name = fpath + &#34;.preproc&#34;
            # warnings.warn(&#39;could not load .preproc file as %s - attempting to load as %s&#39; % (os.path.join(fpath, U.PREPROC_NAME), preproc_name))
            with open(preproc_name, &#34;rb&#34;) as f:
                preproc = pickle.load(f)
        except:
            raise Exception(
                &#34;Failed to load .preproc file in either the post v0.16.x loction (%s) or pre v0.16.x location (%s)&#34;
                % (os.path.join(fpath, U.PREPROC_NAME), fpath + &#34;.preproc&#34;)
            )

    # load the model
    model = _load_model(fpath, preproc=preproc, custom_objects=custom_objects)

    # preprocessing functions in ImageDataGenerators are not pickable
    # so, we must reconstruct
    if hasattr(preproc, &#34;datagen&#34;) and hasattr(preproc.datagen, &#34;ktrain_preproc&#34;):
        preproc_name = preproc.datagen.ktrain_preproc
        if preproc_name == &#34;resnet50&#34;:
            preproc.datagen.preprocessing_function = (
                keras.applications.resnet50.preprocess_input
            )
        elif preproc_name == &#34;mobilenet&#34;:
            preproc.datagen.preprocessing_function = (
                keras.applications.mobilenet.preprocess_input
            )
        elif preproc_name == &#34;mobilenetv3&#34;:
            preproc.datagen.preprocessing_function = (
                keras.applications.mobilenet_v3.preprocess_input
            )
        elif preproc_name == &#34;inception&#34;:
            preproc.datagen.preprocessing_function = (
                keras.applications.inception_v3.preprocess_input
            )
        elif preproc_name == &#34;efficientnet&#34;:
            preproc.datagen.preprocessing_function = (
                keras.applications.efficientnet.preprocess_input
            )
        else:
            raise Exception(&#34;Uknown preprocessing_function name: %s&#34; % (preproc_name))

    # return the appropriate predictor
    if not isinstance(model, keras.Model):
        raise ValueError(&#34;model must be of instance keras.Model&#34;)
    if not isinstance(
        preproc,
        (
            ImagePreprocessor,
            TextPreprocessor,
            NERPreprocessor,
            NodePreprocessor,
            LinkPreprocessor,
            TabularPreprocessor,
        ),
    ):
        raise ValueError(&#34;preproc must be instance of ktrain.preprocessor.Preprocessor&#34;)
    if isinstance(preproc, ImagePreprocessor):
        return ImagePredictor(model, preproc, batch_size=batch_size)
    elif isinstance(preproc, TextPreprocessor):
        return TextPredictor(model, preproc, batch_size=batch_size)
    elif isinstance(preproc, NERPreprocessor):
        return NERPredictor(model, preproc, batch_size=batch_size)
    elif isinstance(preproc, NodePreprocessor):
        return NodePredictor(model, preproc, batch_size=batch_size)
    elif isinstance(preproc, LinkPreprocessor):
        return LinkPredictor(model, preproc, batch_size=batch_size)
    elif isinstance(preproc, TabularPreprocessor):
        return TabularPredictor(model, preproc, batch_size=batch_size)
    else:
        raise Exception(&#34;preprocessor not currently supported&#34;)


# ----------------------------------------
# Utility Functions
# ----------------------------------------


def release_gpu_memory(device=0):
    &#34;&#34;&#34;
    ```
    Relase GPU memory allocated by Tensorflow
    Source:
    https://stackoverflow.com/questions/51005147/keras-release-memory-after-finish-training-process
    ```
    &#34;&#34;&#34;
    from numba import cuda

    K.clear_session()
    cuda.select_device(device)
    cuda.close()
    return


def _load_model(fpath, preproc=None, train_data=None, custom_objects=None):
    if not preproc and not train_data:
        raise ValueError(&#34;Either preproc or train_data is required.&#34;)
    if (preproc and isinstance(preproc, TransformersPreprocessor)) or (
        train_data and U.is_huggingface(data=train_data)
    ):
        if preproc:
            model = preproc.get_model(fpath=fpath)
            # if model_name is local_path, update it to reflect current predictor folder
            # in case learner was trained with local path on different machine
            # TODO: support this for Windows paths
            if preproc.model_name.startswith(os.sep):
                preproc.model_name = fpath
        else:
            model = TransformersPreprocessor.load_model_and_configure_from_data(
                fpath, train_data
            )
        return model
    elif (
        (
            preproc
            and (
                isinstance(preproc, BERTPreprocessor)
                or type(preproc).__name__ == &#34;BERTPreprocessor&#34;
            )
        )
        or train_data
        and U.bert_data_tuple(train_data)
    ):
        # custom BERT model
        check_keras_bert()
        if isinstance(custom_objects, dict):
            custom_objects.update(keras_bert.get_custom_objects())
        else:
            custom_objects = keras_bert.get_custom_objects()
    elif (
        (
            preproc
            and (
                isinstance(preproc, NERPreprocessor)
                or type(preproc).__name__ == &#34;NERPreprocessor&#34;
            )
        )
        or train_data
        and U.is_ner(data=train_data)
    ):
        from .text.ner.anago.layers import CRF, crf_loss

        custom_objects = {&#34;CRF&#34;: CRF, &#34;crf_loss&#34;: crf_loss}
        # save old te_model as backup
        if preproc:
            old_te_model = preproc.p.te_model
            # load TransformerEmbedding model from fpath/hf folder
            # if model_name is local_path, update it to reflect current predictor folder, since
            # all model/tokenizer/config files should have been saved there by predictor.save

            preproc.p.te_model = (
                os.path.join(fpath, &#34;hf&#34;) if preproc.p.te_model else preproc.p.te_model
            )
            if preproc.p.te_model:
                # te_model should point fpath/hf folder
                try:
                    preproc.p.activate_transformer(
                        preproc.p.te_model, layers=preproc.p.te_layers
                    )
                except:
                    # fall back to old model id or location if error for backwards compatibility
                    warnings.warn(
                        f&#34;could not load TransformerEmbedding model from {preproc.p.te_model} - trying {old_te_model}&#34;
                    )
                    preproc.p.te_model = old_te_model
                    preproc.p.activate_transformer(
                        preproc.p.te_model, layers=preproc.p.te_layers
                    )

    elif (
        (
            preproc
            and (
                isinstance(preproc, NodePreprocessor)
                or type(preproc).__name__ == &#34;NodePreprocessor&#34;
            )
        )
        or train_data
        and U.is_nodeclass(data=train_data)
    ):
        from stellargraph.layer import MeanAggregator

        custom_objects = {&#34;MeanAggregator&#34;: MeanAggregator}
    elif (
        (
            preproc
            and (
                isinstance(preproc, LinkPreprocessor)
                or type(preproc).__name__ == &#34;LinkPreprocessor&#34;
            )
        )
        or train_data
        and U.is_linkpred(data=train_data)
    ):
        from stellargraph.layer import MeanAggregator

        custom_objects = {&#34;MeanAggregator&#34;: MeanAggregator}
    custom_objects = {} if custom_objects is None else custom_objects
    from .lroptimize.optimization import AdamWeightDecay

    custom_objects[&#34;AdamWeightDecay&#34;] = AdamWeightDecay
    try:
        try:
            model = keras.models.load_model(
                os.path.join(fpath, U.MODEL_NAME), custom_objects=custom_objects
            )
        except:
            try:
                # pre-0.16: model fpath was file name of model not folder for non-Transformer models
                # warnings.warn(&#39;could not load model as %s - attempting to load model as %s&#39; % (os.path.join(fpath, U.MODEL_NAME), fpath))
                model = keras.models.load_model(fpath, custom_objects=custom_objects)
            except:
                # for bilstm models without CRF layer on TF2 where CRF is not supported
                model = keras.models.load_model(
                    fpath, custom_objects={&#34;AdamWeightDecay&#34;: AdamWeightDecay}
                )
    except Exception as e:
        print(
            &#34;Call to keras.models.load_model failed. Try manually invoking this function to investigate error and report issue if necessary.&#34;
        )
        raise Exception(&#34;Error detected: %s&#34; % (e))

    # see issue https://github.com/amaiya/ktrain/issues/21
    if hasattr(model, &#34;_make_predict_function&#34;):
        model._make_predict_function()

    return model</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ktrain.core.get_predictor"><code class="name flex">
<span>def <span class="ident">get_predictor</span></span>(<span>model, preproc, batch_size=32)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>Returns a Predictor instance that can be used to make predictions on
unlabeled examples.  Can be saved to disk and reloaded as part of a
larger application.

Args
    model (Model):        A compiled instance of keras.engine.training.Model
    preproc(Preprocessor):   An instance of TextPreprocessor,ImagePreprocessor,
                             or NERPreprocessor.
                             These instances are returned from the data loading
                             functions in the ktrain vision and text modules:

                             ktrain.vision.images_from_folder
                             ktrain.vision.images_from_csv
                             ktrain.vision.images_from_array
                             ktrain.text.texts_from_folder
                             ktrain.text.texts_from_csv
                             ktrain.text.ner.entities_from_csv
    batch_size(int):    batch size to use.  default:32
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_predictor(model, preproc, batch_size=U.DEFAULT_BS):
    &#34;&#34;&#34;
    ```
    Returns a Predictor instance that can be used to make predictions on
    unlabeled examples.  Can be saved to disk and reloaded as part of a
    larger application.

    Args
        model (Model):        A compiled instance of keras.engine.training.Model
        preproc(Preprocessor):   An instance of TextPreprocessor,ImagePreprocessor,
                                 or NERPreprocessor.
                                 These instances are returned from the data loading
                                 functions in the ktrain vision and text modules:

                                 ktrain.vision.images_from_folder
                                 ktrain.vision.images_from_csv
                                 ktrain.vision.images_from_array
                                 ktrain.text.texts_from_folder
                                 ktrain.text.texts_from_csv
                                 ktrain.text.ner.entities_from_csv
        batch_size(int):    batch size to use.  default:32
    ```
    &#34;&#34;&#34;

    # check arguments
    if not isinstance(model, keras.Model):
        raise ValueError(&#34;model must be of instance keras.Model&#34;)
    if not isinstance(
        preproc,
        (
            ImagePreprocessor,
            TextPreprocessor,
            NERPreprocessor,
            NodePreprocessor,
            LinkPreprocessor,
            TabularPreprocessor,
        ),
    ):
        raise ValueError(&#34;preproc must be instance of ktrain.preprocessor.Preprocessor&#34;)
    if isinstance(preproc, ImagePreprocessor):
        return ImagePredictor(model, preproc, batch_size=batch_size)
    elif isinstance(preproc, TextPreprocessor):
        # elif type(preproc).__name__ == &#39;TextPreprocessor&#39;:
        return TextPredictor(model, preproc, batch_size=batch_size)
    elif isinstance(preproc, NERPreprocessor):
        return NERPredictor(model, preproc, batch_size=batch_size)
    elif isinstance(preproc, NodePreprocessor):
        return NodePredictor(model, preproc, batch_size=batch_size)
    elif isinstance(preproc, LinkPreprocessor):
        return LinkPredictor(model, preproc, batch_size=batch_size)
    elif isinstance(preproc, TabularPreprocessor):
        return TabularPredictor(model, preproc, batch_size=batch_size)

    else:
        raise Exception(&#34;preproc of type %s not currently supported&#34; % (type(preproc)))</code></pre>
</details>
</dd>
<dt id="ktrain.core.load_predictor"><code class="name flex">
<span>def <span class="ident">load_predictor</span></span>(<span>fpath, batch_size=32, custom_objects=None)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>Loads a previously saved Predictor instance
Args
  fpath(str): predictor path name (value supplied to predictor.save)
              From v0.16.x, this is always the path to a folder.
              Pre-v0.16.x, this is the base name used to save model and .preproc instance.
  batch_size(int): batch size to use for predictions. default:32
  custom_objects(dict): custom objects required to load model.
                        This is useful if you compiled the model with a custom loss function, for example.
                        For models included with ktrain as is, this is populated automatically
                        and can be disregarded.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_predictor(fpath, batch_size=U.DEFAULT_BS, custom_objects=None):
    &#34;&#34;&#34;
    ```
    Loads a previously saved Predictor instance
    Args
      fpath(str): predictor path name (value supplied to predictor.save)
                  From v0.16.x, this is always the path to a folder.
                  Pre-v0.16.x, this is the base name used to save model and .preproc instance.
      batch_size(int): batch size to use for predictions. default:32
      custom_objects(dict): custom objects required to load model.
                            This is useful if you compiled the model with a custom loss function, for example.
                            For models included with ktrain as is, this is populated automatically
                            and can be disregarded.
    ```
    &#34;&#34;&#34;

    # load the preprocessor
    preproc = None
    try:
        preproc_name = os.path.join(fpath, U.PREPROC_NAME)
        with open(preproc_name, &#34;rb&#34;) as f:
            preproc = pickle.load(f)
    except:
        try:
            preproc_name = fpath + &#34;.preproc&#34;
            # warnings.warn(&#39;could not load .preproc file as %s - attempting to load as %s&#39; % (os.path.join(fpath, U.PREPROC_NAME), preproc_name))
            with open(preproc_name, &#34;rb&#34;) as f:
                preproc = pickle.load(f)
        except:
            raise Exception(
                &#34;Failed to load .preproc file in either the post v0.16.x loction (%s) or pre v0.16.x location (%s)&#34;
                % (os.path.join(fpath, U.PREPROC_NAME), fpath + &#34;.preproc&#34;)
            )

    # load the model
    model = _load_model(fpath, preproc=preproc, custom_objects=custom_objects)

    # preprocessing functions in ImageDataGenerators are not pickable
    # so, we must reconstruct
    if hasattr(preproc, &#34;datagen&#34;) and hasattr(preproc.datagen, &#34;ktrain_preproc&#34;):
        preproc_name = preproc.datagen.ktrain_preproc
        if preproc_name == &#34;resnet50&#34;:
            preproc.datagen.preprocessing_function = (
                keras.applications.resnet50.preprocess_input
            )
        elif preproc_name == &#34;mobilenet&#34;:
            preproc.datagen.preprocessing_function = (
                keras.applications.mobilenet.preprocess_input
            )
        elif preproc_name == &#34;mobilenetv3&#34;:
            preproc.datagen.preprocessing_function = (
                keras.applications.mobilenet_v3.preprocess_input
            )
        elif preproc_name == &#34;inception&#34;:
            preproc.datagen.preprocessing_function = (
                keras.applications.inception_v3.preprocess_input
            )
        elif preproc_name == &#34;efficientnet&#34;:
            preproc.datagen.preprocessing_function = (
                keras.applications.efficientnet.preprocess_input
            )
        else:
            raise Exception(&#34;Uknown preprocessing_function name: %s&#34; % (preproc_name))

    # return the appropriate predictor
    if not isinstance(model, keras.Model):
        raise ValueError(&#34;model must be of instance keras.Model&#34;)
    if not isinstance(
        preproc,
        (
            ImagePreprocessor,
            TextPreprocessor,
            NERPreprocessor,
            NodePreprocessor,
            LinkPreprocessor,
            TabularPreprocessor,
        ),
    ):
        raise ValueError(&#34;preproc must be instance of ktrain.preprocessor.Preprocessor&#34;)
    if isinstance(preproc, ImagePreprocessor):
        return ImagePredictor(model, preproc, batch_size=batch_size)
    elif isinstance(preproc, TextPreprocessor):
        return TextPredictor(model, preproc, batch_size=batch_size)
    elif isinstance(preproc, NERPreprocessor):
        return NERPredictor(model, preproc, batch_size=batch_size)
    elif isinstance(preproc, NodePreprocessor):
        return NodePredictor(model, preproc, batch_size=batch_size)
    elif isinstance(preproc, LinkPreprocessor):
        return LinkPredictor(model, preproc, batch_size=batch_size)
    elif isinstance(preproc, TabularPreprocessor):
        return TabularPredictor(model, preproc, batch_size=batch_size)
    else:
        raise Exception(&#34;preprocessor not currently supported&#34;)</code></pre>
</details>
</dd>
<dt id="ktrain.core.release_gpu_memory"><code class="name flex">
<span>def <span class="ident">release_gpu_memory</span></span>(<span>device=0)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>Relase GPU memory allocated by Tensorflow
Source:
https://stackoverflow.com/questions/51005147/keras-release-memory-after-finish-training-process
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def release_gpu_memory(device=0):
    &#34;&#34;&#34;
    ```
    Relase GPU memory allocated by Tensorflow
    Source:
    https://stackoverflow.com/questions/51005147/keras-release-memory-after-finish-training-process
    ```
    &#34;&#34;&#34;
    from numba import cuda

    K.clear_session()
    cuda.select_device(device)
    cuda.close()
    return</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ktrain.core.ArrayLearner"><code class="flex name class">
<span>class <span class="ident">ArrayLearner</span></span>
<span>(</span><span>model, train_data=None, val_data=None, batch_size=32, eval_batch_size=32, workers=1, use_multiprocessing=False)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>Main class used to tune and train Keras models
using Array data.  An objects of this class should be instantiated
via the ktrain.get_learner method instead of directly.
Main parameters are:


model (Model):        A compiled instance of keras.engine.training.Model
train_data (ndarray): A tuple of (x_train, y_train), where x_train and
                      y_train are numpy.ndarrays.
val_data (ndarray):   A tuple of (x_test, y_test), where x_test and
                      y_test are numpy.ndarrays.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ArrayLearner(Learner):
    &#34;&#34;&#34;
    ```
    Main class used to tune and train Keras models
    using Array data.  An objects of this class should be instantiated
    via the ktrain.get_learner method instead of directly.
    Main parameters are:


    model (Model):        A compiled instance of keras.engine.training.Model
    train_data (ndarray): A tuple of (x_train, y_train), where x_train and
                          y_train are numpy.ndarrays.
    val_data (ndarray):   A tuple of (x_test, y_test), where x_test and
                          y_test are numpy.ndarrays.
    ```
    &#34;&#34;&#34;

    def __init__(
        self,
        model,
        train_data=None,
        val_data=None,
        batch_size=U.DEFAULT_BS,
        eval_batch_size=U.DEFAULT_BS,
        workers=1,
        use_multiprocessing=False,
    ):
        super().__init__(
            model, workers=workers, use_multiprocessing=use_multiprocessing
        )
        self.train_data = train_data
        self.val_data = val_data
        self.batch_size = batch_size
        self.eval_batch_size = eval_batch_size
        return

    def fit(
        self,
        lr,
        n_cycles,
        cycle_len=None,
        cycle_mult=1,
        lr_decay=1,
        checkpoint_folder=None,
        early_stopping=None,
        verbose=1,
        class_weight=None,
        callbacks=[],
        steps_per_epoch=None,
    ):
        &#34;&#34;&#34;
        ```
        Trains the model. By default, fit is simply a wrapper for model.fit.
        When cycle_len parameter is supplied, an SGDR learning rate schedule is used.
        Trains the model.

        lr (float): learning rate
        n_cycles (int):  n_cycles
        cycle_len (int): If not None, decay learning rate over &lt;cycle_len&gt;
                         epochs until restarting/resetting learning rate to &lt;lr&gt;.
                         If None, lr remains constant
        cycle_mult (int): Increase cycle_len by factor of cycle_mult.
                          This will gradually elongate the cycle.
                          Has no effect if cycle_len is None.
        lr_decay(float): rate of decay of learning rate each cycle
        checkpoint_folder (string): Folder path in which to save the model weights
                                   for each epoch.
                                   File name will be of the form:
                                   weights-{epoch:02d}-{val_loss:.2f}.hdf5
        early_stopping (int):     If not None, training will automatically stop after this many
                                  epochs of no improvement in validation loss.
                                  Upon completion, model will be loaded with weights from epoch
                                  with lowest validation loss.
        callbacks (list):         list of Callback instances to employ during training
        class_weight (dict):       Optional dictionary mapping class indices (integers) to a weight (float)
        steps_per_epoch(int):    Steps per epoch. If None, then, math.ceil(num_samples/batch_size) is used.
                                 Ignored unless training dataset is generator (and in ArrayLearner instances).
        verbose (bool):           whether or not to show progress bar
        ```
        &#34;&#34;&#34;

        # check early_stopping
        if self.val_data is None and early_stopping is not None:
            raise ValueError(
                &#34;early_stopping monitors val_loss but validation data not set&#34;
            )

        # setup data
        x_train = self.train_data[0]
        y_train = self.train_data[1]
        validation = None
        if self.val_data:
            validation = (self.val_data[0], self.val_data[1])
        # setup learning rate schedule
        epochs = self._check_cycles(n_cycles, cycle_len, cycle_mult)
        self.set_lr(lr)

        # set call backs
        kcallbacks = callbacks if callbacks else None
        kcallbacks = self._cb_sgdr(
            lr,
            np.ceil(len(x_train) / self.batch_size),
            cycle_len,
            cycle_mult,
            lr_decay,
            callbacks=kcallbacks,
        )
        kcallbacks = self._cb_checkpoint(checkpoint_folder, callbacks=kcallbacks)
        kcallbacks = self._cb_earlystopping(early_stopping, callbacks=kcallbacks)
        sgdr = (
            [cb for cb in kcallbacks if type(cb).__name__ == &#34;SGDRScheduler&#34;]
            if kcallbacks
            else None
        )
        sgdr = sgdr[0] if sgdr else None

        # train model
        with warnings.catch_warnings():
            warnings.filterwarnings(&#34;ignore&#34;, message=&#34;.*Check your callbacks.*&#34;)
            hist = self.model.fit(
                self._prepare(x_train),
                self._prepare(y_train, train=False),
                batch_size=self.batch_size,
                epochs=epochs,
                validation_data=validation,
                verbose=verbose,
                shuffle=True,
                class_weight=class_weight,
                callbacks=kcallbacks,
            )

        if sgdr is not None:
            hist.history[&#34;lr&#34;] = sgdr.history[&#34;lr&#34;]
        self.history = hist

        if early_stopping:
            U.vprint(
                &#34;Weights from best epoch have been loaded into model.&#34;, verbose=verbose
            )
            # loss, acc = self.model.evaluate(self.val_data[0], self.val_data[1])
            # U.vprint(&#39;\n&#39;, verbose=verbose)
            # U.vprint(&#39;Early stopping due to no further improvement.&#39;, verbose=verbose)
            # U.vprint(&#39;final loss:%s, final score:%s&#39; % (loss, acc), verbose=verbose)

        return hist

    def layer_output(self, layer_id, example_id=0, use_val=False):
        &#34;&#34;&#34;
        ```
        Prints output of layer with index &lt;layer_id&gt; to help debug models.
        Uses first example (example_id=0) from training set, by default.
        ```
        &#34;&#34;&#34;

        inp = self.model.layers[0].input
        outp = self.model.layers[layer_id].output
        f_out = K.function([inp], [outp])
        if not use_val:
            example = self.train_data[0][example_id]
        else:
            example = self.val_data[0][example_id]
        layer_out = f_out(
            [
                np.array(
                    [
                        example,
                    ]
                )
            ]
        )[0]
        return layer_out

    def view_top_losses(self, n=4, preproc=None, val_data=None):
        &#34;&#34;&#34;
        ```
        Views observations with top losses in validation set.
        Typically over-ridden by Learner subclasses.
        Args:
         n(int or tuple): a range to select in form of int or tuple
                          e.g., n=8 is treated as n=(0,8)
         preproc (Preprocessor): A TextPreprocessor or ImagePreprocessor.
                                 For some data like text data, a preprocessor
                                 is required to undo the pre-processing
                                 to correctly view raw data.
          val_data:  optional val_data to use instead of self.val_data
        Returns:
            list of n tuples where first element is either
            filepath or id of validation example and second element
            is loss.
        ```
        &#34;&#34;&#34;
        val = self._check_val(val_data)

        # get top losses and associated data
        tups = self.top_losses(n=n, val_data=val, preproc=preproc)

        # get multilabel status and class names
        classes = preproc.get_classes() if preproc is not None else None
        # iterate through losses
        for tup in tups:
            # get data
            idx = tup[0]
            loss = tup[1]
            truth = tup[2]
            pred = tup[3]

            obs = val[0][idx]
            join_char = &#34; &#34;
            if preproc is not None:
                obs = preproc.undo(obs)
            if preproc is not None and isinstance(preproc, TextPreprocessor):
                if preproc.is_nospace_lang():
                    join_char = &#34;&#34;
            if type(obs) == str:
                obs = join_char.join(obs.split()[:512])
            print(&#34;----------&#34;)
            print(
                &#34;id:%s | loss:%s | true:%s | pred:%s)\n&#34;
                % (idx, round(loss, 2), truth, pred)
            )
            print(obs)
        return</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ktrain.core.Learner" href="#ktrain.core.Learner">Learner</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ktrain.text.learner.BERTTextClassLearner" href="text/learner.html#ktrain.text.learner.BERTTextClassLearner">BERTTextClassLearner</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ktrain.core.ArrayLearner.fit"><code class="name flex">
<span>def <span class="ident">fit</span></span>(<span>self, lr, n_cycles, cycle_len=None, cycle_mult=1, lr_decay=1, checkpoint_folder=None, early_stopping=None, verbose=1, class_weight=None, callbacks=[], steps_per_epoch=None)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>Trains the model. By default, fit is simply a wrapper for model.fit.
When cycle_len parameter is supplied, an SGDR learning rate schedule is used.
Trains the model.

lr (float): learning rate
n_cycles (int):  n_cycles
cycle_len (int): If not None, decay learning rate over &lt;cycle_len&gt;
                 epochs until restarting/resetting learning rate to &lt;lr&gt;.
                 If None, lr remains constant
cycle_mult (int): Increase cycle_len by factor of cycle_mult.
                  This will gradually elongate the cycle.
                  Has no effect if cycle_len is None.
lr_decay(float): rate of decay of learning rate each cycle
checkpoint_folder (string): Folder path in which to save the model weights
                           for each epoch.
                           File name will be of the form:
                           weights-{epoch:02d}-{val_loss:.2f}.hdf5
early_stopping (int):     If not None, training will automatically stop after this many
                          epochs of no improvement in validation loss.
                          Upon completion, model will be loaded with weights from epoch
                          with lowest validation loss.
callbacks (list):         list of Callback instances to employ during training
class_weight (dict):       Optional dictionary mapping class indices (integers) to a weight (float)
steps_per_epoch(int):    Steps per epoch. If None, then, math.ceil(num_samples/batch_size) is used.
                         Ignored unless training dataset is generator (and in ArrayLearner instances).
verbose (bool):           whether or not to show progress bar
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit(
    self,
    lr,
    n_cycles,
    cycle_len=None,
    cycle_mult=1,
    lr_decay=1,
    checkpoint_folder=None,
    early_stopping=None,
    verbose=1,
    class_weight=None,
    callbacks=[],
    steps_per_epoch=None,
):
    &#34;&#34;&#34;
    ```
    Trains the model. By default, fit is simply a wrapper for model.fit.
    When cycle_len parameter is supplied, an SGDR learning rate schedule is used.
    Trains the model.

    lr (float): learning rate
    n_cycles (int):  n_cycles
    cycle_len (int): If not None, decay learning rate over &lt;cycle_len&gt;
                     epochs until restarting/resetting learning rate to &lt;lr&gt;.
                     If None, lr remains constant
    cycle_mult (int): Increase cycle_len by factor of cycle_mult.
                      This will gradually elongate the cycle.
                      Has no effect if cycle_len is None.
    lr_decay(float): rate of decay of learning rate each cycle
    checkpoint_folder (string): Folder path in which to save the model weights
                               for each epoch.
                               File name will be of the form:
                               weights-{epoch:02d}-{val_loss:.2f}.hdf5
    early_stopping (int):     If not None, training will automatically stop after this many
                              epochs of no improvement in validation loss.
                              Upon completion, model will be loaded with weights from epoch
                              with lowest validation loss.
    callbacks (list):         list of Callback instances to employ during training
    class_weight (dict):       Optional dictionary mapping class indices (integers) to a weight (float)
    steps_per_epoch(int):    Steps per epoch. If None, then, math.ceil(num_samples/batch_size) is used.
                             Ignored unless training dataset is generator (and in ArrayLearner instances).
    verbose (bool):           whether or not to show progress bar
    ```
    &#34;&#34;&#34;

    # check early_stopping
    if self.val_data is None and early_stopping is not None:
        raise ValueError(
            &#34;early_stopping monitors val_loss but validation data not set&#34;
        )

    # setup data
    x_train = self.train_data[0]
    y_train = self.train_data[1]
    validation = None
    if self.val_data:
        validation = (self.val_data[0], self.val_data[1])
    # setup learning rate schedule
    epochs = self._check_cycles(n_cycles, cycle_len, cycle_mult)
    self.set_lr(lr)

    # set call backs
    kcallbacks = callbacks if callbacks else None
    kcallbacks = self._cb_sgdr(
        lr,
        np.ceil(len(x_train) / self.batch_size),
        cycle_len,
        cycle_mult,
        lr_decay,
        callbacks=kcallbacks,
    )
    kcallbacks = self._cb_checkpoint(checkpoint_folder, callbacks=kcallbacks)
    kcallbacks = self._cb_earlystopping(early_stopping, callbacks=kcallbacks)
    sgdr = (
        [cb for cb in kcallbacks if type(cb).__name__ == &#34;SGDRScheduler&#34;]
        if kcallbacks
        else None
    )
    sgdr = sgdr[0] if sgdr else None

    # train model
    with warnings.catch_warnings():
        warnings.filterwarnings(&#34;ignore&#34;, message=&#34;.*Check your callbacks.*&#34;)
        hist = self.model.fit(
            self._prepare(x_train),
            self._prepare(y_train, train=False),
            batch_size=self.batch_size,
            epochs=epochs,
            validation_data=validation,
            verbose=verbose,
            shuffle=True,
            class_weight=class_weight,
            callbacks=kcallbacks,
        )

    if sgdr is not None:
        hist.history[&#34;lr&#34;] = sgdr.history[&#34;lr&#34;]
    self.history = hist

    if early_stopping:
        U.vprint(
            &#34;Weights from best epoch have been loaded into model.&#34;, verbose=verbose
        )
        # loss, acc = self.model.evaluate(self.val_data[0], self.val_data[1])
        # U.vprint(&#39;\n&#39;, verbose=verbose)
        # U.vprint(&#39;Early stopping due to no further improvement.&#39;, verbose=verbose)
        # U.vprint(&#39;final loss:%s, final score:%s&#39; % (loss, acc), verbose=verbose)

    return hist</code></pre>
</details>
</dd>
<dt id="ktrain.core.ArrayLearner.layer_output"><code class="name flex">
<span>def <span class="ident">layer_output</span></span>(<span>self, layer_id, example_id=0, use_val=False)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>Prints output of layer with index &lt;layer_id&gt; to help debug models.
Uses first example (example_id=0) from training set, by default.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def layer_output(self, layer_id, example_id=0, use_val=False):
    &#34;&#34;&#34;
    ```
    Prints output of layer with index &lt;layer_id&gt; to help debug models.
    Uses first example (example_id=0) from training set, by default.
    ```
    &#34;&#34;&#34;

    inp = self.model.layers[0].input
    outp = self.model.layers[layer_id].output
    f_out = K.function([inp], [outp])
    if not use_val:
        example = self.train_data[0][example_id]
    else:
        example = self.val_data[0][example_id]
    layer_out = f_out(
        [
            np.array(
                [
                    example,
                ]
            )
        ]
    )[0]
    return layer_out</code></pre>
</details>
</dd>
<dt id="ktrain.core.ArrayLearner.view_top_losses"><code class="name flex">
<span>def <span class="ident">view_top_losses</span></span>(<span>self, n=4, preproc=None, val_data=None)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>Views observations with top losses in validation set.
Typically over-ridden by Learner subclasses.
Args:
 n(int or tuple): a range to select in form of int or tuple
                  e.g., n=8 is treated as n=(0,8)
 preproc (Preprocessor): A TextPreprocessor or ImagePreprocessor.
                         For some data like text data, a preprocessor
                         is required to undo the pre-processing
                         to correctly view raw data.
  val_data:  optional val_data to use instead of self.val_data
Returns:
    list of n tuples where first element is either
    filepath or id of validation example and second element
    is loss.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def view_top_losses(self, n=4, preproc=None, val_data=None):
    &#34;&#34;&#34;
    ```
    Views observations with top losses in validation set.
    Typically over-ridden by Learner subclasses.
    Args:
     n(int or tuple): a range to select in form of int or tuple
                      e.g., n=8 is treated as n=(0,8)
     preproc (Preprocessor): A TextPreprocessor or ImagePreprocessor.
                             For some data like text data, a preprocessor
                             is required to undo the pre-processing
                             to correctly view raw data.
      val_data:  optional val_data to use instead of self.val_data
    Returns:
        list of n tuples where first element is either
        filepath or id of validation example and second element
        is loss.
    ```
    &#34;&#34;&#34;
    val = self._check_val(val_data)

    # get top losses and associated data
    tups = self.top_losses(n=n, val_data=val, preproc=preproc)

    # get multilabel status and class names
    classes = preproc.get_classes() if preproc is not None else None
    # iterate through losses
    for tup in tups:
        # get data
        idx = tup[0]
        loss = tup[1]
        truth = tup[2]
        pred = tup[3]

        obs = val[0][idx]
        join_char = &#34; &#34;
        if preproc is not None:
            obs = preproc.undo(obs)
        if preproc is not None and isinstance(preproc, TextPreprocessor):
            if preproc.is_nospace_lang():
                join_char = &#34;&#34;
        if type(obs) == str:
            obs = join_char.join(obs.split()[:512])
        print(&#34;----------&#34;)
        print(
            &#34;id:%s | loss:%s | true:%s | pred:%s)\n&#34;
            % (idx, round(loss, 2), truth, pred)
        )
        print(obs)
    return</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ktrain.core.Learner" href="#ktrain.core.Learner">Learner</a></b></code>:
<ul class="hlist">
<li><code><a title="ktrain.core.Learner.autofit" href="#ktrain.core.Learner.autofit">autofit</a></code></li>
<li><code><a title="ktrain.core.Learner.evaluate" href="#ktrain.core.Learner.evaluate">evaluate</a></code></li>
<li><code><a title="ktrain.core.Learner.fit_onecycle" href="#ktrain.core.Learner.fit_onecycle">fit_onecycle</a></code></li>
<li><code><a title="ktrain.core.Learner.freeze" href="#ktrain.core.Learner.freeze">freeze</a></code></li>
<li><code><a title="ktrain.core.Learner.get_weight_decay" href="#ktrain.core.Learner.get_weight_decay">get_weight_decay</a></code></li>
<li><code><a title="ktrain.core.Learner.load_model" href="#ktrain.core.Learner.load_model">load_model</a></code></li>
<li><code><a title="ktrain.core.Learner.lr_estimate" href="#ktrain.core.Learner.lr_estimate">lr_estimate</a></code></li>
<li><code><a title="ktrain.core.Learner.lr_find" href="#ktrain.core.Learner.lr_find">lr_find</a></code></li>
<li><code><a title="ktrain.core.Learner.lr_plot" href="#ktrain.core.Learner.lr_plot">lr_plot</a></code></li>
<li><code><a title="ktrain.core.Learner.plot" href="#ktrain.core.Learner.plot">plot</a></code></li>
<li><code><a title="ktrain.core.Learner.predict" href="#ktrain.core.Learner.predict">predict</a></code></li>
<li><code><a title="ktrain.core.Learner.print_layers" href="#ktrain.core.Learner.print_layers">print_layers</a></code></li>
<li><code><a title="ktrain.core.Learner.reset_weights" href="#ktrain.core.Learner.reset_weights">reset_weights</a></code></li>
<li><code><a title="ktrain.core.Learner.save_model" href="#ktrain.core.Learner.save_model">save_model</a></code></li>
<li><code><a title="ktrain.core.Learner.set_model" href="#ktrain.core.Learner.set_model">set_model</a></code></li>
<li><code><a title="ktrain.core.Learner.set_weight_decay" href="#ktrain.core.Learner.set_weight_decay">set_weight_decay</a></code></li>
<li><code><a title="ktrain.core.Learner.top_losses" href="#ktrain.core.Learner.top_losses">top_losses</a></code></li>
<li><code><a title="ktrain.core.Learner.unfreeze" href="#ktrain.core.Learner.unfreeze">unfreeze</a></code></li>
<li><code><a title="ktrain.core.Learner.validate" href="#ktrain.core.Learner.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ktrain.core.GenLearner"><code class="flex name class">
<span>class <span class="ident">GenLearner</span></span>
<span>(</span><span>model, train_data=None, val_data=None, batch_size=32, eval_batch_size=32, workers=1, use_multiprocessing=False)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>Main class used to tune and train Keras models
using a Keras generator (e.g., DirectoryIterator).
Objects of this class should be instantiated using the
ktrain.get_learner function, rather than directly.

Main parameters are:

model (Model): A compiled instance of keras.engine.training.Model
train_data (Iterator): a Iterator instance for training set
val_data (Iterator):   A Iterator instance for validation set
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GenLearner(Learner):
    &#34;&#34;&#34;
    ```
    Main class used to tune and train Keras models
    using a Keras generator (e.g., DirectoryIterator).
    Objects of this class should be instantiated using the
    ktrain.get_learner function, rather than directly.

    Main parameters are:

    model (Model): A compiled instance of keras.engine.training.Model
    train_data (Iterator): a Iterator instance for training set
    val_data (Iterator):   A Iterator instance for validation set
    ```
    &#34;&#34;&#34;

    def __init__(
        self,
        model,
        train_data=None,
        val_data=None,
        batch_size=U.DEFAULT_BS,
        eval_batch_size=U.DEFAULT_BS,
        workers=1,
        use_multiprocessing=False,
    ):
        super().__init__(
            model, workers=workers, use_multiprocessing=use_multiprocessing
        )
        self.train_data = train_data
        self.val_data = val_data
        self.batch_size = batch_size
        self.eval_batch_size = eval_batch_size
        if self.train_data:
            self.train_data.batch_size = batch_size
        if self.val_data:
            self.val_data.batch_size = eval_batch_size
        return

    def fit(
        self,
        lr,
        n_cycles,
        cycle_len=None,
        cycle_mult=1,
        lr_decay=1.0,
        checkpoint_folder=None,
        early_stopping=None,
        class_weight=None,
        callbacks=[],
        steps_per_epoch=None,
        verbose=1,
    ):
        &#34;&#34;&#34;
        ```
        Trains the model. By default, fit is simply a wrapper for model.fit (for generators/sequences).
        When cycle_len parameter is supplied, an SGDR learning rate schedule is used.

        lr (float): learning rate
        n_cycles (int):  n_cycles
        cycle_len (int): If not None, decay learning rate over &lt;cycle_len&gt;
                         epochs until restarting/resetting learning rate to &lt;lr&gt;.
                         If None, lr remains constant
        cycle_mult (int): Increase cycle_len by factor of cycle_mult.
                          This will gradually elongate the cycle.
                          Has no effect if cycle_len is None.
        lr_decay (float): rate of decay of learning reach each cycle.
                          Has no effect if cycle_len is None
        checkpoint_folder (string): Folder path in which to save the model weights
                                   for each epoch.
                                   File name will be of the form:
                                   weights-{epoch:02d}-{val_loss:.2f}.hdf5
        early_stopping (int):     If not None, training will automatically stop after this many
                                  epochs of no improvement in validation loss.
                                  Upon completion, model will be loaded with weights from epoch
                                  with lowest validation loss.
        class_weight (dict):       Optional dictionary mapping class indices (integers) to a weight (float)
        callbacks (list):         list of Callback instances to employ during training
        steps_per_epoch(int):    Steps per epoch. If None, then, math.ceil(num_samples/batch_size) is used.
        verbose (boolean):       whether or not to print progress bar
        ```
        &#34;&#34;&#34;
        # check early_stopping
        if self.val_data is None and early_stopping is not None:
            raise ValueError(
                &#34;early_stopping monitors val_loss but validation data not set&#34;
            )

        # handle callbacks
        num_samples = U.nsamples_from_data(self.train_data)
        train_bs = (
            self.train_data.batch_size
            if hasattr(self.train_data, &#34;batch_size&#34;)
            else self.batch_size
        )
        if steps_per_epoch is None:
            steps_per_epoch = math.ceil(num_samples / train_bs)
        validation_steps = None
        if self.val_data is not None:
            val_bs = (
                self.val_data.batch_size
                if hasattr(self.val_data, &#34;batch_size&#34;)
                else self.batch_size
            )
            validation_steps = math.ceil(U.nsamples_from_data(self.val_data) / val_bs)

        epochs = self._check_cycles(n_cycles, cycle_len, cycle_mult)
        self.set_lr(lr)

        # set call backs
        kcallbacks = callbacks if callbacks else None
        kcallbacks = self._cb_sgdr(
            lr, steps_per_epoch, cycle_len, cycle_mult, lr_decay, callbacks=kcallbacks
        )
        kcallbacks = self._cb_checkpoint(checkpoint_folder, callbacks=kcallbacks)
        kcallbacks = self._cb_earlystopping(early_stopping, callbacks=kcallbacks)
        sgdr = (
            [cb for cb in kcallbacks if type(cb).__name__ == &#34;SGDRScheduler&#34;]
            if kcallbacks
            else None
        )
        sgdr = sgdr[0] if sgdr else None
        # if kcallbacks: print([type(cb).__name__ for cb in kcallbacks])

        # MNIST times per epoch on Titan V
        # workers=4, usemp=True 9 sec.
        # workers=1, usemp=True 12 sec.
        # workers=1, usemp=False 16 sec.
        # workers=4, usemp=False 30+ sec.
        # print(self.workers)
        # print(self.use_multiprocessing)

        # train model
        with warnings.catch_warnings():
            warnings.filterwarnings(&#34;ignore&#34;, message=&#34;.*Check your callbacks.*&#34;)
            fit_fn = self.model.fit
            hist = fit_fn(
                self._prepare(self.train_data),
                steps_per_epoch=steps_per_epoch,
                validation_steps=validation_steps,
                epochs=epochs,
                validation_data=self._prepare(self.val_data, train=False),
                workers=self.workers,
                use_multiprocessing=self.use_multiprocessing,
                verbose=verbose,
                shuffle=True,
                class_weight=class_weight,
                callbacks=kcallbacks,
            )
        if sgdr is not None:
            hist.history[&#34;lr&#34;] = sgdr.history[&#34;lr&#34;]
        self.history = hist

        if early_stopping:
            U.vprint(
                &#34;Weights from best epoch have been loaded into model.&#34;, verbose=verbose
            )
            # loss, acc = self.model.evaluate_generator(self.val_data)
            # U.vprint(&#39;\n&#39;, verbose=verbose)
            # U.vprint(&#39;Early stopping due to no further improvement.&#39;, verbose=verbose)
            # U.vprint(&#39;final loss:%s, final score:%s&#39; % (loss, acc), verbose=verbose)
        return hist

    def layer_output(self, layer_id, example_id=0, batch_id=0, use_val=False):
        &#34;&#34;&#34;
        ```
        Prints output of layer with index &lt;layer_id&gt; to help debug models.
        Uses first example (example_id=0) from first batch from training set, by default.
        ```
        &#34;&#34;&#34;

        inp = self.model.layers[0].input
        outp = self.model.layers[layer_id].output
        f_out = K.function([inp], [outp])
        if not use_val:
            example = self.train_data[0][batch_id][example_id]
        else:
            example = self.val_data[0][batch_id][example_id]
        layer_out = f_out(
            [
                np.array(
                    [
                        example,
                    ]
                )
            ]
        )[0]
        return layer_out

    # def view_top_losses(self, n=4, preproc=None, val_data=None):
    #    &#34;&#34;&#34;
    #    Views observations with top losses in validation set.
    #    Musta be overridden by Learner subclasses.
    #    &#34;&#34;&#34;
    #    raise NotImplementedError(&#39;view_top_losses must be overriden by GenLearner subclass&#39;)
    def view_top_losses(self, n=4, preproc=None, val_data=None):
        &#34;&#34;&#34;
        ```
        Views observations with top losses in validation set.
        Typically over-ridden by Learner subclasses.
        Args:
         n(int or tuple): a range to select in form of int or tuple
                          e.g., n=8 is treated as n=(0,8)
         preproc (Preprocessor): A TextPreprocessor or ImagePreprocessor.
                                 For some data like text data, a preprocessor
                                 is required to undo the pre-processing
                                 to correctly view raw data.
          val_data:  optional val_data to use instead of self.val_data
        Returns:
            list of n tuples where first element is either
            filepath or id of validation example and second element
            is loss.
        ```
        &#34;&#34;&#34;
        val = self._check_val(val_data)

        # get top losses and associated data
        tups = self.top_losses(n=n, val_data=val, preproc=preproc)

        # get multilabel status and class names
        classes = preproc.get_classes() if preproc is not None else None
        # iterate through losses
        for tup in tups:
            # get data
            idx = tup[0]
            loss = tup[1]
            truth = tup[2]
            pred = tup[3]

            print(&#34;----------&#34;)
            print(
                &#34;id:%s | loss:%s | true:%s | pred:%s)\n&#34;
                % (idx, round(loss, 2), truth, pred)
            )
        return</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ktrain.core.Learner" href="#ktrain.core.Learner">Learner</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ktrain.graph.learner.LinkPredLearner" href="graph/learner.html#ktrain.graph.learner.LinkPredLearner">LinkPredLearner</a></li>
<li><a title="ktrain.graph.learner.NodeClassLearner" href="graph/learner.html#ktrain.graph.learner.NodeClassLearner">NodeClassLearner</a></li>
<li><a title="ktrain.text.learner.TransformerTextClassLearner" href="text/learner.html#ktrain.text.learner.TransformerTextClassLearner">TransformerTextClassLearner</a></li>
<li><a title="ktrain.text.ner.learner.NERLearner" href="text/ner/learner.html#ktrain.text.ner.learner.NERLearner">NERLearner</a></li>
<li><a title="ktrain.vision.learner.ImageClassLearner" href="vision/learner.html#ktrain.vision.learner.ImageClassLearner">ImageClassLearner</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ktrain.core.GenLearner.fit"><code class="name flex">
<span>def <span class="ident">fit</span></span>(<span>self, lr, n_cycles, cycle_len=None, cycle_mult=1, lr_decay=1.0, checkpoint_folder=None, early_stopping=None, class_weight=None, callbacks=[], steps_per_epoch=None, verbose=1)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>Trains the model. By default, fit is simply a wrapper for model.fit (for generators/sequences).
When cycle_len parameter is supplied, an SGDR learning rate schedule is used.

lr (float): learning rate
n_cycles (int):  n_cycles
cycle_len (int): If not None, decay learning rate over &lt;cycle_len&gt;
                 epochs until restarting/resetting learning rate to &lt;lr&gt;.
                 If None, lr remains constant
cycle_mult (int): Increase cycle_len by factor of cycle_mult.
                  This will gradually elongate the cycle.
                  Has no effect if cycle_len is None.
lr_decay (float): rate of decay of learning reach each cycle.
                  Has no effect if cycle_len is None
checkpoint_folder (string): Folder path in which to save the model weights
                           for each epoch.
                           File name will be of the form:
                           weights-{epoch:02d}-{val_loss:.2f}.hdf5
early_stopping (int):     If not None, training will automatically stop after this many
                          epochs of no improvement in validation loss.
                          Upon completion, model will be loaded with weights from epoch
                          with lowest validation loss.
class_weight (dict):       Optional dictionary mapping class indices (integers) to a weight (float)
callbacks (list):         list of Callback instances to employ during training
steps_per_epoch(int):    Steps per epoch. If None, then, math.ceil(num_samples/batch_size) is used.
verbose (boolean):       whether or not to print progress bar
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit(
    self,
    lr,
    n_cycles,
    cycle_len=None,
    cycle_mult=1,
    lr_decay=1.0,
    checkpoint_folder=None,
    early_stopping=None,
    class_weight=None,
    callbacks=[],
    steps_per_epoch=None,
    verbose=1,
):
    &#34;&#34;&#34;
    ```
    Trains the model. By default, fit is simply a wrapper for model.fit (for generators/sequences).
    When cycle_len parameter is supplied, an SGDR learning rate schedule is used.

    lr (float): learning rate
    n_cycles (int):  n_cycles
    cycle_len (int): If not None, decay learning rate over &lt;cycle_len&gt;
                     epochs until restarting/resetting learning rate to &lt;lr&gt;.
                     If None, lr remains constant
    cycle_mult (int): Increase cycle_len by factor of cycle_mult.
                      This will gradually elongate the cycle.
                      Has no effect if cycle_len is None.
    lr_decay (float): rate of decay of learning reach each cycle.
                      Has no effect if cycle_len is None
    checkpoint_folder (string): Folder path in which to save the model weights
                               for each epoch.
                               File name will be of the form:
                               weights-{epoch:02d}-{val_loss:.2f}.hdf5
    early_stopping (int):     If not None, training will automatically stop after this many
                              epochs of no improvement in validation loss.
                              Upon completion, model will be loaded with weights from epoch
                              with lowest validation loss.
    class_weight (dict):       Optional dictionary mapping class indices (integers) to a weight (float)
    callbacks (list):         list of Callback instances to employ during training
    steps_per_epoch(int):    Steps per epoch. If None, then, math.ceil(num_samples/batch_size) is used.
    verbose (boolean):       whether or not to print progress bar
    ```
    &#34;&#34;&#34;
    # check early_stopping
    if self.val_data is None and early_stopping is not None:
        raise ValueError(
            &#34;early_stopping monitors val_loss but validation data not set&#34;
        )

    # handle callbacks
    num_samples = U.nsamples_from_data(self.train_data)
    train_bs = (
        self.train_data.batch_size
        if hasattr(self.train_data, &#34;batch_size&#34;)
        else self.batch_size
    )
    if steps_per_epoch is None:
        steps_per_epoch = math.ceil(num_samples / train_bs)
    validation_steps = None
    if self.val_data is not None:
        val_bs = (
            self.val_data.batch_size
            if hasattr(self.val_data, &#34;batch_size&#34;)
            else self.batch_size
        )
        validation_steps = math.ceil(U.nsamples_from_data(self.val_data) / val_bs)

    epochs = self._check_cycles(n_cycles, cycle_len, cycle_mult)
    self.set_lr(lr)

    # set call backs
    kcallbacks = callbacks if callbacks else None
    kcallbacks = self._cb_sgdr(
        lr, steps_per_epoch, cycle_len, cycle_mult, lr_decay, callbacks=kcallbacks
    )
    kcallbacks = self._cb_checkpoint(checkpoint_folder, callbacks=kcallbacks)
    kcallbacks = self._cb_earlystopping(early_stopping, callbacks=kcallbacks)
    sgdr = (
        [cb for cb in kcallbacks if type(cb).__name__ == &#34;SGDRScheduler&#34;]
        if kcallbacks
        else None
    )
    sgdr = sgdr[0] if sgdr else None
    # if kcallbacks: print([type(cb).__name__ for cb in kcallbacks])

    # MNIST times per epoch on Titan V
    # workers=4, usemp=True 9 sec.
    # workers=1, usemp=True 12 sec.
    # workers=1, usemp=False 16 sec.
    # workers=4, usemp=False 30+ sec.
    # print(self.workers)
    # print(self.use_multiprocessing)

    # train model
    with warnings.catch_warnings():
        warnings.filterwarnings(&#34;ignore&#34;, message=&#34;.*Check your callbacks.*&#34;)
        fit_fn = self.model.fit
        hist = fit_fn(
            self._prepare(self.train_data),
            steps_per_epoch=steps_per_epoch,
            validation_steps=validation_steps,
            epochs=epochs,
            validation_data=self._prepare(self.val_data, train=False),
            workers=self.workers,
            use_multiprocessing=self.use_multiprocessing,
            verbose=verbose,
            shuffle=True,
            class_weight=class_weight,
            callbacks=kcallbacks,
        )
    if sgdr is not None:
        hist.history[&#34;lr&#34;] = sgdr.history[&#34;lr&#34;]
    self.history = hist

    if early_stopping:
        U.vprint(
            &#34;Weights from best epoch have been loaded into model.&#34;, verbose=verbose
        )
        # loss, acc = self.model.evaluate_generator(self.val_data)
        # U.vprint(&#39;\n&#39;, verbose=verbose)
        # U.vprint(&#39;Early stopping due to no further improvement.&#39;, verbose=verbose)
        # U.vprint(&#39;final loss:%s, final score:%s&#39; % (loss, acc), verbose=verbose)
    return hist</code></pre>
</details>
</dd>
<dt id="ktrain.core.GenLearner.layer_output"><code class="name flex">
<span>def <span class="ident">layer_output</span></span>(<span>self, layer_id, example_id=0, batch_id=0, use_val=False)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>Prints output of layer with index &lt;layer_id&gt; to help debug models.
Uses first example (example_id=0) from first batch from training set, by default.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def layer_output(self, layer_id, example_id=0, batch_id=0, use_val=False):
    &#34;&#34;&#34;
    ```
    Prints output of layer with index &lt;layer_id&gt; to help debug models.
    Uses first example (example_id=0) from first batch from training set, by default.
    ```
    &#34;&#34;&#34;

    inp = self.model.layers[0].input
    outp = self.model.layers[layer_id].output
    f_out = K.function([inp], [outp])
    if not use_val:
        example = self.train_data[0][batch_id][example_id]
    else:
        example = self.val_data[0][batch_id][example_id]
    layer_out = f_out(
        [
            np.array(
                [
                    example,
                ]
            )
        ]
    )[0]
    return layer_out</code></pre>
</details>
</dd>
<dt id="ktrain.core.GenLearner.view_top_losses"><code class="name flex">
<span>def <span class="ident">view_top_losses</span></span>(<span>self, n=4, preproc=None, val_data=None)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>Views observations with top losses in validation set.
Typically over-ridden by Learner subclasses.
Args:
 n(int or tuple): a range to select in form of int or tuple
                  e.g., n=8 is treated as n=(0,8)
 preproc (Preprocessor): A TextPreprocessor or ImagePreprocessor.
                         For some data like text data, a preprocessor
                         is required to undo the pre-processing
                         to correctly view raw data.
  val_data:  optional val_data to use instead of self.val_data
Returns:
    list of n tuples where first element is either
    filepath or id of validation example and second element
    is loss.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def view_top_losses(self, n=4, preproc=None, val_data=None):
    &#34;&#34;&#34;
    ```
    Views observations with top losses in validation set.
    Typically over-ridden by Learner subclasses.
    Args:
     n(int or tuple): a range to select in form of int or tuple
                      e.g., n=8 is treated as n=(0,8)
     preproc (Preprocessor): A TextPreprocessor or ImagePreprocessor.
                             For some data like text data, a preprocessor
                             is required to undo the pre-processing
                             to correctly view raw data.
      val_data:  optional val_data to use instead of self.val_data
    Returns:
        list of n tuples where first element is either
        filepath or id of validation example and second element
        is loss.
    ```
    &#34;&#34;&#34;
    val = self._check_val(val_data)

    # get top losses and associated data
    tups = self.top_losses(n=n, val_data=val, preproc=preproc)

    # get multilabel status and class names
    classes = preproc.get_classes() if preproc is not None else None
    # iterate through losses
    for tup in tups:
        # get data
        idx = tup[0]
        loss = tup[1]
        truth = tup[2]
        pred = tup[3]

        print(&#34;----------&#34;)
        print(
            &#34;id:%s | loss:%s | true:%s | pred:%s)\n&#34;
            % (idx, round(loss, 2), truth, pred)
        )
    return</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ktrain.core.Learner" href="#ktrain.core.Learner">Learner</a></b></code>:
<ul class="hlist">
<li><code><a title="ktrain.core.Learner.autofit" href="#ktrain.core.Learner.autofit">autofit</a></code></li>
<li><code><a title="ktrain.core.Learner.evaluate" href="#ktrain.core.Learner.evaluate">evaluate</a></code></li>
<li><code><a title="ktrain.core.Learner.fit_onecycle" href="#ktrain.core.Learner.fit_onecycle">fit_onecycle</a></code></li>
<li><code><a title="ktrain.core.Learner.freeze" href="#ktrain.core.Learner.freeze">freeze</a></code></li>
<li><code><a title="ktrain.core.Learner.get_weight_decay" href="#ktrain.core.Learner.get_weight_decay">get_weight_decay</a></code></li>
<li><code><a title="ktrain.core.Learner.load_model" href="#ktrain.core.Learner.load_model">load_model</a></code></li>
<li><code><a title="ktrain.core.Learner.lr_estimate" href="#ktrain.core.Learner.lr_estimate">lr_estimate</a></code></li>
<li><code><a title="ktrain.core.Learner.lr_find" href="#ktrain.core.Learner.lr_find">lr_find</a></code></li>
<li><code><a title="ktrain.core.Learner.lr_plot" href="#ktrain.core.Learner.lr_plot">lr_plot</a></code></li>
<li><code><a title="ktrain.core.Learner.plot" href="#ktrain.core.Learner.plot">plot</a></code></li>
<li><code><a title="ktrain.core.Learner.predict" href="#ktrain.core.Learner.predict">predict</a></code></li>
<li><code><a title="ktrain.core.Learner.print_layers" href="#ktrain.core.Learner.print_layers">print_layers</a></code></li>
<li><code><a title="ktrain.core.Learner.reset_weights" href="#ktrain.core.Learner.reset_weights">reset_weights</a></code></li>
<li><code><a title="ktrain.core.Learner.save_model" href="#ktrain.core.Learner.save_model">save_model</a></code></li>
<li><code><a title="ktrain.core.Learner.set_model" href="#ktrain.core.Learner.set_model">set_model</a></code></li>
<li><code><a title="ktrain.core.Learner.set_weight_decay" href="#ktrain.core.Learner.set_weight_decay">set_weight_decay</a></code></li>
<li><code><a title="ktrain.core.Learner.top_losses" href="#ktrain.core.Learner.top_losses">top_losses</a></code></li>
<li><code><a title="ktrain.core.Learner.unfreeze" href="#ktrain.core.Learner.unfreeze">unfreeze</a></code></li>
<li><code><a title="ktrain.core.Learner.validate" href="#ktrain.core.Learner.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ktrain.core.Learner"><code class="flex name class">
<span>class <span class="ident">Learner</span></span>
<span>(</span><span>model, workers=1, use_multiprocessing=False)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>Abstract class used to tune and train Keras models. The fit method is
an abstract method and must be implemented by subclasses.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Learner(ABC):
    &#34;&#34;&#34;
    ```
    Abstract class used to tune and train Keras models. The fit method is
    an abstract method and must be implemented by subclasses.
    ```

    &#34;&#34;&#34;

    def __init__(self, model, workers=1, use_multiprocessing=False):
        if not isinstance(model, keras.Model):
            raise ValueError(&#34;model must be of instance keras.Model&#34;)
        self.model = model
        self.lr_finder = LRFinder(self.model)
        self.workers = workers
        self.use_multiprocessing = use_multiprocessing
        self.history = None

        # save original weights of model
        try:
            new_file, weightfile = tempfile.mkstemp()
            self.model.save_weights(weightfile)
            self._original_weights = weightfile
        except Exception as e:
            warnings.warn(&#34;Could not save original model weights: %s&#34; % (e))
            self._original_weights = None

    @property
    def _monitor_metrics(self):
        &#34;&#34;&#34;
        ```
        monitor metrics
        ```
        &#34;&#34;&#34;
        metrics = [&#34;loss&#34;]
        try:
            m = U.metrics_from_model(self.model)
            if isinstance(m, list):
                metrics.extend(m)
        except:
            pass
        if self.val_data is not None:
            for m in metrics[:]:
                metrics.append(&#34;val_%s&#34; % (m))
        return metrics

    def get_weight_decay(self):
        &#34;&#34;&#34;
        ```
        Get current weight decay rate
        ```
        &#34;&#34;&#34;
        if type(self.model.optimizer).__name__ == &#34;AdamWeightDecay&#34;:
            return self.model.optimizer.weight_decay_rate
        else:
            return None

    def set_weight_decay(self, wd=U.DEFAULT_WD):
        &#34;&#34;&#34;
        ```
        Sets global weight decay via AdamWeightDecay optimizer
        Args:
          wd(float): weight decay
        Returns:
          None
        ```
        &#34;&#34;&#34;
        self._recompile(wd=wd)
        return

    def evaluate(
        self,
        test_data=None,
        print_report=True,
        save_path=&#34;ktrain_classification_report.csv&#34;,
        class_names=[],
    ):
        &#34;&#34;&#34;
        ```
        alias for self.validate().
        Returns confusion matrix and optionally prints
        a classification report.
        This is currently only supported for binary and multiclass
        classification, not multilabel classification.

        By default, this uses val_data, as supplied to ktrain.get_learner().
        Other validation or test data can be optionally be supplied as argument via &lt;test_data&gt; argument.
        Supply class_names to include labels instead of intenger class integer values in classification report.
        Args:
          test_data(Dataset|np.ndarray): test or validation data.  If None, self.val_data is used.
          print_report(bool): If True, classification report will be printed. If False, report will be saved to CSV
                              at save_path. Not applicable to regression models.
                              Not applicable to regression models.
          save_path(str): Classification report will be saved to this file path/name if print_report=False
                          Not applicable to regression models.
          class_names(list): list of class names to be used in classification report instead of
                             class integer IDs.
        ```
        &#34;&#34;&#34;
        return self.validate(
            val_data=test_data,
            print_report=print_report,
            save_path=save_path,
            class_names=class_names,
        )

    def validate(
        self,
        val_data=None,
        print_report=True,
        save_path=&#34;ktrain_classification_report.csv&#34;,
        class_names=[],
    ):
        &#34;&#34;&#34;
        ```
        Returns confusion matrix and optionally prints
        a classification report.
        This is currently only supported for binary and multiclass
        classification, not multilabel classification.

        By default, this uses val_data, as supplied to ktrain.get_learner().
        Other validation or test data can be optionally be supplied as argument.
        Supply class_names to include labels instead of intenger class integer values in classification report.
        Args:
          val_data(Dataset|np.ndarray): validation data.  If None, self.val_data is used.
          print_report(bool): If True, classification report will be printed. If False, report will be saved to CSV
                              at save path. Not applicable to regression models.
          save_path(str): Classification report will be saved to this file path/name if print_report=False
          class_names(list): list of class names to be used in classification report instead of
                             class integer IDs.
        ```
        &#34;&#34;&#34;
        if val_data is not None:
            val = val_data
        else:
            val = self.val_data

        classification, multilabel = U.is_classifier(self.model)
        if not classification:
            # warnings.warn(&#39;learner.validate is only for classification problems. &#39;
            #&#39;For regression, etc., use learner.predict and learner.ground_truth &#39;
            #&#39;to manually validate.&#39;)
            # return
            pass

        if U.is_multilabel(val) or multilabel:
            warnings.warn(&#34;multilabel confusion matrices not yet supported&#34;)
            return
        y_pred = self.predict(val_data=val)
        y_true = self.ground_truth(val_data=val)
        y_pred = np.squeeze(y_pred)
        y_true = np.squeeze(y_true)

        # regression evaluation
        if not classification:
            from sklearn.metrics import mean_absolute_error, mean_squared_error

            regout = []
            metrics = U.metrics_from_model(self.model)
            for m in metrics:
                if m in [&#34;mae&#34;, &#34;mean_absolute_error&#34;]:
                    regout.append((m, mean_absolute_error(y_true, y_pred)))
                elif m in [&#34;mse&#34;, &#34;mean_squared_error&#34;]:
                    regout.append((m, mean_squared_error(y_true, y_pred)))
            if not regout:
                warnings.warn(
                    &#34;%s is not supported by validate/evaluate - falling back to MAE&#34;
                )
                regout.append((&#34;mae&#34;, mean_absolute_error(y_true, y_pred)))
            return regout

        if len(y_pred.shape) == 1:
            y_pred = np.where(y_pred &gt; 0.5, 1, 0)
            y_true = np.where(y_true &gt; 0.5, 1, 0)
        else:
            y_pred = np.argmax(y_pred, axis=1)
            y_true = np.argmax(y_true, axis=1)
        if print_report or save_path is not None:
            if class_names:
                try:
                    class_names = [str(s) for s in class_names]
                except:
                    pass
                report = classification_report(
                    y_true,
                    y_pred,
                    target_names=class_names,
                    output_dict=not print_report,
                )
            else:
                report = classification_report(
                    y_true, y_pred, output_dict=not print_report
                )
            if print_report:
                print(report)
            else:
                df = pd.DataFrame(report).transpose()
                df.to_csv(save_path)
                print(&#34;classification report saved to: %s&#34; % (save_path))
            cm_func = confusion_matrix
        cm = confusion_matrix(y_true, y_pred)
        return cm

    def _check_val(self, val_data):
        if val_data is not None:
            val = val_data
        else:
            val = self.val_data
        if val is None:
            raise Exception(
                &#34;val_data must be supplied to get_learner or view_top_losses&#34;
            )
        return val

    def top_losses(self, n=4, val_data=None, preproc=None):
        &#34;&#34;&#34;
        ```
        Computes losses on validation set sorted by examples with top losses
        Args:
          n(int or tuple): a range to select in form of int or tuple
                          e.g., n=8 is treated as n=(0,8)
          val_data:  optional val_data to use instead of self.val_data
          preproc (Preprocessor): A TextPreprocessor or ImagePreprocessor.
                                  For some data like text data, a preprocessor
                                  is required to undo the pre-processing
                                   to correctly view raw data.
        Returns:
            list of n tuples where first element is either
            filepath or id of validation example and second element
            is loss.
        ```
        &#34;&#34;&#34;

        # check validation data and arguments
        if val_data is not None:
            val = val_data
        else:
            val = self.val_data
        if val is None:
            raise Exception(&#34;val_data must be supplied to get_learner or top_losses&#34;)
        if type(n) == type(42):
            n = (0, n)

        # multilabel = True if U.is_multilabel(val) else False
        classification, multilabel = U.is_classifier(self.model)

        # get predicictions and ground truth
        y_pred = self.predict(val_data=val)
        y_true = self.ground_truth(val_data=val)
        y_true = y_true.astype(&#34;float32&#34;)

        # adjust y_true for regression problems
        if (
            not classification
            and len(y_true.shape) == 1
            and (len(y_pred.shape) == 2 and y_pred.shape[1] == 1)
        ):
            y_true = np.expand_dims(y_true, -1)

        # compute loss
        # this doesn&#39;t work in tf.keras 1.14
        # losses = self.model.loss_functions[0](tf.convert_to_tensor(y_true), tf.convert_to_tensor(y_pred))
        # if U.is_tf_keras():
        # L = self.model.loss_functions[0].fn
        # else:
        # L = self.model.loss_functions[0]
        L = U.loss_fn_from_model(self.model)
        losses = L(tf.convert_to_tensor(y_true), tf.convert_to_tensor(y_pred))
        if DISABLE_V2_BEHAVIOR:
            losses = tf.Session().run(losses)
        else:
            losses = losses.numpy()

        class_names = [] if preproc is None else preproc.get_classes()
        if preproc is None:
            class_fcn = lambda x: &#34;%s&#34; % (x)
        else:
            class_fcn = lambda x: class_names[x]

        # regression output modifications
        if not classification:
            if len(y_pred.shape) == 2 and y_pred.shape[1] == 1:
                y_pred = np.squeeze(y_pred)
                y_pred = np.around(y_pred, 2)
            if len(y_true.shape) == 2 and y_true.shape[1] == 1:
                y_true = np.squeeze(y_true)
                y_true = np.around(y_true, 2)

        # sort by loss and prune correct classifications, if necessary
        if classification and not multilabel:
            y_pred = np.squeeze(y_pred)
            y_true = np.squeeze(y_true)
            if len(y_pred.shape) == 1:
                y_p = np.where(y_pred &gt; 0.5, 1, 0)
                y_t = np.where(y_true &gt; 0.5, 1, 0)
            else:
                y_p = np.argmax(y_pred, axis=1)
                y_t = np.argmax(y_true, axis=1)
            tups = [
                (i, x, class_fcn(y_t[i]), class_fcn(y_p[i]))
                for i, x in enumerate(losses)
                if y_p[i] != y_t[i]
            ]
        else:
            tups = [
                (i, x, y_true[i], np.around(y_pred[i], 2)) for i, x in enumerate(losses)
            ]
        tups.sort(key=operator.itemgetter(1), reverse=True)

        # prune by given range
        tups = tups[n[0] : n[1]] if n is not None else tups
        return tups

    def view_top_losses(self, n=4, preproc=None, val_data=None):
        &#34;&#34;&#34;
        ```
        View observations with top losses in validation set.
        Musta be overridden by Learner subclasses.
        ```
        &#34;&#34;&#34;
        raise NotImplementedError(
            &#34;view_top_losses must be overriden by Learner subclass&#34;
        )

    def _make_model_folder(self, fpath):
        if os.path.isfile(fpath):
            raise ValueError(
                f&#34;There is an existing file named {fpath}. &#34;
                + &#34;Please use dfferent value for fpath.&#34;
            )
        elif os.path.exists(fpath):
            # warnings.warn(&#39;model is being saved to folder that already exists: %s&#39; % (fpath))
            pass
        elif not os.path.exists(fpath):
            os.makedirs(fpath)

    def save_model(self, fpath):
        &#34;&#34;&#34;
        ```
        a wrapper to model.save
        Args:
          fpath(str): path to folder in which to save model
        Returns:
          None
        ```
        &#34;&#34;&#34;
        self._make_model_folder(fpath)
        self.model.save(os.path.join(fpath, U.MODEL_NAME), save_format=&#34;h5&#34;)
        return

    def load_model(self, fpath, custom_objects=None, **kwargs):
        &#34;&#34;&#34;
        ```
        loads model from folder.
        Note: **kwargs included for backwards compatibility only, as TransformerTextClassLearner.load_model was removed in v0.18.0.
        Args:
          fpath(str): path to folder containing model
          custom_objects(dict): custom objects required to load model.
                                For models included with ktrain, this is populated automatically
                                and can be disregarded.

        ```
        &#34;&#34;&#34;
        self.model = _load_model(
            fpath, train_data=self.train_data, custom_objects=custom_objects
        )
        return

    def _is_adamlike(self):
        &#34;&#34;&#34;
        ```
        checks whether optimizer attached to model is an
        &#34;Adam-like&#34; optimizer with beta_1 parameter.
        ```
        &#34;&#34;&#34;
        return self.model is not None and hasattr(self.model.optimizer, &#34;beta_1&#34;)

    def _recompile(self, wd=None):
        metrics = U.metrics_from_model(self.model)
        if (
            wd is not None
            and wd &gt; 0
            and type(self.model.optimizer).__name__ != &#34;AdamWeightDecay&#34;
        ):
            warnings.warn(
                &#34;recompiling model to use AdamWeightDecay as opimizer with weight decay of %s&#34;
                % (wd)
            )
            optimizer = U.get_default_optimizer(wd=wd)
        elif wd is not None and wd &gt; 0:
            optimizer = U.get_default_optimizer(wd=wd)
        elif wd is not None and wd == 0:
            optimizer = U.DEFAULT_OPT
        else:  # wd is None -&gt; don&#39;t modify optimizer
            optimizer = self.model.optimizer
        self.model.compile(optimizer=optimizer, loss=self.model.loss, metrics=metrics)

        return

    def set_model(self, model):
        &#34;&#34;&#34;
        ```
        replace model in this Learner instance
        ```
        &#34;&#34;&#34;
        if not isinstance(model, keras.Model):
            raise ValueError(&#34;model must be of instance keras.Model&#34;)
        self.model = model
        self.history = None
        return

    def freeze(self, freeze_range=None):
        &#34;&#34;&#34;
        ```
        If freeze_range is None, makes all layers trainable=False except last Dense layer.
        If freeze_range is given, freezes the first &lt;freeze_range&gt; layers and
        unfrezes all remaining layers.
        NOTE:      Freeze method does not currently work with
                   multi-GPU models.  If you are using the load_imagemodel method,
                   please use the freeze_layers argument of load_imagemodel
                   to freeze layers.
        Args:
            freeze_range(int): number of layers to freeze
        Returns:
            None
        ```
        &#34;&#34;&#34;

        if freeze_range is None:
            # freeze everything except last Dense layer
            # first find last dense layer
            dense_id = None
            for i, layer in reversed(list(enumerate(self.model.layers))):
                if isinstance(layer, keras.layers.Dense):
                    dense_id = i
                    break
            if dense_id is None:
                raise Exception(&#34;cannot find Dense layer in this model&#34;)
            for i, layer in enumerate(self.model.layers):
                if i &lt; dense_id:
                    layer.trainable = False
                else:
                    layer.trainable = True
        else:
            # freeze all layers up to and including layer_id
            if type(freeze_range) != type(1) or freeze_range &lt; 1:
                raise ValueError(&#34;freeze_range must be integer &gt; 0&#34;)
            for i, layer in enumerate(self.model.layers):
                if i &lt; freeze_range:
                    layer.trainable = False
                else:
                    layer.trainable = True
        self._recompile()
        return

    def unfreeze(self, exclude_range=None):
        &#34;&#34;&#34;
        ```
        Make every layer trainable except those in exclude_range.
        unfreeze is simply a proxy method to freeze.
        NOTE:      Unfreeze method does not currently work with
                   multi-GPU models.  If you are using the load_imagemodel method,
                   please use the freeze_layers argument of load_imagemodel
                   to freeze layers.
        ```
        &#34;&#34;&#34;
        # make all layers trainable
        for i, layer in enumerate(self.model.layers):
            layer.trainable = True
        if exclude_range:
            for i, layer in enumerate(self.model.layers[:exclude_range]):
                layer.trainable = False
        self._recompile()
        return

    def reset_weights(self, verbose=1):
        &#34;&#34;&#34;
        ```
        Re-initializes network with original weights
        ```
        &#34;&#34;&#34;

        if os.path.isfile(self._original_weights):
            self.model.load_weights(self._original_weights)
            self.history = None
            U.vprint(&#34;Model weights have been reset.&#34;, verbose=verbose)
        else:
            warnings.warn(
                &#34;Weights have not been reset because the original weights file &#34;
                + &#34;(%s) no longer exists.&#34; % (self._original_weights)
            )
        return

    def lr_find(
        self,
        start_lr=1e-7,
        lr_mult=1.01,
        max_epochs=None,
        class_weight=None,
        stop_factor=4,
        show_plot=False,
        suggest=False,
        restore_weights_only=False,
        verbose=1,
    ):
        &#34;&#34;&#34;
        ```
        Plots loss as learning rate is increased.  Highest learning rate
        corresponding to a still falling loss should be chosen.

        If you find the LR finder is running for more epochs than you&#39;d prefer,
        you can set max_epochs (e.g., max_epochs=5) to estimate LR with a
        smaller sample size.

        If lr_mult is supplied and max_epochs is None, LR will increase until loss diverges.
        Reasonable values of lr_mult are between 1.01 and 1.05.

        If max_epochs is supplied, lr_mult argument is ignored and computed automatically.

        Reference: https://arxiv.org/abs/1506.01186

        Args:
            start_lr (float): smallest lr to start simulation
            lr_mult (float): multiplication factor to increase LR.
                             Ignored if max_epochs is supplied.
            max_epochs (int):  maximum number of epochs to simulate.
                               lr_mult is ignored if max_epoch is supplied.
                               Default is None. Set max_epochs to an integer
                               (e.g., 5) if lr_find is taking too long
                               and running for more epochs than desired.
            class_weight(dict): class_weight parameter passed to model.fit
                                for imbalanced datasets.
            stop_factor(int): factor used to determine threhsold that loss
                              must exceed to stop training simulation.
                              Increase this if loss is erratic and lr_find
                              exits too early.
            show_plot (bool):  If True, automatically invoke lr_plot
            restore_weights_only(bool): If True, when training simulation is complete,
                                        the model weights only are restored, but not
                                        the original optimizer weights.
                                        In at least a few cases, this seems to improve performance
                                        when actual training begins. Further investigation is needed,
                                        so it is False by default.
            verbose (bool): specifies how much output to print
        Returns:
            None
        ```
        &#34;&#34;&#34;
        # dep_fix: bug in TF 2.2 and 2.3
        if version.parse(tf.__version__) &gt; version.parse(&#34;2.1&#34;) and version.parse(
            tf.__version__
        ) &lt; version.parse(&#34;2.4&#34;):
            if max_epochs is None:
                raise ValueError(
                    &#34;Due to a bug in TensorFlow 2.2 and 2.3, the max_epochs argument is temporarily required. &#34;
                    + &#34;Please re-run with max_epochs (e.g., max_epochs=5). \n&#34;
                    + &#34;More info: https://github.com/tensorflow/tensorflow/issues/41174#issuecomment-656330268&#34;
                )

        U.vprint(
            &#34;simulating training for different learning rates... this may take a few moments...&#34;,
            verbose=verbose,
        )
        # save current weights and temporarily restore original weights
        # dep_fix: temporarily use save_model instead of save_weights as default due to https://github.com/tensorflow/tensorflow/issues/41116
        _weights_only = True
        if restore_weights_only:
            new_file, weightfile = tempfile.mkstemp()
            self.model.save_weights(weightfile)
        else:
            temp_folder = tempfile.mkdtemp()
            self.save_model(temp_folder)

        # compute steps_per_epoch
        num_samples = U.nsamples_from_data(self.train_data)
        bs = (
            self.train_data.batch_size
            if hasattr(self.train_data, &#34;batch_size&#34;)
            else self.batch_size
        )
        if U.is_iter(self.train_data):
            use_gen = True
            steps_per_epoch = num_samples // bs
        else:
            use_gen = False
            steps_per_epoch = np.ceil(num_samples / bs)

        # check steps_per_epoch
        if steps_per_epoch &lt;= 64 and max_epochs is None:
            warnings.warn(
                &#34;max_epochs is being set to 5 since steps per epoch is small. &#34;
                + &#34;If you wish to estimate LR using more epochs, set max_epochs manually.&#34;
            )
            max_epochs = 5

        try:
            # track and plot learning rates
            self.lr_finder = LRFinder(self.model, stop_factor=stop_factor)
            self.lr_finder.find(
                self._prepare(self.train_data),
                steps_per_epoch,
                use_gen=use_gen,
                start_lr=start_lr,
                lr_mult=lr_mult,
                max_epochs=max_epochs,
                class_weight=class_weight,
                workers=self.workers,
                use_multiprocessing=self.use_multiprocessing,
                batch_size=self.batch_size,
                verbose=verbose,
            )
        except KeyboardInterrupt:
            # re-load current weights
            # self.model.load_weights(weightfile)
            self.load_model(temp_folder)
            return

        # re-load current weights
        # dep_fix: temporarily use load_model instead of load_weights as default due to https://github.com/tensorflow/tensorflow/issues/41116
        if restore_weights_only:
            self.model.load_weights(weightfile)
        else:
            self.load_model(temp_folder)

        # instructions to invoker
        U.vprint(&#34;\n&#34;, verbose=verbose)
        U.vprint(&#34;done.&#34;, verbose=verbose)
        if show_plot:
            U.vprint(
                &#34;Visually inspect loss plot and select learning rate associated with falling loss&#34;,
                verbose=verbose,
            )
            self.lr_plot(suggest=suggest)
        else:
            U.vprint(
                &#34;Please invoke the Learner.lr_plot() method to visually inspect &#34;
                &#34;the loss plot to help identify the maximal learning rate &#34;
                &#34;associated with falling loss.&#34;,
                verbose=verbose,
            )
        return

    def lr_estimate(self):
        &#34;&#34;&#34;
        ```
        Return numerical estimates of lr using two different methods:
          1. lr associated with minum numerical gradient (None if gradient computation fails)
          2. lr associated with minimum loss divided by 10
          3. lr associated with longest valley
        Since none of these methods are fool-proof and can
        potentially return bad estimates, it is recommended that you
        examine the plot generated by lr_plot to estimate the learning rate.
        Returns:
          tuple: tuple of the form (float, float)
        ```
        &#34;&#34;&#34;
        if self.lr_finder is None or not self.lr_finder.find_called():
            raise ValueError(&#34;Please call lr_find first.&#34;)
        return self.lr_finder.estimate_lr()

    def lr_plot(
        self, n_skip_beginning=10, n_skip_end=5, suggest=False, return_fig=False
    ):
        &#34;&#34;&#34;
        ```
        Plots the loss vs. learning rate to help identify
        The maximal learning rate associated with a falling loss.
        The nskip_beginning and n_skip_end arguments can be used
        to &#34;zoom in&#34; on the plot.
        Args:
            n_skip_beginning(int): number of batches to skip on the left.
            n_skip_end(int):  number of batches to skip on the right.
            suggest(bool): will highlight numerical estimate
                           of best lr if True - methods adapted from fastai
            return_fig(bool): If True, return matplotlib.figure.Figure
        Returns:
          matplotlib.figure.Figure if return_fig else None
        ```
        &#34;&#34;&#34;
        # dep_fix: bug in TF 2.2 and 2.3
        if version.parse(tf.__version__) &gt; version.parse(&#34;2.1&#34;) and version.parse(
            tf.__version__
        ) &lt; version.parse(&#34;2.4&#34;):
            if n_skip_end == 5:
                n_skip_end = 10

        if self.lr_finder is None or not self.lr_finder.find_called():
            raise ValueError(&#34;Please call lr_find first.&#34;)
        return self.lr_finder.plot_loss(
            n_skip_beginning=n_skip_beginning,
            n_skip_end=n_skip_end,
            suggest=suggest,
            return_fig=return_fig,
        )

    def plot(self, plot_type=&#34;loss&#34;, return_fig=False):
        &#34;&#34;&#34;
        ```
        plots training history
        Args:
          plot_type (str):  A valid value in tf.keras History.  Either a built-in value  {&#39;loss&#39;, &#39;lr&#39;, &#39;momentum&#39;} or
                            other values previously specified by user.  For instance, if &#39;mae&#39; and/or &#39;mse&#39; is previously specified as metrics
                            when creating model, then these values can also be specified.
          return_fig(bool):  If True, return matplotlib.figure.Figure
        Return:
          matplotlib.figure.Figure if return_fig else None
        ```
        &#34;&#34;&#34;
        if self.history is None:
            raise Exception(&#34;No training history - did you train the model yet?&#34;)
        if not isinstance(plot_type, str):
            raise ValueError(&#34;plot_type must be str/string&#34;)

        fig = None
        if plot_type == &#34;loss&#34;:
            plt.plot(self.history.history[&#34;loss&#34;])
            if &#34;val_loss&#34; in self.history.history:
                plt.plot(self.history.history[&#34;val_loss&#34;])
                legend_items = [&#34;train&#34;, &#34;validation&#34;]
            else:
                legend_items = [&#34;train&#34;]
            plt.title(&#34;Model Loss&#34;)
            plt.ylabel(&#34;loss&#34;)
            plt.xlabel(&#34;epoch&#34;)
            plt.legend(legend_items, loc=&#34;upper left&#34;)
        elif plot_type == &#34;lr&#34;:
            if &#34;lr&#34; not in self.history.history:
                raise ValueError(
                    &#34;no lr in history: are you sure you used autofit or fit_onecycle to train?&#34;
                )
            plt.plot(self.history.history[&#34;lr&#34;])
            plt.title(&#34;LR Schedule&#34;)
            plt.ylabel(&#34;lr&#34;)
            plt.xlabel(&#34;iterations&#34;)
        elif plot_type == &#34;momentum&#34;:
            if &#34;momentum&#34; not in self.history.history:
                raise ValueError(
                    &#34;no momentum history: are you sure you used autofit or fit_onecycle to train?&#34;
                )
            plt.plot(self.history.history[&#34;momentum&#34;])
            plt.title(&#34;Momentum Schedule&#34;)
            plt.ylabel(&#34;momentum&#34;)
            plt.xlabel(&#34;iterations&#34;)
        else:
            if plot_type not in self.history.history:
                raise ValueError(
                    f&#34;no {plot_type} in history: are you sure {plot_type} exists in history?&#34;
                )
            plt.plot(self.history.history[plot_type])

            val_key = f&#34;val_{plot_type}&#34;
            if val_key in self.history.history:
                plt.plot(self.history.history[val_key])
                legend_items = [&#34;train&#34;, &#34;validation&#34;]
            else:
                warnings.warn(
                    f&#34;Validation value for {plot_type} wasn&#39;t found in history&#34;
                )
                legend_items = [&#34;train&#34;]

            plt.title(f&#34;History of {plot_type}&#34;)
            plt.ylabel(plot_type)
            plt.xlabel(&#34;epoch&#34;)
            plt.legend(legend_items, loc=&#34;upper left&#34;)
        fig = plt.gcf()
        plt.show()
        if return_fig:
            return fig
        return

    def print_layers(self, show_wd=False):
        &#34;&#34;&#34;
        ```
        prints the layers of the model along with indices
        ```
        &#34;&#34;&#34;
        if show_wd:
            warnings.warn(
                &#34;set_weight_decay now uses AdamWeightDecay instead of kernel_regularizers.&#34;
            )
        for i, layer in enumerate(self.model.layers):
            if show_wd and hasattr(layer, &#34;kernel_regularizer&#34;):
                reg = layer.kernel_regularizer
                if hasattr(reg, &#34;l2&#34;):
                    wd = reg.l2
                elif hasattr(reg, &#34;l1&#34;):
                    wd = reg.l1
                else:
                    wd = None
                print(&#34;%s (trainable=%s, wd=%s) : %s&#34; % (i, layer.trainable, wd, layer))
            else:
                print(&#34;%s (trainable=%s) : %s&#34; % (i, layer.trainable, layer))
        return

    def layer_output(self, layer_id, example_id=0, use_val=False):
        # should implemented in subclass
        raise NotImplementedError

    def set_lr(self, lr):
        K.set_value(self.model.optimizer.lr, lr)
        return

    def _check_cycles(self, n_cycles, cycle_len, cycle_mult):
        if type(n_cycles) != type(1) or n_cycles &lt; 1:
            raise ValueError(&#34;n_cycles must be &gt;= 1&#34;)
        if type(cycle_mult) != type(1) or cycle_mult &lt; 1:
            raise ValueError(&#34;cycle_mult must by &gt;= 1&#34;)
        if cycle_len is not None:
            if type(cycle_len) != type(1) or cycle_len &lt; 1:
                raise ValueError(&#34;cycle_len must either be None or &gt;= 1&#34;)

        # calculate number of epochs
        if cycle_len is None:
            epochs = n_cycles
        else:
            epochs = 0
            tmp_cycle_len = cycle_len
            for i in range(n_cycles):
                epochs += tmp_cycle_len
                tmp_cycle_len *= cycle_mult
        return epochs

    def _cb_sgdr(
        self, max_lr, steps_per_epoch, cycle_len, cycle_mult, lr_decay=1.0, callbacks=[]
    ):
        if callbacks and &#34;SGDRScheduler&#34; in [type(cb).__name__ for cb in callbacks]:
            return callbacks
        # configuration
        min_lr = 1e-9
        if max_lr &lt;= min_lr:
            min_lr = max_lr / 10

        #  use learning_rate schedule
        if cycle_len is not None:
            if not isinstance(callbacks, list):
                callbacks = []
            from .lroptimize.sgdr import SGDRScheduler

            schedule = SGDRScheduler(
                min_lr=min_lr,
                max_lr=max_lr,
                steps_per_epoch=steps_per_epoch,
                lr_decay=lr_decay,
                cycle_length=cycle_len,
                mult_factor=cycle_mult,
            )
            callbacks.append(schedule)
        if not callbacks:
            callbacks = None
        return callbacks

    def _cb_checkpoint(self, folder, callbacks=[]):
        if callbacks and &#34;ModelCheckpoint&#34; in [type(cb).__name__ for cb in callbacks]:
            return callbacks
        if folder is not None:
            os.makedirs(folder, exist_ok=True)
            if not isinstance(callbacks, list):
                callbacks = []
            # filepath=os.path.join(folder, &#34;weights-{epoch:02d}-{val_loss:.2f}.hdf5&#34;)
            filepath = os.path.join(folder, &#34;weights-{epoch:02d}.hdf5&#34;)
            callbacks.append(
                keras.callbacks.ModelCheckpoint(
                    filepath, save_best_only=False, save_weights_only=True
                )
            )
        if not callbacks:
            callbacks = None
        return callbacks

    def _cb_earlystopping(self, early_stopping, callbacks=[]):
        if callbacks and &#34;EarlyStopping&#34; in [type(cb).__name__ for cb in callbacks]:
            return callbacks
        if early_stopping:
            if not isinstance(callbacks, list):
                callbacks = []
            # if StrictVersion(keras.__version__) &gt;= StrictVersion(&#39;2.2.3&#39;):
            try:
                callbacks.append(
                    keras.callbacks.EarlyStopping(
                        monitor=&#34;val_loss&#34;,
                        min_delta=0,
                        patience=early_stopping,
                        restore_best_weights=True,
                        verbose=0,
                        mode=&#34;auto&#34;,
                    )
                )
            except TypeError:
                warnings.warn(
                    &#34;&#34;&#34;
                              The early_stopping=True argument relies on EarlyStopping.restore_best_weights,
                              which is only supported on Keras 2.2.3 or greater.
                              For now, we are falling back to EarlyStopping.restore_best_weights=False.
                              Please use checkpoint_folder option in fit() to restore best weights.&#34;&#34;&#34;
                )
                callbacks.append(
                    keras.callbacks.EarlyStopping(
                        monitor=&#34;val_loss&#34;,
                        min_delta=0,
                        patience=early_stopping,
                        verbose=0,
                        mode=&#34;auto&#34;,
                    )
                )

        if not callbacks:
            callbacks = None
        return callbacks

    def _prepare(self, data, train=True):
        &#34;&#34;&#34;
        ```
        Subclasses can override this method if data
        needs to be specially-prepared prior to invoking fit methods
        Args:
          data:  dataset
          train(bool):  If True, prepare for training. Otherwise, prepare for evaluation.
        ```
        &#34;&#34;&#34;
        if data is None:
            return None

        if hasattr(data, &#34;to_tfdataset&#34;):
            return data.to_tfdataset(train=train)
        else:
            return data

    @abstractmethod
    def fit(self, lr, n_cycles, cycle_len=None, cycle_mult=1, batch_size=U.DEFAULT_BS):
        pass

    def fit_onecycle(
        self,
        lr,
        epochs,
        checkpoint_folder=None,
        cycle_momentum=True,
        max_momentum=0.95,
        min_momentum=0.85,
        class_weight=None,
        callbacks=[],
        steps_per_epoch=None,
        verbose=1,
    ):
        &#34;&#34;&#34;
        ```
        Train model using a version of Leslie Smith&#39;s 1cycle policy.
        This method can be used with any optimizer. Thus,
        cyclical momentum is not currently implemented.

        Args:
            lr (float): (maximum) learning rate.
                       It is recommended that you estimate lr yourself by
                       running lr_finder (and lr_plot) and visually inspect plot
                       for dramatic loss drop.
            epochs (int): Number of epochs.  Number of epochs
            checkpoint_folder (string): Folder path in which to save the model weights
                                        for each epoch.
                                        File name will be of the form:
                                        weights-{epoch:02d}-{val_loss:.2f}.hdf5
            cycle_momentum (bool):    If True and optimizer is Adam, Nadam, or Adamax, momentum of
                                      optimzer will be cycled between 0.95 and 0.85 as described in
                                      https://arxiv.org/abs/1803.09820.
                                      Only takes effect if Adam, Nadam, or Adamax optimizer is used.
            max_momentum(float): Maximum momentum to use if cycle_momentum=True
            min_momentum(float): minimum momentum to use if cycle_momentum=True
            class_weight (dict):       Optional dictionary mapping class indices (integers) to a weight (float)
            callbacks (list): list of Callback instances to employ during training
            steps_per_epoch(int):    Steps per epoch. If None, then, math.ceil(num_samples/batch_size) is used.
                                     Ignored unless training dataset is generator.
            verbose (bool):  verbose mode
        ```
        &#34;&#34;&#34;
        if not self._is_adamlike() and cycle_momentum:
            warnings.warn(
                &#34;cyclical momentum has been disabled because &#34;
                + &#39;optimizer is not &#34;Adam-like&#34; with beta_1 param&#39;
            )
            cycle_momentum = False

        num_samples = U.nsamples_from_data(self.train_data)
        if steps_per_epoch is None:
            steps_per_epoch = math.ceil(num_samples / self.batch_size)

        # setup callbacks for learning rates and early stopping
        if not callbacks:
            kcallbacks = []
        else:
            kcallbacks = callbacks[:]
        if cycle_momentum:
            max_momentum = max_momentum
            min_momentum = min_momentum
        else:
            max_momentum = None
            min_momentum = None

        from .lroptimize.triangular import CyclicLR

        clr = CyclicLR(
            base_lr=lr / 10,
            max_lr=lr,
            step_size=math.ceil((steps_per_epoch * epochs) / 2),
            reduce_on_plateau=0,
            max_momentum=max_momentum,
            min_momentum=min_momentum,
            verbose=verbose,
        )
        kcallbacks.append(clr)

        # start training
        policy = &#34;onecycle&#34;
        U.vprint(&#34;\n&#34;, verbose=verbose)
        U.vprint(
            &#34;begin training using %s policy with max lr of %s...&#34; % (policy, lr),
            verbose=verbose,
        )
        hist = self.fit(
            lr,
            epochs,
            early_stopping=None,
            checkpoint_folder=checkpoint_folder,
            verbose=verbose,
            class_weight=class_weight,
            callbacks=kcallbacks,
            steps_per_epoch=steps_per_epoch,
        )
        hist.history[&#34;lr&#34;] = clr.history[&#34;lr&#34;]
        hist.history[&#34;iterations&#34;] = clr.history[&#34;iterations&#34;]
        if cycle_momentum:
            hist.history[&#34;momentum&#34;] = clr.history[&#34;momentum&#34;]
        self.history = hist
        return hist

    def autofit(
        self,
        lr,
        epochs=None,
        early_stopping=None,
        reduce_on_plateau=None,
        reduce_factor=2,
        cycle_momentum=True,
        max_momentum=0.95,
        min_momentum=0.85,
        monitor=&#34;val_loss&#34;,
        checkpoint_folder=None,
        class_weight=None,
        callbacks=[],
        steps_per_epoch=None,
        verbose=1,
    ):
        &#34;&#34;&#34;
        ```
        Automatically train model using a default learning rate schedule shown to work well
        in practice.  By default, this method currently employs a triangular learning
        rate policy (https://arxiv.org/abs/1506.01186).
        During each epoch, this learning rate policy varies the learning rate from lr/10 to lr
        and then back to a low learning rate that is near-zero.
        If epochs is None, then early_stopping and reduce_on_plateau are atomatically
        set to 5 and 2, respectively.

        Args:
            lr (float): optional initial learning rate.  If missing,
                       lr will be estimated automatically.
                       It is recommended that you estimate lr yourself by
                       running lr_finder (and lr_plot) and visually inspect plot
                       for dramatic loss drop.
            epochs (int): Number of epochs.  If None, training will continue until
                          validation loss no longer improves after 5 epochs.
            early_stopping (int):     If not None, training will automatically stop after this many
                                      epochs of no improvement in validation loss.
                                      Upon completion, model will be loaded with weights from epoch
                                      with lowest validation loss.
                                      NOTE: If reduce_on_plateau is also enabled, then
                                      early_stopping must be greater than reduce_on_plateau.
                                      Example: early_stopping=6, reduce_on_plateau=3.
            reduce_on_plateau (int):  If not None, will lower learning rate when
                                      when validation loss fails to improve after
                                      the specified number of epochs.
                                      NOTE: If early_stopping is enabled, then
                                      reduce_on_plateu must be less than early_stopping.
                                      Example: early_stopping=6, reduce_on_plateau=3.
            reduce_factor (int):      Learning reate is reduced by this factor on plateau.
                                      Only takes effect if reduce_on_plateau &gt; 0.
            cycle_momentum (bool):    If True and optimizer is Adam, Nadam, or Adamax, momentum of
                                      optimzer will be cycled between 0.95 and 0.85 as described in
                                      https://arxiv.org/abs/1803.09820.
                                      Only takes effect if Adam, Nadam, or Adamax optimizer is used.
            max_momentum(float):  maximum momentum to use when cycle_momentum=True
            min_momentum(float): minimum momentum to use when cycle_momentum=True
            checkpoint_folder (string): Folder path in which to save the model weights
                                        for each epoch.
                                        File name will be of the form:
                                        weights-{epoch:02d}-{val_loss:.2f}.hdf5
            monitor (str):              what metric to monitor for early_stopping
                                        and reduce_on_plateau. Defaults to &#39;val_loss&#39;.
                                        Only used if early_stopping or reduce_on_plateau
                                        is enabled.
            class_weight (dict):       Optional dictionary mapping class indices (integers) to a weight (float)
            callbacks (list): list of Callback instances to employ during training
            steps_per_epoch(int):    Steps per epoch. If None, then, math.ceil(num_samples/batch_size) is used.
                                     Ignored unless training dataset is generator.
            verbose (bool):  verbose mode
        ```
        &#34;&#34;&#34;
        # check optimizer
        if not self._is_adamlike() and cycle_momentum:
            warnings.warn(
                &#34;cyclical momentum has been disabled because &#34;
                + &#39;optimizer is not &#34;Adam-like&#34; with beta_1 param&#39;
            )
            cycle_momentum = False

        # setup learning rate policy
        num_samples = U.nsamples_from_data(self.train_data)
        if steps_per_epoch is None:
            steps_per_epoch = math.ceil(num_samples / self.batch_size)
        step_size = math.ceil(steps_per_epoch / 2)

        # handle missing epochs
        if epochs is None:
            epochs = 1024
            if not early_stopping:
                early_stopping = U.DEFAULT_ES
                U.vprint(
                    &#34;early_stopping automatically enabled at patience=%s&#34;
                    % (U.DEFAULT_ES),
                    verbose=verbose,
                )
            if not reduce_on_plateau:
                reduce_on_plateau = U.DEFAULT_ROP
                U.vprint(
                    &#34;reduce_on_plateau automatically enabled at patience=%s&#34;
                    % (U.DEFAULT_ROP),
                    verbose=verbose,
                )
        if (
            reduce_on_plateau
            and early_stopping
            and (reduce_on_plateau &gt; early_stopping)
        ):
            warnings.warn(
                &#34;reduce_on_plateau=%s and is greater than &#34; % (reduce_on_plateau)
                + &#34;early_stopping=%s.  &#34; % (early_stopping)
                + &#34;Either reduce reduce_on_plateau or set early_stopping &#34;
                + &#34;to be higher.&#34;
            )

        # check monitor
        if reduce_on_plateau is not None or early_stopping is not None:
            if monitor.startswith(&#34;val_&#34;) and self.val_data is None:
                raise ValueError(
                    &#34;monitor is %s but no val_data was supplied.\nChange monitor or supply val_data to get_learner function.&#34;
                    % monitor
                )
            if monitor != &#34;val_loss&#34; and monitor not in self._monitor_metrics:
                raise ValueError(
                    &#34;monitor must be one of {%s}&#34; % (self._monitor_metrics)
                )

        # setup callbacks for learning rates and early stopping
        if not callbacks:
            kcallbacks = []
        else:
            kcallbacks = callbacks[:]
        if cycle_momentum:
            max_momentum = max_momentum
            min_momentum = min_momentum
        else:
            max_momentum = None
            min_momentum = None

        from .lroptimize.triangular import CyclicLR

        clr = CyclicLR(
            base_lr=lr / 10,
            max_lr=lr,
            step_size=step_size,
            verbose=verbose,
            monitor=monitor,
            reduce_on_plateau=reduce_on_plateau,
            reduce_factor=reduce_factor,
            max_momentum=max_momentum,
            min_momentum=min_momentum,
        )
        kcallbacks.append(clr)
        if early_stopping:
            kcallbacks.append(
                keras.callbacks.EarlyStopping(
                    monitor=monitor,
                    min_delta=0,
                    patience=early_stopping,
                    restore_best_weights=True,
                    verbose=1,
                    mode=&#34;auto&#34;,
                )
            )

        # start training
        U.vprint(&#34;\n&#34;, verbose=verbose)
        policy = &#34;triangular learning rate&#34;
        U.vprint(
            &#34;begin training using %s policy with max lr of %s...&#34; % (policy, lr),
            verbose=verbose,
        )
        hist = self.fit(
            lr,
            epochs,
            early_stopping=early_stopping,
            checkpoint_folder=checkpoint_folder,
            verbose=verbose,
            class_weight=class_weight,
            callbacks=kcallbacks,
            steps_per_epoch=steps_per_epoch,
        )
        hist.history[&#34;lr&#34;] = clr.history[&#34;lr&#34;]
        hist.history[&#34;iterations&#34;] = clr.history[&#34;iterations&#34;]
        if cycle_momentum:
            hist.history[&#34;momentum&#34;] = clr.history[&#34;momentum&#34;]
        self.history = hist
        return hist

    def ground_truth(self, val_data=None):
        if val_data is not None:
            val = val_data
        else:
            val = self.val_data
        if not val:
            raise Exception(&#34;val_data must be supplied to get_learner or ground_truth&#34;)
        return U.y_from_data(val)

    def predict(self, val_data=None):
        &#34;&#34;&#34;
        ```
        Makes predictions on validation set
        ```
        &#34;&#34;&#34;
        if val_data is not None:
            val = val_data
        else:
            val = self.val_data
        if val is None:
            raise Exception(&#34;val_data must be supplied to get_learner or predict&#34;)
        if U.is_iter(val):
            if hasattr(val, &#34;reset&#34;):
                val.reset()
            steps = np.ceil(U.nsamples_from_data(val) / val.batch_size)
            # *_generator methods are deprecated from TF 2.1.0
            # result = self.model.predict_generator(self._prepare(val, train=False),
            # steps=steps)
            result = self.model.predict(self._prepare(val, train=False), steps=steps)
            return result
        else:
            return self.model.predict(val[0], batch_size=self.eval_batch_size)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ktrain.core.ArrayLearner" href="#ktrain.core.ArrayLearner">ArrayLearner</a></li>
<li><a title="ktrain.core.GenLearner" href="#ktrain.core.GenLearner">GenLearner</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ktrain.core.Learner.autofit"><code class="name flex">
<span>def <span class="ident">autofit</span></span>(<span>self, lr, epochs=None, early_stopping=None, reduce_on_plateau=None, reduce_factor=2, cycle_momentum=True, max_momentum=0.95, min_momentum=0.85, monitor='val_loss', checkpoint_folder=None, class_weight=None, callbacks=[], steps_per_epoch=None, verbose=1)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>Automatically train model using a default learning rate schedule shown to work well
in practice.  By default, this method currently employs a triangular learning
rate policy (https://arxiv.org/abs/1506.01186).
During each epoch, this learning rate policy varies the learning rate from lr/10 to lr
and then back to a low learning rate that is near-zero.
If epochs is None, then early_stopping and reduce_on_plateau are atomatically
set to 5 and 2, respectively.

Args:
    lr (float): optional initial learning rate.  If missing,
               lr will be estimated automatically.
               It is recommended that you estimate lr yourself by
               running lr_finder (and lr_plot) and visually inspect plot
               for dramatic loss drop.
    epochs (int): Number of epochs.  If None, training will continue until
                  validation loss no longer improves after 5 epochs.
    early_stopping (int):     If not None, training will automatically stop after this many
                              epochs of no improvement in validation loss.
                              Upon completion, model will be loaded with weights from epoch
                              with lowest validation loss.
                              NOTE: If reduce_on_plateau is also enabled, then
                              early_stopping must be greater than reduce_on_plateau.
                              Example: early_stopping=6, reduce_on_plateau=3.
    reduce_on_plateau (int):  If not None, will lower learning rate when
                              when validation loss fails to improve after
                              the specified number of epochs.
                              NOTE: If early_stopping is enabled, then
                              reduce_on_plateu must be less than early_stopping.
                              Example: early_stopping=6, reduce_on_plateau=3.
    reduce_factor (int):      Learning reate is reduced by this factor on plateau.
                              Only takes effect if reduce_on_plateau &gt; 0.
    cycle_momentum (bool):    If True and optimizer is Adam, Nadam, or Adamax, momentum of
                              optimzer will be cycled between 0.95 and 0.85 as described in
                              https://arxiv.org/abs/1803.09820.
                              Only takes effect if Adam, Nadam, or Adamax optimizer is used.
    max_momentum(float):  maximum momentum to use when cycle_momentum=True
    min_momentum(float): minimum momentum to use when cycle_momentum=True
    checkpoint_folder (string): Folder path in which to save the model weights
                                for each epoch.
                                File name will be of the form:
                                weights-{epoch:02d}-{val_loss:.2f}.hdf5
    monitor (str):              what metric to monitor for early_stopping
                                and reduce_on_plateau. Defaults to 'val_loss'.
                                Only used if early_stopping or reduce_on_plateau
                                is enabled.
    class_weight (dict):       Optional dictionary mapping class indices (integers) to a weight (float)
    callbacks (list): list of Callback instances to employ during training
    steps_per_epoch(int):    Steps per epoch. If None, then, math.ceil(num_samples/batch_size) is used.
                             Ignored unless training dataset is generator.
    verbose (bool):  verbose mode
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def autofit(
    self,
    lr,
    epochs=None,
    early_stopping=None,
    reduce_on_plateau=None,
    reduce_factor=2,
    cycle_momentum=True,
    max_momentum=0.95,
    min_momentum=0.85,
    monitor=&#34;val_loss&#34;,
    checkpoint_folder=None,
    class_weight=None,
    callbacks=[],
    steps_per_epoch=None,
    verbose=1,
):
    &#34;&#34;&#34;
    ```
    Automatically train model using a default learning rate schedule shown to work well
    in practice.  By default, this method currently employs a triangular learning
    rate policy (https://arxiv.org/abs/1506.01186).
    During each epoch, this learning rate policy varies the learning rate from lr/10 to lr
    and then back to a low learning rate that is near-zero.
    If epochs is None, then early_stopping and reduce_on_plateau are atomatically
    set to 5 and 2, respectively.

    Args:
        lr (float): optional initial learning rate.  If missing,
                   lr will be estimated automatically.
                   It is recommended that you estimate lr yourself by
                   running lr_finder (and lr_plot) and visually inspect plot
                   for dramatic loss drop.
        epochs (int): Number of epochs.  If None, training will continue until
                      validation loss no longer improves after 5 epochs.
        early_stopping (int):     If not None, training will automatically stop after this many
                                  epochs of no improvement in validation loss.
                                  Upon completion, model will be loaded with weights from epoch
                                  with lowest validation loss.
                                  NOTE: If reduce_on_plateau is also enabled, then
                                  early_stopping must be greater than reduce_on_plateau.
                                  Example: early_stopping=6, reduce_on_plateau=3.
        reduce_on_plateau (int):  If not None, will lower learning rate when
                                  when validation loss fails to improve after
                                  the specified number of epochs.
                                  NOTE: If early_stopping is enabled, then
                                  reduce_on_plateu must be less than early_stopping.
                                  Example: early_stopping=6, reduce_on_plateau=3.
        reduce_factor (int):      Learning reate is reduced by this factor on plateau.
                                  Only takes effect if reduce_on_plateau &gt; 0.
        cycle_momentum (bool):    If True and optimizer is Adam, Nadam, or Adamax, momentum of
                                  optimzer will be cycled between 0.95 and 0.85 as described in
                                  https://arxiv.org/abs/1803.09820.
                                  Only takes effect if Adam, Nadam, or Adamax optimizer is used.
        max_momentum(float):  maximum momentum to use when cycle_momentum=True
        min_momentum(float): minimum momentum to use when cycle_momentum=True
        checkpoint_folder (string): Folder path in which to save the model weights
                                    for each epoch.
                                    File name will be of the form:
                                    weights-{epoch:02d}-{val_loss:.2f}.hdf5
        monitor (str):              what metric to monitor for early_stopping
                                    and reduce_on_plateau. Defaults to &#39;val_loss&#39;.
                                    Only used if early_stopping or reduce_on_plateau
                                    is enabled.
        class_weight (dict):       Optional dictionary mapping class indices (integers) to a weight (float)
        callbacks (list): list of Callback instances to employ during training
        steps_per_epoch(int):    Steps per epoch. If None, then, math.ceil(num_samples/batch_size) is used.
                                 Ignored unless training dataset is generator.
        verbose (bool):  verbose mode
    ```
    &#34;&#34;&#34;
    # check optimizer
    if not self._is_adamlike() and cycle_momentum:
        warnings.warn(
            &#34;cyclical momentum has been disabled because &#34;
            + &#39;optimizer is not &#34;Adam-like&#34; with beta_1 param&#39;
        )
        cycle_momentum = False

    # setup learning rate policy
    num_samples = U.nsamples_from_data(self.train_data)
    if steps_per_epoch is None:
        steps_per_epoch = math.ceil(num_samples / self.batch_size)
    step_size = math.ceil(steps_per_epoch / 2)

    # handle missing epochs
    if epochs is None:
        epochs = 1024
        if not early_stopping:
            early_stopping = U.DEFAULT_ES
            U.vprint(
                &#34;early_stopping automatically enabled at patience=%s&#34;
                % (U.DEFAULT_ES),
                verbose=verbose,
            )
        if not reduce_on_plateau:
            reduce_on_plateau = U.DEFAULT_ROP
            U.vprint(
                &#34;reduce_on_plateau automatically enabled at patience=%s&#34;
                % (U.DEFAULT_ROP),
                verbose=verbose,
            )
    if (
        reduce_on_plateau
        and early_stopping
        and (reduce_on_plateau &gt; early_stopping)
    ):
        warnings.warn(
            &#34;reduce_on_plateau=%s and is greater than &#34; % (reduce_on_plateau)
            + &#34;early_stopping=%s.  &#34; % (early_stopping)
            + &#34;Either reduce reduce_on_plateau or set early_stopping &#34;
            + &#34;to be higher.&#34;
        )

    # check monitor
    if reduce_on_plateau is not None or early_stopping is not None:
        if monitor.startswith(&#34;val_&#34;) and self.val_data is None:
            raise ValueError(
                &#34;monitor is %s but no val_data was supplied.\nChange monitor or supply val_data to get_learner function.&#34;
                % monitor
            )
        if monitor != &#34;val_loss&#34; and monitor not in self._monitor_metrics:
            raise ValueError(
                &#34;monitor must be one of {%s}&#34; % (self._monitor_metrics)
            )

    # setup callbacks for learning rates and early stopping
    if not callbacks:
        kcallbacks = []
    else:
        kcallbacks = callbacks[:]
    if cycle_momentum:
        max_momentum = max_momentum
        min_momentum = min_momentum
    else:
        max_momentum = None
        min_momentum = None

    from .lroptimize.triangular import CyclicLR

    clr = CyclicLR(
        base_lr=lr / 10,
        max_lr=lr,
        step_size=step_size,
        verbose=verbose,
        monitor=monitor,
        reduce_on_plateau=reduce_on_plateau,
        reduce_factor=reduce_factor,
        max_momentum=max_momentum,
        min_momentum=min_momentum,
    )
    kcallbacks.append(clr)
    if early_stopping:
        kcallbacks.append(
            keras.callbacks.EarlyStopping(
                monitor=monitor,
                min_delta=0,
                patience=early_stopping,
                restore_best_weights=True,
                verbose=1,
                mode=&#34;auto&#34;,
            )
        )

    # start training
    U.vprint(&#34;\n&#34;, verbose=verbose)
    policy = &#34;triangular learning rate&#34;
    U.vprint(
        &#34;begin training using %s policy with max lr of %s...&#34; % (policy, lr),
        verbose=verbose,
    )
    hist = self.fit(
        lr,
        epochs,
        early_stopping=early_stopping,
        checkpoint_folder=checkpoint_folder,
        verbose=verbose,
        class_weight=class_weight,
        callbacks=kcallbacks,
        steps_per_epoch=steps_per_epoch,
    )
    hist.history[&#34;lr&#34;] = clr.history[&#34;lr&#34;]
    hist.history[&#34;iterations&#34;] = clr.history[&#34;iterations&#34;]
    if cycle_momentum:
        hist.history[&#34;momentum&#34;] = clr.history[&#34;momentum&#34;]
    self.history = hist
    return hist</code></pre>
</details>
</dd>
<dt id="ktrain.core.Learner.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>self, test_data=None, print_report=True, save_path='ktrain_classification_report.csv', class_names=[])</span>
</code></dt>
<dd>
<div class="desc"><pre><code>alias for self.validate().
Returns confusion matrix and optionally prints
a classification report.
This is currently only supported for binary and multiclass
classification, not multilabel classification.

By default, this uses val_data, as supplied to ktrain.get_learner().
Other validation or test data can be optionally be supplied as argument via &lt;test_data&gt; argument.
Supply class_names to include labels instead of intenger class integer values in classification report.
Args:
  test_data(Dataset|np.ndarray): test or validation data.  If None, self.val_data is used.
  print_report(bool): If True, classification report will be printed. If False, report will be saved to CSV
                      at save_path. Not applicable to regression models.
                      Not applicable to regression models.
  save_path(str): Classification report will be saved to this file path/name if print_report=False
                  Not applicable to regression models.
  class_names(list): list of class names to be used in classification report instead of
                     class integer IDs.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate(
    self,
    test_data=None,
    print_report=True,
    save_path=&#34;ktrain_classification_report.csv&#34;,
    class_names=[],
):
    &#34;&#34;&#34;
    ```
    alias for self.validate().
    Returns confusion matrix and optionally prints
    a classification report.
    This is currently only supported for binary and multiclass
    classification, not multilabel classification.

    By default, this uses val_data, as supplied to ktrain.get_learner().
    Other validation or test data can be optionally be supplied as argument via &lt;test_data&gt; argument.
    Supply class_names to include labels instead of intenger class integer values in classification report.
    Args:
      test_data(Dataset|np.ndarray): test or validation data.  If None, self.val_data is used.
      print_report(bool): If True, classification report will be printed. If False, report will be saved to CSV
                          at save_path. Not applicable to regression models.
                          Not applicable to regression models.
      save_path(str): Classification report will be saved to this file path/name if print_report=False
                      Not applicable to regression models.
      class_names(list): list of class names to be used in classification report instead of
                         class integer IDs.
    ```
    &#34;&#34;&#34;
    return self.validate(
        val_data=test_data,
        print_report=print_report,
        save_path=save_path,
        class_names=class_names,
    )</code></pre>
</details>
</dd>
<dt id="ktrain.core.Learner.fit"><code class="name flex">
<span>def <span class="ident">fit</span></span>(<span>self, lr, n_cycles, cycle_len=None, cycle_mult=1, batch_size=32)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def fit(self, lr, n_cycles, cycle_len=None, cycle_mult=1, batch_size=U.DEFAULT_BS):
    pass</code></pre>
</details>
</dd>
<dt id="ktrain.core.Learner.fit_onecycle"><code class="name flex">
<span>def <span class="ident">fit_onecycle</span></span>(<span>self, lr, epochs, checkpoint_folder=None, cycle_momentum=True, max_momentum=0.95, min_momentum=0.85, class_weight=None, callbacks=[], steps_per_epoch=None, verbose=1)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>Train model using a version of Leslie Smith's 1cycle policy.
This method can be used with any optimizer. Thus,
cyclical momentum is not currently implemented.

Args:
    lr (float): (maximum) learning rate.
               It is recommended that you estimate lr yourself by
               running lr_finder (and lr_plot) and visually inspect plot
               for dramatic loss drop.
    epochs (int): Number of epochs.  Number of epochs
    checkpoint_folder (string): Folder path in which to save the model weights
                                for each epoch.
                                File name will be of the form:
                                weights-{epoch:02d}-{val_loss:.2f}.hdf5
    cycle_momentum (bool):    If True and optimizer is Adam, Nadam, or Adamax, momentum of
                              optimzer will be cycled between 0.95 and 0.85 as described in
                              https://arxiv.org/abs/1803.09820.
                              Only takes effect if Adam, Nadam, or Adamax optimizer is used.
    max_momentum(float): Maximum momentum to use if cycle_momentum=True
    min_momentum(float): minimum momentum to use if cycle_momentum=True
    class_weight (dict):       Optional dictionary mapping class indices (integers) to a weight (float)
    callbacks (list): list of Callback instances to employ during training
    steps_per_epoch(int):    Steps per epoch. If None, then, math.ceil(num_samples/batch_size) is used.
                             Ignored unless training dataset is generator.
    verbose (bool):  verbose mode
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit_onecycle(
    self,
    lr,
    epochs,
    checkpoint_folder=None,
    cycle_momentum=True,
    max_momentum=0.95,
    min_momentum=0.85,
    class_weight=None,
    callbacks=[],
    steps_per_epoch=None,
    verbose=1,
):
    &#34;&#34;&#34;
    ```
    Train model using a version of Leslie Smith&#39;s 1cycle policy.
    This method can be used with any optimizer. Thus,
    cyclical momentum is not currently implemented.

    Args:
        lr (float): (maximum) learning rate.
                   It is recommended that you estimate lr yourself by
                   running lr_finder (and lr_plot) and visually inspect plot
                   for dramatic loss drop.
        epochs (int): Number of epochs.  Number of epochs
        checkpoint_folder (string): Folder path in which to save the model weights
                                    for each epoch.
                                    File name will be of the form:
                                    weights-{epoch:02d}-{val_loss:.2f}.hdf5
        cycle_momentum (bool):    If True and optimizer is Adam, Nadam, or Adamax, momentum of
                                  optimzer will be cycled between 0.95 and 0.85 as described in
                                  https://arxiv.org/abs/1803.09820.
                                  Only takes effect if Adam, Nadam, or Adamax optimizer is used.
        max_momentum(float): Maximum momentum to use if cycle_momentum=True
        min_momentum(float): minimum momentum to use if cycle_momentum=True
        class_weight (dict):       Optional dictionary mapping class indices (integers) to a weight (float)
        callbacks (list): list of Callback instances to employ during training
        steps_per_epoch(int):    Steps per epoch. If None, then, math.ceil(num_samples/batch_size) is used.
                                 Ignored unless training dataset is generator.
        verbose (bool):  verbose mode
    ```
    &#34;&#34;&#34;
    if not self._is_adamlike() and cycle_momentum:
        warnings.warn(
            &#34;cyclical momentum has been disabled because &#34;
            + &#39;optimizer is not &#34;Adam-like&#34; with beta_1 param&#39;
        )
        cycle_momentum = False

    num_samples = U.nsamples_from_data(self.train_data)
    if steps_per_epoch is None:
        steps_per_epoch = math.ceil(num_samples / self.batch_size)

    # setup callbacks for learning rates and early stopping
    if not callbacks:
        kcallbacks = []
    else:
        kcallbacks = callbacks[:]
    if cycle_momentum:
        max_momentum = max_momentum
        min_momentum = min_momentum
    else:
        max_momentum = None
        min_momentum = None

    from .lroptimize.triangular import CyclicLR

    clr = CyclicLR(
        base_lr=lr / 10,
        max_lr=lr,
        step_size=math.ceil((steps_per_epoch * epochs) / 2),
        reduce_on_plateau=0,
        max_momentum=max_momentum,
        min_momentum=min_momentum,
        verbose=verbose,
    )
    kcallbacks.append(clr)

    # start training
    policy = &#34;onecycle&#34;
    U.vprint(&#34;\n&#34;, verbose=verbose)
    U.vprint(
        &#34;begin training using %s policy with max lr of %s...&#34; % (policy, lr),
        verbose=verbose,
    )
    hist = self.fit(
        lr,
        epochs,
        early_stopping=None,
        checkpoint_folder=checkpoint_folder,
        verbose=verbose,
        class_weight=class_weight,
        callbacks=kcallbacks,
        steps_per_epoch=steps_per_epoch,
    )
    hist.history[&#34;lr&#34;] = clr.history[&#34;lr&#34;]
    hist.history[&#34;iterations&#34;] = clr.history[&#34;iterations&#34;]
    if cycle_momentum:
        hist.history[&#34;momentum&#34;] = clr.history[&#34;momentum&#34;]
    self.history = hist
    return hist</code></pre>
</details>
</dd>
<dt id="ktrain.core.Learner.freeze"><code class="name flex">
<span>def <span class="ident">freeze</span></span>(<span>self, freeze_range=None)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>If freeze_range is None, makes all layers trainable=False except last Dense layer.
If freeze_range is given, freezes the first &lt;freeze_range&gt; layers and
unfrezes all remaining layers.
NOTE:      Freeze method does not currently work with
           multi-GPU models.  If you are using the load_imagemodel method,
           please use the freeze_layers argument of load_imagemodel
           to freeze layers.
Args:
    freeze_range(int): number of layers to freeze
Returns:
    None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def freeze(self, freeze_range=None):
    &#34;&#34;&#34;
    ```
    If freeze_range is None, makes all layers trainable=False except last Dense layer.
    If freeze_range is given, freezes the first &lt;freeze_range&gt; layers and
    unfrezes all remaining layers.
    NOTE:      Freeze method does not currently work with
               multi-GPU models.  If you are using the load_imagemodel method,
               please use the freeze_layers argument of load_imagemodel
               to freeze layers.
    Args:
        freeze_range(int): number of layers to freeze
    Returns:
        None
    ```
    &#34;&#34;&#34;

    if freeze_range is None:
        # freeze everything except last Dense layer
        # first find last dense layer
        dense_id = None
        for i, layer in reversed(list(enumerate(self.model.layers))):
            if isinstance(layer, keras.layers.Dense):
                dense_id = i
                break
        if dense_id is None:
            raise Exception(&#34;cannot find Dense layer in this model&#34;)
        for i, layer in enumerate(self.model.layers):
            if i &lt; dense_id:
                layer.trainable = False
            else:
                layer.trainable = True
    else:
        # freeze all layers up to and including layer_id
        if type(freeze_range) != type(1) or freeze_range &lt; 1:
            raise ValueError(&#34;freeze_range must be integer &gt; 0&#34;)
        for i, layer in enumerate(self.model.layers):
            if i &lt; freeze_range:
                layer.trainable = False
            else:
                layer.trainable = True
    self._recompile()
    return</code></pre>
</details>
</dd>
<dt id="ktrain.core.Learner.get_weight_decay"><code class="name flex">
<span>def <span class="ident">get_weight_decay</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>Get current weight decay rate
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_weight_decay(self):
    &#34;&#34;&#34;
    ```
    Get current weight decay rate
    ```
    &#34;&#34;&#34;
    if type(self.model.optimizer).__name__ == &#34;AdamWeightDecay&#34;:
        return self.model.optimizer.weight_decay_rate
    else:
        return None</code></pre>
</details>
</dd>
<dt id="ktrain.core.Learner.ground_truth"><code class="name flex">
<span>def <span class="ident">ground_truth</span></span>(<span>self, val_data=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ground_truth(self, val_data=None):
    if val_data is not None:
        val = val_data
    else:
        val = self.val_data
    if not val:
        raise Exception(&#34;val_data must be supplied to get_learner or ground_truth&#34;)
    return U.y_from_data(val)</code></pre>
</details>
</dd>
<dt id="ktrain.core.Learner.layer_output"><code class="name flex">
<span>def <span class="ident">layer_output</span></span>(<span>self, layer_id, example_id=0, use_val=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def layer_output(self, layer_id, example_id=0, use_val=False):
    # should implemented in subclass
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="ktrain.core.Learner.load_model"><code class="name flex">
<span>def <span class="ident">load_model</span></span>(<span>self, fpath, custom_objects=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>loads model from folder.
Note: **kwargs included for backwards compatibility only, as TransformerTextClassLearner.load_model was removed in v0.18.0.
Args:
  fpath(str): path to folder containing model
  custom_objects(dict): custom objects required to load model.
                        For models included with ktrain, this is populated automatically
                        and can be disregarded.

</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_model(self, fpath, custom_objects=None, **kwargs):
    &#34;&#34;&#34;
    ```
    loads model from folder.
    Note: **kwargs included for backwards compatibility only, as TransformerTextClassLearner.load_model was removed in v0.18.0.
    Args:
      fpath(str): path to folder containing model
      custom_objects(dict): custom objects required to load model.
                            For models included with ktrain, this is populated automatically
                            and can be disregarded.

    ```
    &#34;&#34;&#34;
    self.model = _load_model(
        fpath, train_data=self.train_data, custom_objects=custom_objects
    )
    return</code></pre>
</details>
</dd>
<dt id="ktrain.core.Learner.lr_estimate"><code class="name flex">
<span>def <span class="ident">lr_estimate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>Return numerical estimates of lr using two different methods:
  1. lr associated with minum numerical gradient (None if gradient computation fails)
  2. lr associated with minimum loss divided by 10
  3. lr associated with longest valley
Since none of these methods are fool-proof and can
potentially return bad estimates, it is recommended that you
examine the plot generated by lr_plot to estimate the learning rate.
Returns:
  tuple: tuple of the form (float, float)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lr_estimate(self):
    &#34;&#34;&#34;
    ```
    Return numerical estimates of lr using two different methods:
      1. lr associated with minum numerical gradient (None if gradient computation fails)
      2. lr associated with minimum loss divided by 10
      3. lr associated with longest valley
    Since none of these methods are fool-proof and can
    potentially return bad estimates, it is recommended that you
    examine the plot generated by lr_plot to estimate the learning rate.
    Returns:
      tuple: tuple of the form (float, float)
    ```
    &#34;&#34;&#34;
    if self.lr_finder is None or not self.lr_finder.find_called():
        raise ValueError(&#34;Please call lr_find first.&#34;)
    return self.lr_finder.estimate_lr()</code></pre>
</details>
</dd>
<dt id="ktrain.core.Learner.lr_find"><code class="name flex">
<span>def <span class="ident">lr_find</span></span>(<span>self, start_lr=1e-07, lr_mult=1.01, max_epochs=None, class_weight=None, stop_factor=4, show_plot=False, suggest=False, restore_weights_only=False, verbose=1)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>Plots loss as learning rate is increased.  Highest learning rate
corresponding to a still falling loss should be chosen.

If you find the LR finder is running for more epochs than you'd prefer,
you can set max_epochs (e.g., max_epochs=5) to estimate LR with a
smaller sample size.

If lr_mult is supplied and max_epochs is None, LR will increase until loss diverges.
Reasonable values of lr_mult are between 1.01 and 1.05.

If max_epochs is supplied, lr_mult argument is ignored and computed automatically.

Reference: https://arxiv.org/abs/1506.01186

Args:
    start_lr (float): smallest lr to start simulation
    lr_mult (float): multiplication factor to increase LR.
                     Ignored if max_epochs is supplied.
    max_epochs (int):  maximum number of epochs to simulate.
                       lr_mult is ignored if max_epoch is supplied.
                       Default is None. Set max_epochs to an integer
                       (e.g., 5) if lr_find is taking too long
                       and running for more epochs than desired.
    class_weight(dict): class_weight parameter passed to model.fit
                        for imbalanced datasets.
    stop_factor(int): factor used to determine threhsold that loss
                      must exceed to stop training simulation.
                      Increase this if loss is erratic and lr_find
                      exits too early.
    show_plot (bool):  If True, automatically invoke lr_plot
    restore_weights_only(bool): If True, when training simulation is complete,
                                the model weights only are restored, but not
                                the original optimizer weights.
                                In at least a few cases, this seems to improve performance
                                when actual training begins. Further investigation is needed,
                                so it is False by default.
    verbose (bool): specifies how much output to print
Returns:
    None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lr_find(
    self,
    start_lr=1e-7,
    lr_mult=1.01,
    max_epochs=None,
    class_weight=None,
    stop_factor=4,
    show_plot=False,
    suggest=False,
    restore_weights_only=False,
    verbose=1,
):
    &#34;&#34;&#34;
    ```
    Plots loss as learning rate is increased.  Highest learning rate
    corresponding to a still falling loss should be chosen.

    If you find the LR finder is running for more epochs than you&#39;d prefer,
    you can set max_epochs (e.g., max_epochs=5) to estimate LR with a
    smaller sample size.

    If lr_mult is supplied and max_epochs is None, LR will increase until loss diverges.
    Reasonable values of lr_mult are between 1.01 and 1.05.

    If max_epochs is supplied, lr_mult argument is ignored and computed automatically.

    Reference: https://arxiv.org/abs/1506.01186

    Args:
        start_lr (float): smallest lr to start simulation
        lr_mult (float): multiplication factor to increase LR.
                         Ignored if max_epochs is supplied.
        max_epochs (int):  maximum number of epochs to simulate.
                           lr_mult is ignored if max_epoch is supplied.
                           Default is None. Set max_epochs to an integer
                           (e.g., 5) if lr_find is taking too long
                           and running for more epochs than desired.
        class_weight(dict): class_weight parameter passed to model.fit
                            for imbalanced datasets.
        stop_factor(int): factor used to determine threhsold that loss
                          must exceed to stop training simulation.
                          Increase this if loss is erratic and lr_find
                          exits too early.
        show_plot (bool):  If True, automatically invoke lr_plot
        restore_weights_only(bool): If True, when training simulation is complete,
                                    the model weights only are restored, but not
                                    the original optimizer weights.
                                    In at least a few cases, this seems to improve performance
                                    when actual training begins. Further investigation is needed,
                                    so it is False by default.
        verbose (bool): specifies how much output to print
    Returns:
        None
    ```
    &#34;&#34;&#34;
    # dep_fix: bug in TF 2.2 and 2.3
    if version.parse(tf.__version__) &gt; version.parse(&#34;2.1&#34;) and version.parse(
        tf.__version__
    ) &lt; version.parse(&#34;2.4&#34;):
        if max_epochs is None:
            raise ValueError(
                &#34;Due to a bug in TensorFlow 2.2 and 2.3, the max_epochs argument is temporarily required. &#34;
                + &#34;Please re-run with max_epochs (e.g., max_epochs=5). \n&#34;
                + &#34;More info: https://github.com/tensorflow/tensorflow/issues/41174#issuecomment-656330268&#34;
            )

    U.vprint(
        &#34;simulating training for different learning rates... this may take a few moments...&#34;,
        verbose=verbose,
    )
    # save current weights and temporarily restore original weights
    # dep_fix: temporarily use save_model instead of save_weights as default due to https://github.com/tensorflow/tensorflow/issues/41116
    _weights_only = True
    if restore_weights_only:
        new_file, weightfile = tempfile.mkstemp()
        self.model.save_weights(weightfile)
    else:
        temp_folder = tempfile.mkdtemp()
        self.save_model(temp_folder)

    # compute steps_per_epoch
    num_samples = U.nsamples_from_data(self.train_data)
    bs = (
        self.train_data.batch_size
        if hasattr(self.train_data, &#34;batch_size&#34;)
        else self.batch_size
    )
    if U.is_iter(self.train_data):
        use_gen = True
        steps_per_epoch = num_samples // bs
    else:
        use_gen = False
        steps_per_epoch = np.ceil(num_samples / bs)

    # check steps_per_epoch
    if steps_per_epoch &lt;= 64 and max_epochs is None:
        warnings.warn(
            &#34;max_epochs is being set to 5 since steps per epoch is small. &#34;
            + &#34;If you wish to estimate LR using more epochs, set max_epochs manually.&#34;
        )
        max_epochs = 5

    try:
        # track and plot learning rates
        self.lr_finder = LRFinder(self.model, stop_factor=stop_factor)
        self.lr_finder.find(
            self._prepare(self.train_data),
            steps_per_epoch,
            use_gen=use_gen,
            start_lr=start_lr,
            lr_mult=lr_mult,
            max_epochs=max_epochs,
            class_weight=class_weight,
            workers=self.workers,
            use_multiprocessing=self.use_multiprocessing,
            batch_size=self.batch_size,
            verbose=verbose,
        )
    except KeyboardInterrupt:
        # re-load current weights
        # self.model.load_weights(weightfile)
        self.load_model(temp_folder)
        return

    # re-load current weights
    # dep_fix: temporarily use load_model instead of load_weights as default due to https://github.com/tensorflow/tensorflow/issues/41116
    if restore_weights_only:
        self.model.load_weights(weightfile)
    else:
        self.load_model(temp_folder)

    # instructions to invoker
    U.vprint(&#34;\n&#34;, verbose=verbose)
    U.vprint(&#34;done.&#34;, verbose=verbose)
    if show_plot:
        U.vprint(
            &#34;Visually inspect loss plot and select learning rate associated with falling loss&#34;,
            verbose=verbose,
        )
        self.lr_plot(suggest=suggest)
    else:
        U.vprint(
            &#34;Please invoke the Learner.lr_plot() method to visually inspect &#34;
            &#34;the loss plot to help identify the maximal learning rate &#34;
            &#34;associated with falling loss.&#34;,
            verbose=verbose,
        )
    return</code></pre>
</details>
</dd>
<dt id="ktrain.core.Learner.lr_plot"><code class="name flex">
<span>def <span class="ident">lr_plot</span></span>(<span>self, n_skip_beginning=10, n_skip_end=5, suggest=False, return_fig=False)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>Plots the loss vs. learning rate to help identify
The maximal learning rate associated with a falling loss.
The nskip_beginning and n_skip_end arguments can be used
to &quot;zoom in&quot; on the plot.
Args:
    n_skip_beginning(int): number of batches to skip on the left.
    n_skip_end(int):  number of batches to skip on the right.
    suggest(bool): will highlight numerical estimate
                   of best lr if True - methods adapted from fastai
    return_fig(bool): If True, return matplotlib.figure.Figure
Returns:
  matplotlib.figure.Figure if return_fig else None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lr_plot(
    self, n_skip_beginning=10, n_skip_end=5, suggest=False, return_fig=False
):
    &#34;&#34;&#34;
    ```
    Plots the loss vs. learning rate to help identify
    The maximal learning rate associated with a falling loss.
    The nskip_beginning and n_skip_end arguments can be used
    to &#34;zoom in&#34; on the plot.
    Args:
        n_skip_beginning(int): number of batches to skip on the left.
        n_skip_end(int):  number of batches to skip on the right.
        suggest(bool): will highlight numerical estimate
                       of best lr if True - methods adapted from fastai
        return_fig(bool): If True, return matplotlib.figure.Figure
    Returns:
      matplotlib.figure.Figure if return_fig else None
    ```
    &#34;&#34;&#34;
    # dep_fix: bug in TF 2.2 and 2.3
    if version.parse(tf.__version__) &gt; version.parse(&#34;2.1&#34;) and version.parse(
        tf.__version__
    ) &lt; version.parse(&#34;2.4&#34;):
        if n_skip_end == 5:
            n_skip_end = 10

    if self.lr_finder is None or not self.lr_finder.find_called():
        raise ValueError(&#34;Please call lr_find first.&#34;)
    return self.lr_finder.plot_loss(
        n_skip_beginning=n_skip_beginning,
        n_skip_end=n_skip_end,
        suggest=suggest,
        return_fig=return_fig,
    )</code></pre>
</details>
</dd>
<dt id="ktrain.core.Learner.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, plot_type='loss', return_fig=False)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>plots training history
Args:
  plot_type (str):  A valid value in tf.keras History.  Either a built-in value  {'loss', 'lr', 'momentum'} or
                    other values previously specified by user.  For instance, if 'mae' and/or 'mse' is previously specified as metrics
                    when creating model, then these values can also be specified.
  return_fig(bool):  If True, return matplotlib.figure.Figure
Return:
  matplotlib.figure.Figure if return_fig else None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, plot_type=&#34;loss&#34;, return_fig=False):
    &#34;&#34;&#34;
    ```
    plots training history
    Args:
      plot_type (str):  A valid value in tf.keras History.  Either a built-in value  {&#39;loss&#39;, &#39;lr&#39;, &#39;momentum&#39;} or
                        other values previously specified by user.  For instance, if &#39;mae&#39; and/or &#39;mse&#39; is previously specified as metrics
                        when creating model, then these values can also be specified.
      return_fig(bool):  If True, return matplotlib.figure.Figure
    Return:
      matplotlib.figure.Figure if return_fig else None
    ```
    &#34;&#34;&#34;
    if self.history is None:
        raise Exception(&#34;No training history - did you train the model yet?&#34;)
    if not isinstance(plot_type, str):
        raise ValueError(&#34;plot_type must be str/string&#34;)

    fig = None
    if plot_type == &#34;loss&#34;:
        plt.plot(self.history.history[&#34;loss&#34;])
        if &#34;val_loss&#34; in self.history.history:
            plt.plot(self.history.history[&#34;val_loss&#34;])
            legend_items = [&#34;train&#34;, &#34;validation&#34;]
        else:
            legend_items = [&#34;train&#34;]
        plt.title(&#34;Model Loss&#34;)
        plt.ylabel(&#34;loss&#34;)
        plt.xlabel(&#34;epoch&#34;)
        plt.legend(legend_items, loc=&#34;upper left&#34;)
    elif plot_type == &#34;lr&#34;:
        if &#34;lr&#34; not in self.history.history:
            raise ValueError(
                &#34;no lr in history: are you sure you used autofit or fit_onecycle to train?&#34;
            )
        plt.plot(self.history.history[&#34;lr&#34;])
        plt.title(&#34;LR Schedule&#34;)
        plt.ylabel(&#34;lr&#34;)
        plt.xlabel(&#34;iterations&#34;)
    elif plot_type == &#34;momentum&#34;:
        if &#34;momentum&#34; not in self.history.history:
            raise ValueError(
                &#34;no momentum history: are you sure you used autofit or fit_onecycle to train?&#34;
            )
        plt.plot(self.history.history[&#34;momentum&#34;])
        plt.title(&#34;Momentum Schedule&#34;)
        plt.ylabel(&#34;momentum&#34;)
        plt.xlabel(&#34;iterations&#34;)
    else:
        if plot_type not in self.history.history:
            raise ValueError(
                f&#34;no {plot_type} in history: are you sure {plot_type} exists in history?&#34;
            )
        plt.plot(self.history.history[plot_type])

        val_key = f&#34;val_{plot_type}&#34;
        if val_key in self.history.history:
            plt.plot(self.history.history[val_key])
            legend_items = [&#34;train&#34;, &#34;validation&#34;]
        else:
            warnings.warn(
                f&#34;Validation value for {plot_type} wasn&#39;t found in history&#34;
            )
            legend_items = [&#34;train&#34;]

        plt.title(f&#34;History of {plot_type}&#34;)
        plt.ylabel(plot_type)
        plt.xlabel(&#34;epoch&#34;)
        plt.legend(legend_items, loc=&#34;upper left&#34;)
    fig = plt.gcf()
    plt.show()
    if return_fig:
        return fig
    return</code></pre>
</details>
</dd>
<dt id="ktrain.core.Learner.predict"><code class="name flex">
<span>def <span class="ident">predict</span></span>(<span>self, val_data=None)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>Makes predictions on validation set
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predict(self, val_data=None):
    &#34;&#34;&#34;
    ```
    Makes predictions on validation set
    ```
    &#34;&#34;&#34;
    if val_data is not None:
        val = val_data
    else:
        val = self.val_data
    if val is None:
        raise Exception(&#34;val_data must be supplied to get_learner or predict&#34;)
    if U.is_iter(val):
        if hasattr(val, &#34;reset&#34;):
            val.reset()
        steps = np.ceil(U.nsamples_from_data(val) / val.batch_size)
        # *_generator methods are deprecated from TF 2.1.0
        # result = self.model.predict_generator(self._prepare(val, train=False),
        # steps=steps)
        result = self.model.predict(self._prepare(val, train=False), steps=steps)
        return result
    else:
        return self.model.predict(val[0], batch_size=self.eval_batch_size)</code></pre>
</details>
</dd>
<dt id="ktrain.core.Learner.print_layers"><code class="name flex">
<span>def <span class="ident">print_layers</span></span>(<span>self, show_wd=False)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>prints the layers of the model along with indices
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_layers(self, show_wd=False):
    &#34;&#34;&#34;
    ```
    prints the layers of the model along with indices
    ```
    &#34;&#34;&#34;
    if show_wd:
        warnings.warn(
            &#34;set_weight_decay now uses AdamWeightDecay instead of kernel_regularizers.&#34;
        )
    for i, layer in enumerate(self.model.layers):
        if show_wd and hasattr(layer, &#34;kernel_regularizer&#34;):
            reg = layer.kernel_regularizer
            if hasattr(reg, &#34;l2&#34;):
                wd = reg.l2
            elif hasattr(reg, &#34;l1&#34;):
                wd = reg.l1
            else:
                wd = None
            print(&#34;%s (trainable=%s, wd=%s) : %s&#34; % (i, layer.trainable, wd, layer))
        else:
            print(&#34;%s (trainable=%s) : %s&#34; % (i, layer.trainable, layer))
    return</code></pre>
</details>
</dd>
<dt id="ktrain.core.Learner.reset_weights"><code class="name flex">
<span>def <span class="ident">reset_weights</span></span>(<span>self, verbose=1)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>Re-initializes network with original weights
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_weights(self, verbose=1):
    &#34;&#34;&#34;
    ```
    Re-initializes network with original weights
    ```
    &#34;&#34;&#34;

    if os.path.isfile(self._original_weights):
        self.model.load_weights(self._original_weights)
        self.history = None
        U.vprint(&#34;Model weights have been reset.&#34;, verbose=verbose)
    else:
        warnings.warn(
            &#34;Weights have not been reset because the original weights file &#34;
            + &#34;(%s) no longer exists.&#34; % (self._original_weights)
        )
    return</code></pre>
</details>
</dd>
<dt id="ktrain.core.Learner.save_model"><code class="name flex">
<span>def <span class="ident">save_model</span></span>(<span>self, fpath)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>a wrapper to model.save
Args:
  fpath(str): path to folder in which to save model
Returns:
  None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_model(self, fpath):
    &#34;&#34;&#34;
    ```
    a wrapper to model.save
    Args:
      fpath(str): path to folder in which to save model
    Returns:
      None
    ```
    &#34;&#34;&#34;
    self._make_model_folder(fpath)
    self.model.save(os.path.join(fpath, U.MODEL_NAME), save_format=&#34;h5&#34;)
    return</code></pre>
</details>
</dd>
<dt id="ktrain.core.Learner.set_lr"><code class="name flex">
<span>def <span class="ident">set_lr</span></span>(<span>self, lr)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_lr(self, lr):
    K.set_value(self.model.optimizer.lr, lr)
    return</code></pre>
</details>
</dd>
<dt id="ktrain.core.Learner.set_model"><code class="name flex">
<span>def <span class="ident">set_model</span></span>(<span>self, model)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>replace model in this Learner instance
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_model(self, model):
    &#34;&#34;&#34;
    ```
    replace model in this Learner instance
    ```
    &#34;&#34;&#34;
    if not isinstance(model, keras.Model):
        raise ValueError(&#34;model must be of instance keras.Model&#34;)
    self.model = model
    self.history = None
    return</code></pre>
</details>
</dd>
<dt id="ktrain.core.Learner.set_weight_decay"><code class="name flex">
<span>def <span class="ident">set_weight_decay</span></span>(<span>self, wd=0.01)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>Sets global weight decay via AdamWeightDecay optimizer
Args:
  wd(float): weight decay
Returns:
  None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_weight_decay(self, wd=U.DEFAULT_WD):
    &#34;&#34;&#34;
    ```
    Sets global weight decay via AdamWeightDecay optimizer
    Args:
      wd(float): weight decay
    Returns:
      None
    ```
    &#34;&#34;&#34;
    self._recompile(wd=wd)
    return</code></pre>
</details>
</dd>
<dt id="ktrain.core.Learner.top_losses"><code class="name flex">
<span>def <span class="ident">top_losses</span></span>(<span>self, n=4, val_data=None, preproc=None)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>Computes losses on validation set sorted by examples with top losses
Args:
  n(int or tuple): a range to select in form of int or tuple
                  e.g., n=8 is treated as n=(0,8)
  val_data:  optional val_data to use instead of self.val_data
  preproc (Preprocessor): A TextPreprocessor or ImagePreprocessor.
                          For some data like text data, a preprocessor
                          is required to undo the pre-processing
                           to correctly view raw data.
Returns:
    list of n tuples where first element is either
    filepath or id of validation example and second element
    is loss.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def top_losses(self, n=4, val_data=None, preproc=None):
    &#34;&#34;&#34;
    ```
    Computes losses on validation set sorted by examples with top losses
    Args:
      n(int or tuple): a range to select in form of int or tuple
                      e.g., n=8 is treated as n=(0,8)
      val_data:  optional val_data to use instead of self.val_data
      preproc (Preprocessor): A TextPreprocessor or ImagePreprocessor.
                              For some data like text data, a preprocessor
                              is required to undo the pre-processing
                               to correctly view raw data.
    Returns:
        list of n tuples where first element is either
        filepath or id of validation example and second element
        is loss.
    ```
    &#34;&#34;&#34;

    # check validation data and arguments
    if val_data is not None:
        val = val_data
    else:
        val = self.val_data
    if val is None:
        raise Exception(&#34;val_data must be supplied to get_learner or top_losses&#34;)
    if type(n) == type(42):
        n = (0, n)

    # multilabel = True if U.is_multilabel(val) else False
    classification, multilabel = U.is_classifier(self.model)

    # get predicictions and ground truth
    y_pred = self.predict(val_data=val)
    y_true = self.ground_truth(val_data=val)
    y_true = y_true.astype(&#34;float32&#34;)

    # adjust y_true for regression problems
    if (
        not classification
        and len(y_true.shape) == 1
        and (len(y_pred.shape) == 2 and y_pred.shape[1] == 1)
    ):
        y_true = np.expand_dims(y_true, -1)

    # compute loss
    # this doesn&#39;t work in tf.keras 1.14
    # losses = self.model.loss_functions[0](tf.convert_to_tensor(y_true), tf.convert_to_tensor(y_pred))
    # if U.is_tf_keras():
    # L = self.model.loss_functions[0].fn
    # else:
    # L = self.model.loss_functions[0]
    L = U.loss_fn_from_model(self.model)
    losses = L(tf.convert_to_tensor(y_true), tf.convert_to_tensor(y_pred))
    if DISABLE_V2_BEHAVIOR:
        losses = tf.Session().run(losses)
    else:
        losses = losses.numpy()

    class_names = [] if preproc is None else preproc.get_classes()
    if preproc is None:
        class_fcn = lambda x: &#34;%s&#34; % (x)
    else:
        class_fcn = lambda x: class_names[x]

    # regression output modifications
    if not classification:
        if len(y_pred.shape) == 2 and y_pred.shape[1] == 1:
            y_pred = np.squeeze(y_pred)
            y_pred = np.around(y_pred, 2)
        if len(y_true.shape) == 2 and y_true.shape[1] == 1:
            y_true = np.squeeze(y_true)
            y_true = np.around(y_true, 2)

    # sort by loss and prune correct classifications, if necessary
    if classification and not multilabel:
        y_pred = np.squeeze(y_pred)
        y_true = np.squeeze(y_true)
        if len(y_pred.shape) == 1:
            y_p = np.where(y_pred &gt; 0.5, 1, 0)
            y_t = np.where(y_true &gt; 0.5, 1, 0)
        else:
            y_p = np.argmax(y_pred, axis=1)
            y_t = np.argmax(y_true, axis=1)
        tups = [
            (i, x, class_fcn(y_t[i]), class_fcn(y_p[i]))
            for i, x in enumerate(losses)
            if y_p[i] != y_t[i]
        ]
    else:
        tups = [
            (i, x, y_true[i], np.around(y_pred[i], 2)) for i, x in enumerate(losses)
        ]
    tups.sort(key=operator.itemgetter(1), reverse=True)

    # prune by given range
    tups = tups[n[0] : n[1]] if n is not None else tups
    return tups</code></pre>
</details>
</dd>
<dt id="ktrain.core.Learner.unfreeze"><code class="name flex">
<span>def <span class="ident">unfreeze</span></span>(<span>self, exclude_range=None)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>Make every layer trainable except those in exclude_range.
unfreeze is simply a proxy method to freeze.
NOTE:      Unfreeze method does not currently work with
           multi-GPU models.  If you are using the load_imagemodel method,
           please use the freeze_layers argument of load_imagemodel
           to freeze layers.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unfreeze(self, exclude_range=None):
    &#34;&#34;&#34;
    ```
    Make every layer trainable except those in exclude_range.
    unfreeze is simply a proxy method to freeze.
    NOTE:      Unfreeze method does not currently work with
               multi-GPU models.  If you are using the load_imagemodel method,
               please use the freeze_layers argument of load_imagemodel
               to freeze layers.
    ```
    &#34;&#34;&#34;
    # make all layers trainable
    for i, layer in enumerate(self.model.layers):
        layer.trainable = True
    if exclude_range:
        for i, layer in enumerate(self.model.layers[:exclude_range]):
            layer.trainable = False
    self._recompile()
    return</code></pre>
</details>
</dd>
<dt id="ktrain.core.Learner.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self, val_data=None, print_report=True, save_path='ktrain_classification_report.csv', class_names=[])</span>
</code></dt>
<dd>
<div class="desc"><pre><code>Returns confusion matrix and optionally prints
a classification report.
This is currently only supported for binary and multiclass
classification, not multilabel classification.

By default, this uses val_data, as supplied to ktrain.get_learner().
Other validation or test data can be optionally be supplied as argument.
Supply class_names to include labels instead of intenger class integer values in classification report.
Args:
  val_data(Dataset|np.ndarray): validation data.  If None, self.val_data is used.
  print_report(bool): If True, classification report will be printed. If False, report will be saved to CSV
                      at save path. Not applicable to regression models.
  save_path(str): Classification report will be saved to this file path/name if print_report=False
  class_names(list): list of class names to be used in classification report instead of
                     class integer IDs.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(
    self,
    val_data=None,
    print_report=True,
    save_path=&#34;ktrain_classification_report.csv&#34;,
    class_names=[],
):
    &#34;&#34;&#34;
    ```
    Returns confusion matrix and optionally prints
    a classification report.
    This is currently only supported for binary and multiclass
    classification, not multilabel classification.

    By default, this uses val_data, as supplied to ktrain.get_learner().
    Other validation or test data can be optionally be supplied as argument.
    Supply class_names to include labels instead of intenger class integer values in classification report.
    Args:
      val_data(Dataset|np.ndarray): validation data.  If None, self.val_data is used.
      print_report(bool): If True, classification report will be printed. If False, report will be saved to CSV
                          at save path. Not applicable to regression models.
      save_path(str): Classification report will be saved to this file path/name if print_report=False
      class_names(list): list of class names to be used in classification report instead of
                         class integer IDs.
    ```
    &#34;&#34;&#34;
    if val_data is not None:
        val = val_data
    else:
        val = self.val_data

    classification, multilabel = U.is_classifier(self.model)
    if not classification:
        # warnings.warn(&#39;learner.validate is only for classification problems. &#39;
        #&#39;For regression, etc., use learner.predict and learner.ground_truth &#39;
        #&#39;to manually validate.&#39;)
        # return
        pass

    if U.is_multilabel(val) or multilabel:
        warnings.warn(&#34;multilabel confusion matrices not yet supported&#34;)
        return
    y_pred = self.predict(val_data=val)
    y_true = self.ground_truth(val_data=val)
    y_pred = np.squeeze(y_pred)
    y_true = np.squeeze(y_true)

    # regression evaluation
    if not classification:
        from sklearn.metrics import mean_absolute_error, mean_squared_error

        regout = []
        metrics = U.metrics_from_model(self.model)
        for m in metrics:
            if m in [&#34;mae&#34;, &#34;mean_absolute_error&#34;]:
                regout.append((m, mean_absolute_error(y_true, y_pred)))
            elif m in [&#34;mse&#34;, &#34;mean_squared_error&#34;]:
                regout.append((m, mean_squared_error(y_true, y_pred)))
        if not regout:
            warnings.warn(
                &#34;%s is not supported by validate/evaluate - falling back to MAE&#34;
            )
            regout.append((&#34;mae&#34;, mean_absolute_error(y_true, y_pred)))
        return regout

    if len(y_pred.shape) == 1:
        y_pred = np.where(y_pred &gt; 0.5, 1, 0)
        y_true = np.where(y_true &gt; 0.5, 1, 0)
    else:
        y_pred = np.argmax(y_pred, axis=1)
        y_true = np.argmax(y_true, axis=1)
    if print_report or save_path is not None:
        if class_names:
            try:
                class_names = [str(s) for s in class_names]
            except:
                pass
            report = classification_report(
                y_true,
                y_pred,
                target_names=class_names,
                output_dict=not print_report,
            )
        else:
            report = classification_report(
                y_true, y_pred, output_dict=not print_report
            )
        if print_report:
            print(report)
        else:
            df = pd.DataFrame(report).transpose()
            df.to_csv(save_path)
            print(&#34;classification report saved to: %s&#34; % (save_path))
        cm_func = confusion_matrix
    cm = confusion_matrix(y_true, y_pred)
    return cm</code></pre>
</details>
</dd>
<dt id="ktrain.core.Learner.view_top_losses"><code class="name flex">
<span>def <span class="ident">view_top_losses</span></span>(<span>self, n=4, preproc=None, val_data=None)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>View observations with top losses in validation set.
Musta be overridden by Learner subclasses.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def view_top_losses(self, n=4, preproc=None, val_data=None):
    &#34;&#34;&#34;
    ```
    View observations with top losses in validation set.
    Musta be overridden by Learner subclasses.
    ```
    &#34;&#34;&#34;
    raise NotImplementedError(
        &#34;view_top_losses must be overriden by Learner subclass&#34;
    )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ktrain" href="index.html">ktrain</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ktrain.core.get_predictor" href="#ktrain.core.get_predictor">get_predictor</a></code></li>
<li><code><a title="ktrain.core.load_predictor" href="#ktrain.core.load_predictor">load_predictor</a></code></li>
<li><code><a title="ktrain.core.release_gpu_memory" href="#ktrain.core.release_gpu_memory">release_gpu_memory</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ktrain.core.ArrayLearner" href="#ktrain.core.ArrayLearner">ArrayLearner</a></code></h4>
<ul class="">
<li><code><a title="ktrain.core.ArrayLearner.fit" href="#ktrain.core.ArrayLearner.fit">fit</a></code></li>
<li><code><a title="ktrain.core.ArrayLearner.layer_output" href="#ktrain.core.ArrayLearner.layer_output">layer_output</a></code></li>
<li><code><a title="ktrain.core.ArrayLearner.view_top_losses" href="#ktrain.core.ArrayLearner.view_top_losses">view_top_losses</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ktrain.core.GenLearner" href="#ktrain.core.GenLearner">GenLearner</a></code></h4>
<ul class="">
<li><code><a title="ktrain.core.GenLearner.fit" href="#ktrain.core.GenLearner.fit">fit</a></code></li>
<li><code><a title="ktrain.core.GenLearner.layer_output" href="#ktrain.core.GenLearner.layer_output">layer_output</a></code></li>
<li><code><a title="ktrain.core.GenLearner.view_top_losses" href="#ktrain.core.GenLearner.view_top_losses">view_top_losses</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ktrain.core.Learner" href="#ktrain.core.Learner">Learner</a></code></h4>
<ul class="two-column">
<li><code><a title="ktrain.core.Learner.autofit" href="#ktrain.core.Learner.autofit">autofit</a></code></li>
<li><code><a title="ktrain.core.Learner.evaluate" href="#ktrain.core.Learner.evaluate">evaluate</a></code></li>
<li><code><a title="ktrain.core.Learner.fit" href="#ktrain.core.Learner.fit">fit</a></code></li>
<li><code><a title="ktrain.core.Learner.fit_onecycle" href="#ktrain.core.Learner.fit_onecycle">fit_onecycle</a></code></li>
<li><code><a title="ktrain.core.Learner.freeze" href="#ktrain.core.Learner.freeze">freeze</a></code></li>
<li><code><a title="ktrain.core.Learner.get_weight_decay" href="#ktrain.core.Learner.get_weight_decay">get_weight_decay</a></code></li>
<li><code><a title="ktrain.core.Learner.ground_truth" href="#ktrain.core.Learner.ground_truth">ground_truth</a></code></li>
<li><code><a title="ktrain.core.Learner.layer_output" href="#ktrain.core.Learner.layer_output">layer_output</a></code></li>
<li><code><a title="ktrain.core.Learner.load_model" href="#ktrain.core.Learner.load_model">load_model</a></code></li>
<li><code><a title="ktrain.core.Learner.lr_estimate" href="#ktrain.core.Learner.lr_estimate">lr_estimate</a></code></li>
<li><code><a title="ktrain.core.Learner.lr_find" href="#ktrain.core.Learner.lr_find">lr_find</a></code></li>
<li><code><a title="ktrain.core.Learner.lr_plot" href="#ktrain.core.Learner.lr_plot">lr_plot</a></code></li>
<li><code><a title="ktrain.core.Learner.plot" href="#ktrain.core.Learner.plot">plot</a></code></li>
<li><code><a title="ktrain.core.Learner.predict" href="#ktrain.core.Learner.predict">predict</a></code></li>
<li><code><a title="ktrain.core.Learner.print_layers" href="#ktrain.core.Learner.print_layers">print_layers</a></code></li>
<li><code><a title="ktrain.core.Learner.reset_weights" href="#ktrain.core.Learner.reset_weights">reset_weights</a></code></li>
<li><code><a title="ktrain.core.Learner.save_model" href="#ktrain.core.Learner.save_model">save_model</a></code></li>
<li><code><a title="ktrain.core.Learner.set_lr" href="#ktrain.core.Learner.set_lr">set_lr</a></code></li>
<li><code><a title="ktrain.core.Learner.set_model" href="#ktrain.core.Learner.set_model">set_model</a></code></li>
<li><code><a title="ktrain.core.Learner.set_weight_decay" href="#ktrain.core.Learner.set_weight_decay">set_weight_decay</a></code></li>
<li><code><a title="ktrain.core.Learner.top_losses" href="#ktrain.core.Learner.top_losses">top_losses</a></code></li>
<li><code><a title="ktrain.core.Learner.unfreeze" href="#ktrain.core.Learner.unfreeze">unfreeze</a></code></li>
<li><code><a title="ktrain.core.Learner.validate" href="#ktrain.core.Learner.validate">validate</a></code></li>
<li><code><a title="ktrain.core.Learner.view_top_losses" href="#ktrain.core.Learner.view_top_losses">view_top_losses</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>