<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>ktrain.vision.data API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ktrain.vision.data</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from .. import utils as U
from ..imports import *
from .preprocessor import ImagePreprocessor


def show_image(img_path):
    &#34;&#34;&#34;
    ```
    Given file path to image, show it in Jupyter notebook
    ```
    &#34;&#34;&#34;
    if not os.path.isfile(img_path):
        raise ValueError(&#34;%s is not valid file&#34; % (img_path))
    img = plt.imread(img_path)
    out = plt.imshow(img)
    return out


def show_random_images(img_folder, n=4, rows=1):
    &#34;&#34;&#34;
    ```
    display random images from a img_folder
    ```
    &#34;&#34;&#34;
    fnames = []
    for ext in (&#34;*.gif&#34;, &#34;*.png&#34;, &#34;*.jpg&#34;):
        fnames.extend(glob.glob(os.path.join(img_folder, ext)))
    ims = []
    for i in range(n):
        img_path = random.choice(fnames)
        img = keras.preprocessing.image.load_img(img_path)
        x = keras.preprocessing.image.img_to_array(img)
        x = x / 255.0
        ims.append(x)
    U.plots(ims, rows=rows)
    return


def preview_data_aug(img_path, data_aug, rows=1, n=4):
    &#34;&#34;&#34;
    ```
    Preview data augmentation (ImageDatagenerator)
    on a supplied image.
    ```
    &#34;&#34;&#34;
    if type(img_path) != type(&#34;&#34;) or not os.path.isfile(img_path):
        raise ValueError(&#34;img_path must be valid file path to image&#34;)
    idg = copy.copy(data_aug)
    idg.featurewise_center = False
    idg.featurewise_std_normalization = False
    idg.samplewise_center = False
    idg.samplewise_std_normalization = False
    idg.rescale = None
    idg.zca_whitening = False
    idg.preprocessing_function = None

    img = keras.preprocessing.image.load_img(img_path)
    x = keras.preprocessing.image.img_to_array(img)
    x = x / 255.0
    x = x.reshape((1,) + x.shape)
    i = 0
    ims = []
    for batch in idg.flow(x, batch_size=1):
        ims.append(np.squeeze(batch))
        i += 1
        if i &gt;= n:
            break
    U.plots(ims, rows=rows)
    return


def preview_data_aug_OLD(img_path, data_aug, n=4):
    &#34;&#34;&#34;
    ```
    Preview data augmentation (ImageDatagenerator)
    on a supplied image.
    ```
    &#34;&#34;&#34;
    if type(img_path) != type(&#34;&#34;) or not os.path.isfile(img_path):
        raise ValueError(&#34;img_path must be valid file path to image&#34;)
    idg = copy.copy(data_aug)
    idg.featurewise_center = False
    idg.featurewise_std_normalization = False
    idg.samplewise_center = False
    idg.samplewise_std_normalization = False
    idg.rescale = None
    idg.zca_whitening = False
    idg.preprocessing_function = None

    img = keras.preprocessing.image.load_img(img_path)
    x = keras.preprocessing.image.img_to_array(img)
    x = x / 255.0
    x = x.reshape((1,) + x.shape)
    i = 0
    for batch in idg.flow(x, batch_size=1):
        plt.figure()
        plt.imshow(np.squeeze(batch))
        i += 1
        if i &gt;= n:
            break
    return


def get_data_aug(
    rotation_range=40,
    zoom_range=0.2,
    width_shift_range=0.2,
    height_shift_range=0.2,
    horizontal_flip=False,
    vertical_flip=False,
    featurewise_center=True,
    featurewise_std_normalization=True,
    samplewise_center=False,
    samplewise_std_normalization=False,
    rescale=None,
    **kwargs
):
    &#34;&#34;&#34;
    ```
    This function is simply a wrapper around ImageDataGenerator
    with some reasonable defaults for data augmentation.
    Returns the default image_data_generator to support
    data augmentation and data normalization.
    Parameters can be adjusted by caller.
    Note that the ktrain.vision.model.image_classifier
    function may adjust these as needed.
    ```
    &#34;&#34;&#34;

    data_aug = keras.preprocessing.image.ImageDataGenerator(
        rotation_range=rotation_range,
        zoom_range=zoom_range,
        width_shift_range=width_shift_range,
        height_shift_range=height_shift_range,
        horizontal_flip=horizontal_flip,
        vertical_flip=vertical_flip,
        featurewise_center=featurewise_center,
        featurewise_std_normalization=featurewise_std_normalization,
        samplewise_center=samplewise_center,
        samplewise_std_normalization=samplewise_std_normalization,
        rescale=rescale,
        **kwargs
    )
    return data_aug


def get_test_datagen(data_aug=None):
    if data_aug:
        featurewise_center = data_aug.featurewise_center
        featurewise_std_normalization = data_aug.featurewise_std_normalization
        samplewise_center = data_aug.samplewise_center
        samplewise_std_normalization = data_aug.samplewise_std_normalization
        rescale = data_aug.rescale
        zca_whitening = data_aug.zca_whitening
        test_datagen = keras.preprocessing.image.ImageDataGenerator(
            rescale=rescale,
            featurewise_center=featurewise_center,
            samplewise_center=samplewise_center,
            featurewise_std_normalization=featurewise_std_normalization,
            samplewise_std_normalization=samplewise_std_normalization,
            zca_whitening=zca_whitening,
        )
    else:
        test_datagen = keras.preprocessing.image.ImageDataGenerator()
    return test_datagen


def process_datagen(
    data_aug,
    train_array=None,
    train_directory=None,
    target_size=None,
    color_mode=&#34;rgb&#34;,
    flat_dir=False,
):
    # set generators for train and test
    if data_aug is not None:
        train_datagen = data_aug
        test_datagen = get_test_datagen(data_aug=data_aug)
    else:
        train_datagen = get_test_datagen()
        test_datagen = get_test_datagen()

    # compute statistics for normalization
    fit_datagens(
        train_datagen,
        test_datagen,
        train_array=train_array,
        train_directory=train_directory,
        target_size=target_size,
        color_mode=color_mode,
        flat_dir=flat_dir,
    )

    return (train_datagen, test_datagen)


def fit_datagens(
    train_datagen,
    test_datagen,
    train_array=None,
    train_directory=None,
    target_size=None,
    color_mode=&#34;rgb&#34;,
    flat_dir=False,
):
    &#34;&#34;&#34;
    ```
    computes stats of images for normalization
    ```
    &#34;&#34;&#34;
    if not datagen_needs_fit(train_datagen):
        return
    if bool(train_array is not None) == bool(train_directory):
        raise ValueError(&#34;only one of train_array or train_directory is required.&#34;)
    if train_array is not None:
        train_datagen.fit(train_array)
        test_datagen.fit(train_array)
    else:
        if target_size is None:
            raise ValueError(&#34;target_size is required when train_directory is supplied&#34;)
        fit_samples = sample_image_folder(
            train_directory, target_size, color_mode=color_mode, flat_dir=flat_dir
        )
        train_datagen.fit(fit_samples)
        test_datagen.fit(fit_samples)
    return


def datagen_needs_fit(datagen):
    if (
        datagen.featurewise_center
        or datagen.featurewise_std_normalization
        or datagen.zca_whitening
    ):
        return True
    else:
        return False


def sample_image_folder(train_directory, target_size, color_mode=&#34;rgb&#34;, flat_dir=False):

    # adjust train_directory
    classes = None
    if flat_dir and train_directory is not None:
        folder = train_directory
        if folder[-1] != os.sep:
            folder += os.sep
        parent = os.path.dirname(os.path.dirname(folder))
        folder_name = os.path.basename(os.path.dirname(folder))
        train_directory = parent
        classes = [folder_name]

    # sample images
    batch_size = 100
    img_gen = keras.preprocessing.image.ImageDataGenerator()
    batches = img_gen.flow_from_directory(
        directory=train_directory,
        classes=classes,
        target_size=target_size,
        batch_size=batch_size,
        color_mode=color_mode,
        shuffle=True,
    )
    the_shape = batches[0][0].shape
    sample_size = the_shape[0]
    if K.image_data_format() == &#34;channels_first&#34;:
        num_channels = the_shape[1]
    else:
        num_channels = the_shape[-1]
    imgs, labels = next(batches)
    return imgs


def detect_color_mode(train_directory, target_size=(32, 32)):
    try:
        fname = glob.glob(os.path.join(train_directory, &#34;**/*&#34;))[0]
        img = Image.open(fname).resize(target_size)
        num_channels = len(img.getbands())
        if num_channels == 3:
            return &#34;rgb&#34;
        elif num_channels == 1:
            return &#34;grayscale&#34;
        else:
            return &#34;rgby&#34;
    except:
        warnings.warn(&#34;could not detect color_mode from %s&#34; % (train_directory))
        return


def preprocess_csv(
    csv_in,
    csv_out,
    x_col=&#34;filename&#34;,
    y_col=None,
    sep=&#34;,&#34;,
    label_sep=&#34; &#34;,
    suffix=&#34;&#34;,
    split_by=None,
):
    &#34;&#34;&#34;
    ```
    Takes a CSV where the one column contains a file name and a column
    containing a string representations of the class(es) like here:
    image_name,tags
    01, sunny|hot
    02, cloudy|cold
    03, cloudy|hot

    .... and one-hot encodes the classes to produce a CSV as follows:
    image_name, cloudy, cold, hot, sunny
    01.jpg,0,0,1,1
    02.jpg,1,1,0,0
    03.jpg,1,0,1,0
    Args:
        csv_in (str):  filepath to input CSV file
        csv_out (str): filepath to output CSV file
        x_col (str):  name of column containing file names
        y_col (str): name of column containing the classes
        sep (str): field delimiter of entire file (e.g., comma fore CSV)
        label_sep (str): delimiter for column containing classes
        suffix (str): adds suffix to x_col values
        split_by(str): name of column. A separate CSV will be
                       created for each value in column. Useful
                       for splitting a CSV based on whether a column
                       contains &#39;train&#39; or &#39;valid&#39;.
    Return:
        list :  the list of clases (and csv_out will be new CSV file)
    ```
    &#34;&#34;&#34;
    if not y_col and not suffix:
        raise ValueError(&#34;one or both of y_col and suffix should be supplied&#34;)
    df = pd.read_csv(csv_in, sep=sep)
    f_csv_out = open(csv_out, &#34;w&#34;)
    writer = csv.writer(f_csv_out, delimiter=sep)
    if y_col:
        df[y_col] = df[y_col].apply(str)

    # write header
    if y_col:
        classes = set()
        for row in df.iterrows():
            data = row[1]
            tags = data[y_col].split(label_sep)
            classes.update(tags)
        classes = list(classes)
        classes.sort()
        writer.writerow([x_col] + classes)
    else:
        classes = df.columns[:-1]
        write.writerow(df.columns)

    # write rows
    for row in df.iterrows():
        data = row[1]
        data[x_col] = data[x_col] + suffix
        if y_col:
            out = list(data[[x_col]].values)
            tags = set(data[y_col].strip().split(label_sep))
            for c in classes:
                if c in tags:
                    out.append(1)
                else:
                    out.append(0)
        else:
            out = data
        writer.writerow(out)
    f_csv_out.close()
    return classes


def images_from_folder(
    datadir,
    target_size=(224, 224),
    classes=None,
    color_mode=&#34;rgb&#34;,
    train_test_names=[&#34;train&#34;, &#34;test&#34;],
    data_aug=None,
    verbose=1,
):

    &#34;&#34;&#34;
    ```
    Returns image generator (Iterator instance).
    Assumes output will be 2D one-hot-encoded labels for categorization.
    Note: This function preprocesses the input in preparation
          for a ResNet50 model.

    Args:
    datadir (string): path to training (or validation/test) dataset
        Assumes folder follows this structure:
        ├── datadir
        │   ├── train
        │   │   ├── class0       # folder containing documents of class 0
        │   │   ├── class1       # folder containing documents of class 1
        │   │   ├── class2       # folder containing documents of class 2
        │   │   └── classN       # folder containing documents of class N
        │   └── test
        │       ├── class0       # folder containing documents of class 0
        │       ├── class1       # folder containing documents of class 1
        │       ├── class2       # folder containing documents of class 2
        │       └── classN       # folder containing documents of class N

    target_size (tuple):  image dimensions
    classes (list):  optional list of class subdirectories (e.g., [&#39;cats&#39;,&#39;dogs&#39;])
    color_mode (string):  color mode
    train_test_names(list): names for train and test subfolders
    data_aug(ImageDataGenerator):  a keras.preprocessing.image.ImageDataGenerator
                                  for data augmentation
    verbose (bool):               verbosity

    Returns:
    batches: a tuple of two Iterators - one for train and one for test
    ```
    &#34;&#34;&#34;

    # train/test names
    train_str = train_test_names[0]
    test_str = train_test_names[1]
    train_dir = os.path.join(datadir, train_str)
    test_dir = os.path.join(datadir, test_str)

    # color mode warning
    if PIL_INSTALLED:
        inferred_color_mode = detect_color_mode(train_dir)
        if inferred_color_mode is not None and (inferred_color_mode != color_mode):
            U.vprint(
                &#34;color_mode detected (%s) different than color_mode selected (%s)&#34;
                % (inferred_color_mode, color_mode),
                verbose=verbose,
            )

    # get train and test data generators
    (train_datagen, test_datagen) = process_datagen(
        data_aug,
        train_directory=train_dir,
        target_size=target_size,
        color_mode=color_mode,
    )
    batches_tr = train_datagen.flow_from_directory(
        train_dir,
        target_size=target_size,
        classes=classes,
        class_mode=&#34;categorical&#34;,
        shuffle=True,
        interpolation=&#34;bicubic&#34;,
        color_mode=color_mode,
    )

    batches_te = test_datagen.flow_from_directory(
        test_dir,
        target_size=target_size,
        classes=classes,
        class_mode=&#34;categorical&#34;,
        shuffle=False,
        interpolation=&#34;bicubic&#34;,
        color_mode=color_mode,
    )

    # setup preprocessor
    class_tup = sorted(batches_tr.class_indices.items(), key=operator.itemgetter(1))
    preproc = ImagePreprocessor(
        test_datagen,
        [x[0] for x in class_tup],
        target_size=target_size,
        color_mode=color_mode,
    )
    return (batches_tr, batches_te, preproc)


def images_from_df(
    train_df,
    image_column,
    label_columns=[],
    directory=None,
    val_directory=None,
    suffix=&#34;&#34;,
    val_df=None,
    is_regression=False,
    target_size=(224, 224),
    color_mode=&#34;rgb&#34;,
    data_aug=None,
    val_pct=0.1,
    random_state=None,
):

    &#34;&#34;&#34;
    ```
    Returns image generator (Iterator instance).
    Assumes output will be 2D one-hot-encoded labels for categorization.
    Note: This function preprocesses the input in preparation
          for a ResNet50 model.

    Args:
    train_df (DataFrame):  pandas dataframe for training dataset
    image_column (string): name of column containing the filenames of images
                           If values in image_column do not have a file extension,
                           the extension should be supplied with suffix argument.
                           If values in image_column are not full file paths,
                           then the path to directory containing images should be supplied
                           as directory argument.

    label_columns(list or str): list or str representing the columns that store labels
                                Labels can be in any one of the following formats:
                                1. a single column string string (or integer) labels

                                   image_fname,label
                                   -----------------
                                   image01,cat
                                   image02,dog

                                2. multiple columns for one-hot-encoded labels
                                   image_fname,cat,dog
                                   image01,1,0
                                   image02,0,1

                                3. a single column of numeric values for image regression
                                   image_fname,age
                                   -----------------
                                   image01,68
                                   image02,18

    directory (string): path to directory containing images
                        not required if image_column contains full filepaths
    val_directory(strin): path to directory containing validation images.
                          only required if validation images are in different folder than train images
    suffix(str): will be appended to each entry in image_column
                 Used when the filenames in image_column do not contain file extensions.
                 The extension in suffx should include &#34;.&#34;.
    val_df (DataFrame): pandas dataframe for validation set

    is_regression(bool): If True, task is treated as regression.
                         Used when there is single column of numeric values and
                         numeric values should be treated as numeric targets as opposed to class labels
    target_size (tuple):  image dimensions
    color_mode (string):  color mode
    data_aug(ImageDataGenerator):  a keras.preprocessing.image.ImageDataGenerator
                                  for data augmentation
    val_pct(float):  proportion of training data to be used for validation
                     only used if val_filepath is None
    random_state(int): random seed for train/test split

    Returns:
    batches: a tuple of two Iterators - one for train and one for test
    ```
    &#34;&#34;&#34;

    # read in train and test data
    train_df = train_df.copy()
    if val_df is not None:
        val_df = val_df.copy()
    else:
        train_df, val_df = train_test_split(
            train_df, test_size=val_pct, random_state=random_state
        )

    # transform labels
    ytransdf = U.YTransformDataFrame(label_columns, is_regression=is_regression)
    train_df = ytransdf.apply_train(train_df)
    val_df = ytransdf.apply_test(val_df)
    class_names = ytransdf.get_classes()
    label_columns = ytransdf.get_label_columns(squeeze=True)

    # get train and test data generators
    if directory:
        img_folder = directory
    else:
        img_folder = os.path.dirname(train_df[image_column].iloc[0])
    (train_datagen, test_datagen) = process_datagen(
        data_aug,
        train_directory=img_folder,
        target_size=target_size,
        color_mode=color_mode,
        flat_dir=True,
    )

    # fix file extensions, if necessary
    if suffix:
        train_df = train_df.copy()
        val_df = val_df.copy()
        train_df[image_column] = train_df.copy()[image_column].apply(
            lambda x: str(x) + suffix
        )
        val_df[image_column] = val_df.copy()[image_column].apply(
            lambda x: str(x) + suffix
        )

    # get generators
    batches_tr = train_datagen.flow_from_dataframe(
        train_df,
        directory=directory,
        x_col=image_column,
        y_col=label_columns,
        target_size=target_size,
        class_mode=&#34;other&#34;,
        shuffle=True,
        interpolation=&#34;bicubic&#34;,
        color_mode=color_mode,
    )
    batches_te = None
    if val_df is not None:
        d = val_directory if val_directory is not None else directory
        batches_te = test_datagen.flow_from_dataframe(
            val_df,
            directory=d,
            x_col=image_column,
            y_col=label_columns,
            target_size=target_size,
            class_mode=&#34;other&#34;,
            shuffle=False,
            interpolation=&#34;bicubic&#34;,
            color_mode=color_mode,
        )

    # setup preprocessor
    preproc = ImagePreprocessor(
        test_datagen, class_names, target_size=target_size, color_mode=color_mode
    )
    return (batches_tr, batches_te, preproc)


def images_from_csv(
    train_filepath,
    image_column,
    label_columns=[],
    directory=None,
    suffix=&#34;&#34;,
    val_filepath=None,
    is_regression=False,
    target_size=(224, 224),
    color_mode=&#34;rgb&#34;,
    data_aug=None,
    val_pct=0.1,
    random_state=None,
):

    &#34;&#34;&#34;
    ```
    Returns image generator (Iterator instance).
    Assumes output will be 2D one-hot-encoded labels for categorization.
    Note: This function preprocesses the input in preparation
          for a ResNet50 model.

    Args:
    train_filepath (string): path to training dataset in CSV format with header row
    image_column (string): name of column containing the filenames of images
                           If values in image_column do not have a file extension,
                           the extension should be supplied with suffix argument.
                           If values in image_column are not full file paths,
                           then the path to directory containing images should be supplied
                           as directory argument.

    label_columns(list or str): list or str representing the columns that store labels
                                Labels can be in any one of the following formats:
                                1. a single column string string (or integer) labels

                                   image_fname,label
                                   -----------------
                                   image01,cat
                                   image02,dog

                                2. multiple columns for one-hot-encoded labels
                                   image_fname,cat,dog
                                   image01,1,0
                                   image02,0,1

                                3. a single column of numeric values for image regression
                                   image_fname,age
                                   -----------------
                                   image01,68
                                   image02,18

    directory (string): path to directory containing images
                        not required if image_column contains full filepaths
    suffix(str): will be appended to each entry in image_column
                 Used when the filenames in image_column do not contain file extensions.
                 The extension in suffx should include &#34;.&#34;.
    val_filepath (string): path to validation dataset in CSV format
    suffix(string): suffix to add to file names in image_column
    is_regression(bool): If True, task is treated as regression.
                         Used when there is single column of numeric values and
                         numeric values should be treated as numeric targets as opposed to class labels
    target_size (tuple):  image dimensions
    color_mode (string):  color mode
    data_aug(ImageDataGenerator):  a keras.preprocessing.image.ImageDataGenerator
                                  for data augmentation
    val_pct(float):  proportion of training data to be used for validation
                     only used if val_filepath is None
    random_state(int): random seed for train/test split

    Returns:
    batches: a tuple of two Iterators - one for train and one for test
    ```
    &#34;&#34;&#34;

    # convert to dataframes
    train_df = pd.read_csv(train_filepath)
    val_df = None
    if val_filepath is not None:
        val_df = pd.read_csv(val_filepath)

    return images_from_df(
        train_df,
        image_column,
        label_columns=label_columns,
        directory=directory,
        suffix=suffix,
        val_df=val_df,
        is_regression=is_regression,
        target_size=target_size,
        color_mode=color_mode,
        data_aug=data_aug,
        val_pct=val_pct,
        random_state=random_state,
    )


def images_from_fname(
    train_folder,
    pattern=r&#34;([^/]+)_\d+.jpg$&#34;,
    val_folder=None,
    is_regression=False,
    target_size=(224, 224),
    color_mode=&#34;rgb&#34;,
    data_aug=None,
    val_pct=0.1,
    random_state=None,
    verbose=1,
):

    &#34;&#34;&#34;
    ```
    Returns image generator (Iterator instance).

    Args:
    train_folder (str): directory containing images
    pat (str):  regular expression to extract class from file name of each image
                Example: r&#39;([^/]+)_\d+.jpg$&#39; to match &#39;english_setter&#39; in &#39;english_setter_140.jpg&#39;
                By default, it will extract classes from file names of the form:
                   &lt;class_name&gt;_&lt;numbers&gt;.jpg
    val_folder (str): directory containing validation images. default:None
    is_regression(bool): If True, task is treated as regression.
                         Used when there is single column of numeric values and
                         numeric values should be treated as numeric targets as opposed to class labels
    target_size (tuple):  image dimensions
    color_mode (string):  color mode
    data_aug(ImageDataGenerator):  a keras.preprocessing.image.ImageDataGenerator
                                  for data augmentation
    val_pct(float):  proportion of training data to be used for validation
                     only used if val_folder is None
    random_state(int): random seed for train/test split
    verbose(bool):   verbosity

    Returns:
    batches: a tuple of two Iterators - one for train and one for test
    ```
    &#34;&#34;&#34;

    image_column = &#34;image_name&#34;
    label_column = &#34;label&#34;
    train_df = _img_fnames_to_df(
        train_folder,
        pattern,
        image_column=image_column,
        label_column=label_column,
        verbose=verbose,
    )
    val_df = None
    if val_folder is not None:
        val_df = _img_fnames_to_df(
            val_folder,
            pattern,
            image_column=image_column,
            label_column=label_column,
            verbose=verbose,
        )
    return images_from_df(
        train_df,
        image_column,
        label_columns=label_column,
        directory=train_folder,
        val_directory=val_folder,
        val_df=val_df,
        is_regression=is_regression,
        target_size=target_size,
        color_mode=color_mode,
        data_aug=data_aug,
        val_pct=val_pct,
        random_state=random_state,
    )


def _img_fnames_to_df(
    img_folder, pattern, image_column=&#34;image_name&#34;, label_column=&#34;label&#34;, verbose=1
):
    # get fnames
    fnames = []
    for ext in (&#34;*.gif&#34;, &#34;*.png&#34;, &#34;*.jpg&#34;):
        fnames.extend(glob.glob(os.path.join(img_folder, ext)))

    # process filenames and labels
    image_names = []
    labels = []
    p = re.compile(pattern)
    for fname in fnames:
        r = p.search(fname)
        if r:
            image_names.append(os.path.basename(fname))
            labels.append(r.group(1))
        else:
            warnings.warn(
                &#34;Could not extract target for %s -  skipping this file&#34; % (fname)
            )
    dct = {&#34;image_name&#34;: image_names, &#34;label&#34;: labels}
    return pd.DataFrame(dct)


#    class_names = list(set(labels))
#    class_names.sort()
#    c2i = {k:v for v,k in enumerate(class_names)}
#    labels = [c2i[label] for label in labels]
#    labels = to_categorical(labels)
#    #class_names = [str(c) in class_names]
#    U.vprint(&#39;Found %s classes: %s&#39; % (len(class_names), class_names), verbose=verbose)
#    U.vprint(&#39;y shape: (%s,%s)&#39; % (labels.shape[0], labels.shape[1]), verbose=verbose)
#    dct = {&#39;image_name&#39;: image_names}
#    for i in range(labels.shape[1]):
#        dct[class_names[i]] = labels[:,i]

#    # convert to dataframes
#    df = pd.DataFrame(dct)
#    return (df, class_names)


def images_from_array(
    x_train,
    y_train,
    validation_data=None,
    val_pct=0.1,
    random_state=None,
    data_aug=None,
    classes=None,
    class_names=None,
    is_regression=False,
):

    &#34;&#34;&#34;
    ```
    Returns image generator (Iterator instance) from training
    and validation data in the form of NumPy arrays.
    This function only supports image classification.
    For image regression, please use images_from_df.

    Args:
      x_train(numpy.ndarray):  training gdata
      y_train(numpy.ndarray):  labels must either be:
                               1. one-hot (or multi-hot) encoded arrays
                               2. integer values representing the label
      validation_data (tuple): tuple of numpy.ndarrays for validation data.
                               labels should be in one of the formats listed above.
      val_pct(float): percentage of training data to use for validaton if validation_data is None
      random_state(int): random state to use for splitting data
      data_aug(ImageDataGenerator):  a keras.preprocessing.image.ImageDataGenerator
      classes(str): old name for class_names - should no longer be used
      class_names(str): list of strings to use as class names
      is_regression(bool): If True, task is treated as regression.
                           Used when there is single column of numeric values and
                           numeric values should be treated as numeric targets as opposed to class labels
    Returns:
      batches: a tuple of two image.Iterator - one for train and one for test and ImagePreprocessor instance
    ```
    &#34;&#34;&#34;
    if classes is not None:
        raise ValueError(&#39;Please use class_names argument instead of &#34;classes&#34;.&#39;)
    if class_names and is_regression:
        warnings.warn(
            &#34;is_regression=True, but class_names is not empty.  Task being treated as regression.&#34;
        )

    # split out validation set if necessary
    if validation_data:
        x_test = validation_data[0]
        y_test = validation_data[1]
    elif val_pct is not None and val_pct &gt; 0:
        x_train, x_test, y_train, y_test = train_test_split(
            x_train, y_train, test_size=val_pct, random_state=random_state
        )
    else:
        x_test = None
        y_test = None

    # transform labels
    ytrans = U.YTransform(class_names=class_names if not is_regression else [])
    y_train = ytrans.apply_train(y_train)
    y_test = ytrans.apply_test(y_test)
    class_names = ytrans.get_classes()

    # train and test data generators
    (train_datagen, test_datagen) = process_datagen(data_aug, train_array=x_train)

    # Image preprocessor
    preproc = ImagePreprocessor(
        test_datagen, class_names, target_size=None, color_mode=None
    )

    # training data
    batches_tr = train_datagen.flow(x_train, y_train, shuffle=True)

    # validation data
    batches_te = None
    if x_test is not None and y_test is not None:
        batches_te = test_datagen.flow(x_test, y_test, shuffle=False)
    return (batches_tr, batches_te, preproc)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ktrain.vision.data.datagen_needs_fit"><code class="name flex">
<span>def <span class="ident">datagen_needs_fit</span></span>(<span>datagen)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def datagen_needs_fit(datagen):
    if (
        datagen.featurewise_center
        or datagen.featurewise_std_normalization
        or datagen.zca_whitening
    ):
        return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="ktrain.vision.data.detect_color_mode"><code class="name flex">
<span>def <span class="ident">detect_color_mode</span></span>(<span>train_directory, target_size=(32, 32))</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def detect_color_mode(train_directory, target_size=(32, 32)):
    try:
        fname = glob.glob(os.path.join(train_directory, &#34;**/*&#34;))[0]
        img = Image.open(fname).resize(target_size)
        num_channels = len(img.getbands())
        if num_channels == 3:
            return &#34;rgb&#34;
        elif num_channels == 1:
            return &#34;grayscale&#34;
        else:
            return &#34;rgby&#34;
    except:
        warnings.warn(&#34;could not detect color_mode from %s&#34; % (train_directory))
        return</code></pre>
</details>
</dd>
<dt id="ktrain.vision.data.fit_datagens"><code class="name flex">
<span>def <span class="ident">fit_datagens</span></span>(<span>train_datagen, test_datagen, train_array=None, train_directory=None, target_size=None, color_mode='rgb', flat_dir=False)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>computes stats of images for normalization
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit_datagens(
    train_datagen,
    test_datagen,
    train_array=None,
    train_directory=None,
    target_size=None,
    color_mode=&#34;rgb&#34;,
    flat_dir=False,
):
    &#34;&#34;&#34;
    ```
    computes stats of images for normalization
    ```
    &#34;&#34;&#34;
    if not datagen_needs_fit(train_datagen):
        return
    if bool(train_array is not None) == bool(train_directory):
        raise ValueError(&#34;only one of train_array or train_directory is required.&#34;)
    if train_array is not None:
        train_datagen.fit(train_array)
        test_datagen.fit(train_array)
    else:
        if target_size is None:
            raise ValueError(&#34;target_size is required when train_directory is supplied&#34;)
        fit_samples = sample_image_folder(
            train_directory, target_size, color_mode=color_mode, flat_dir=flat_dir
        )
        train_datagen.fit(fit_samples)
        test_datagen.fit(fit_samples)
    return</code></pre>
</details>
</dd>
<dt id="ktrain.vision.data.get_data_aug"><code class="name flex">
<span>def <span class="ident">get_data_aug</span></span>(<span>rotation_range=40, zoom_range=0.2, width_shift_range=0.2, height_shift_range=0.2, horizontal_flip=False, vertical_flip=False, featurewise_center=True, featurewise_std_normalization=True, samplewise_center=False, samplewise_std_normalization=False, rescale=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>This function is simply a wrapper around ImageDataGenerator
with some reasonable defaults for data augmentation.
Returns the default image_data_generator to support
data augmentation and data normalization.
Parameters can be adjusted by caller.
Note that the ktrain.vision.model.image_classifier
function may adjust these as needed.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_data_aug(
    rotation_range=40,
    zoom_range=0.2,
    width_shift_range=0.2,
    height_shift_range=0.2,
    horizontal_flip=False,
    vertical_flip=False,
    featurewise_center=True,
    featurewise_std_normalization=True,
    samplewise_center=False,
    samplewise_std_normalization=False,
    rescale=None,
    **kwargs
):
    &#34;&#34;&#34;
    ```
    This function is simply a wrapper around ImageDataGenerator
    with some reasonable defaults for data augmentation.
    Returns the default image_data_generator to support
    data augmentation and data normalization.
    Parameters can be adjusted by caller.
    Note that the ktrain.vision.model.image_classifier
    function may adjust these as needed.
    ```
    &#34;&#34;&#34;

    data_aug = keras.preprocessing.image.ImageDataGenerator(
        rotation_range=rotation_range,
        zoom_range=zoom_range,
        width_shift_range=width_shift_range,
        height_shift_range=height_shift_range,
        horizontal_flip=horizontal_flip,
        vertical_flip=vertical_flip,
        featurewise_center=featurewise_center,
        featurewise_std_normalization=featurewise_std_normalization,
        samplewise_center=samplewise_center,
        samplewise_std_normalization=samplewise_std_normalization,
        rescale=rescale,
        **kwargs
    )
    return data_aug</code></pre>
</details>
</dd>
<dt id="ktrain.vision.data.get_test_datagen"><code class="name flex">
<span>def <span class="ident">get_test_datagen</span></span>(<span>data_aug=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_test_datagen(data_aug=None):
    if data_aug:
        featurewise_center = data_aug.featurewise_center
        featurewise_std_normalization = data_aug.featurewise_std_normalization
        samplewise_center = data_aug.samplewise_center
        samplewise_std_normalization = data_aug.samplewise_std_normalization
        rescale = data_aug.rescale
        zca_whitening = data_aug.zca_whitening
        test_datagen = keras.preprocessing.image.ImageDataGenerator(
            rescale=rescale,
            featurewise_center=featurewise_center,
            samplewise_center=samplewise_center,
            featurewise_std_normalization=featurewise_std_normalization,
            samplewise_std_normalization=samplewise_std_normalization,
            zca_whitening=zca_whitening,
        )
    else:
        test_datagen = keras.preprocessing.image.ImageDataGenerator()
    return test_datagen</code></pre>
</details>
</dd>
<dt id="ktrain.vision.data.images_from_array"><code class="name flex">
<span>def <span class="ident">images_from_array</span></span>(<span>x_train, y_train, validation_data=None, val_pct=0.1, random_state=None, data_aug=None, classes=None, class_names=None, is_regression=False)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>Returns image generator (Iterator instance) from training
and validation data in the form of NumPy arrays.
This function only supports image classification.
For image regression, please use images_from_df.

Args:
  x_train(numpy.ndarray):  training gdata
  y_train(numpy.ndarray):  labels must either be:
                           1. one-hot (or multi-hot) encoded arrays
                           2. integer values representing the label
  validation_data (tuple): tuple of numpy.ndarrays for validation data.
                           labels should be in one of the formats listed above.
  val_pct(float): percentage of training data to use for validaton if validation_data is None
  random_state(int): random state to use for splitting data
  data_aug(ImageDataGenerator):  a keras.preprocessing.image.ImageDataGenerator
  classes(str): old name for class_names - should no longer be used
  class_names(str): list of strings to use as class names
  is_regression(bool): If True, task is treated as regression.
                       Used when there is single column of numeric values and
                       numeric values should be treated as numeric targets as opposed to class labels
Returns:
  batches: a tuple of two image.Iterator - one for train and one for test and ImagePreprocessor instance
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def images_from_array(
    x_train,
    y_train,
    validation_data=None,
    val_pct=0.1,
    random_state=None,
    data_aug=None,
    classes=None,
    class_names=None,
    is_regression=False,
):

    &#34;&#34;&#34;
    ```
    Returns image generator (Iterator instance) from training
    and validation data in the form of NumPy arrays.
    This function only supports image classification.
    For image regression, please use images_from_df.

    Args:
      x_train(numpy.ndarray):  training gdata
      y_train(numpy.ndarray):  labels must either be:
                               1. one-hot (or multi-hot) encoded arrays
                               2. integer values representing the label
      validation_data (tuple): tuple of numpy.ndarrays for validation data.
                               labels should be in one of the formats listed above.
      val_pct(float): percentage of training data to use for validaton if validation_data is None
      random_state(int): random state to use for splitting data
      data_aug(ImageDataGenerator):  a keras.preprocessing.image.ImageDataGenerator
      classes(str): old name for class_names - should no longer be used
      class_names(str): list of strings to use as class names
      is_regression(bool): If True, task is treated as regression.
                           Used when there is single column of numeric values and
                           numeric values should be treated as numeric targets as opposed to class labels
    Returns:
      batches: a tuple of two image.Iterator - one for train and one for test and ImagePreprocessor instance
    ```
    &#34;&#34;&#34;
    if classes is not None:
        raise ValueError(&#39;Please use class_names argument instead of &#34;classes&#34;.&#39;)
    if class_names and is_regression:
        warnings.warn(
            &#34;is_regression=True, but class_names is not empty.  Task being treated as regression.&#34;
        )

    # split out validation set if necessary
    if validation_data:
        x_test = validation_data[0]
        y_test = validation_data[1]
    elif val_pct is not None and val_pct &gt; 0:
        x_train, x_test, y_train, y_test = train_test_split(
            x_train, y_train, test_size=val_pct, random_state=random_state
        )
    else:
        x_test = None
        y_test = None

    # transform labels
    ytrans = U.YTransform(class_names=class_names if not is_regression else [])
    y_train = ytrans.apply_train(y_train)
    y_test = ytrans.apply_test(y_test)
    class_names = ytrans.get_classes()

    # train and test data generators
    (train_datagen, test_datagen) = process_datagen(data_aug, train_array=x_train)

    # Image preprocessor
    preproc = ImagePreprocessor(
        test_datagen, class_names, target_size=None, color_mode=None
    )

    # training data
    batches_tr = train_datagen.flow(x_train, y_train, shuffle=True)

    # validation data
    batches_te = None
    if x_test is not None and y_test is not None:
        batches_te = test_datagen.flow(x_test, y_test, shuffle=False)
    return (batches_tr, batches_te, preproc)</code></pre>
</details>
</dd>
<dt id="ktrain.vision.data.images_from_csv"><code class="name flex">
<span>def <span class="ident">images_from_csv</span></span>(<span>train_filepath, image_column, label_columns=[], directory=None, suffix='', val_filepath=None, is_regression=False, target_size=(224, 224), color_mode='rgb', data_aug=None, val_pct=0.1, random_state=None)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>Returns image generator (Iterator instance).
Assumes output will be 2D one-hot-encoded labels for categorization.
Note: This function preprocesses the input in preparation
      for a ResNet50 model.

Args:
train_filepath (string): path to training dataset in CSV format with header row
image_column (string): name of column containing the filenames of images
                       If values in image_column do not have a file extension,
                       the extension should be supplied with suffix argument.
                       If values in image_column are not full file paths,
                       then the path to directory containing images should be supplied
                       as directory argument.

label_columns(list or str): list or str representing the columns that store labels
                            Labels can be in any one of the following formats:
                            1. a single column string string (or integer) labels

                               image_fname,label
                               -----------------
                               image01,cat
                               image02,dog

                            2. multiple columns for one-hot-encoded labels
                               image_fname,cat,dog
                               image01,1,0
                               image02,0,1

                            3. a single column of numeric values for image regression
                               image_fname,age
                               -----------------
                               image01,68
                               image02,18

directory (string): path to directory containing images
                    not required if image_column contains full filepaths
suffix(str): will be appended to each entry in image_column
             Used when the filenames in image_column do not contain file extensions.
             The extension in suffx should include &quot;.&quot;.
val_filepath (string): path to validation dataset in CSV format
suffix(string): suffix to add to file names in image_column
is_regression(bool): If True, task is treated as regression.
                     Used when there is single column of numeric values and
                     numeric values should be treated as numeric targets as opposed to class labels
target_size (tuple):  image dimensions
color_mode (string):  color mode
data_aug(ImageDataGenerator):  a keras.preprocessing.image.ImageDataGenerator
                              for data augmentation
val_pct(float):  proportion of training data to be used for validation
                 only used if val_filepath is None
random_state(int): random seed for train/test split

Returns:
batches: a tuple of two Iterators - one for train and one for test
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def images_from_csv(
    train_filepath,
    image_column,
    label_columns=[],
    directory=None,
    suffix=&#34;&#34;,
    val_filepath=None,
    is_regression=False,
    target_size=(224, 224),
    color_mode=&#34;rgb&#34;,
    data_aug=None,
    val_pct=0.1,
    random_state=None,
):

    &#34;&#34;&#34;
    ```
    Returns image generator (Iterator instance).
    Assumes output will be 2D one-hot-encoded labels for categorization.
    Note: This function preprocesses the input in preparation
          for a ResNet50 model.

    Args:
    train_filepath (string): path to training dataset in CSV format with header row
    image_column (string): name of column containing the filenames of images
                           If values in image_column do not have a file extension,
                           the extension should be supplied with suffix argument.
                           If values in image_column are not full file paths,
                           then the path to directory containing images should be supplied
                           as directory argument.

    label_columns(list or str): list or str representing the columns that store labels
                                Labels can be in any one of the following formats:
                                1. a single column string string (or integer) labels

                                   image_fname,label
                                   -----------------
                                   image01,cat
                                   image02,dog

                                2. multiple columns for one-hot-encoded labels
                                   image_fname,cat,dog
                                   image01,1,0
                                   image02,0,1

                                3. a single column of numeric values for image regression
                                   image_fname,age
                                   -----------------
                                   image01,68
                                   image02,18

    directory (string): path to directory containing images
                        not required if image_column contains full filepaths
    suffix(str): will be appended to each entry in image_column
                 Used when the filenames in image_column do not contain file extensions.
                 The extension in suffx should include &#34;.&#34;.
    val_filepath (string): path to validation dataset in CSV format
    suffix(string): suffix to add to file names in image_column
    is_regression(bool): If True, task is treated as regression.
                         Used when there is single column of numeric values and
                         numeric values should be treated as numeric targets as opposed to class labels
    target_size (tuple):  image dimensions
    color_mode (string):  color mode
    data_aug(ImageDataGenerator):  a keras.preprocessing.image.ImageDataGenerator
                                  for data augmentation
    val_pct(float):  proportion of training data to be used for validation
                     only used if val_filepath is None
    random_state(int): random seed for train/test split

    Returns:
    batches: a tuple of two Iterators - one for train and one for test
    ```
    &#34;&#34;&#34;

    # convert to dataframes
    train_df = pd.read_csv(train_filepath)
    val_df = None
    if val_filepath is not None:
        val_df = pd.read_csv(val_filepath)

    return images_from_df(
        train_df,
        image_column,
        label_columns=label_columns,
        directory=directory,
        suffix=suffix,
        val_df=val_df,
        is_regression=is_regression,
        target_size=target_size,
        color_mode=color_mode,
        data_aug=data_aug,
        val_pct=val_pct,
        random_state=random_state,
    )</code></pre>
</details>
</dd>
<dt id="ktrain.vision.data.images_from_df"><code class="name flex">
<span>def <span class="ident">images_from_df</span></span>(<span>train_df, image_column, label_columns=[], directory=None, val_directory=None, suffix='', val_df=None, is_regression=False, target_size=(224, 224), color_mode='rgb', data_aug=None, val_pct=0.1, random_state=None)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>Returns image generator (Iterator instance).
Assumes output will be 2D one-hot-encoded labels for categorization.
Note: This function preprocesses the input in preparation
      for a ResNet50 model.

Args:
train_df (DataFrame):  pandas dataframe for training dataset
image_column (string): name of column containing the filenames of images
                       If values in image_column do not have a file extension,
                       the extension should be supplied with suffix argument.
                       If values in image_column are not full file paths,
                       then the path to directory containing images should be supplied
                       as directory argument.

label_columns(list or str): list or str representing the columns that store labels
                            Labels can be in any one of the following formats:
                            1. a single column string string (or integer) labels

                               image_fname,label
                               -----------------
                               image01,cat
                               image02,dog

                            2. multiple columns for one-hot-encoded labels
                               image_fname,cat,dog
                               image01,1,0
                               image02,0,1

                            3. a single column of numeric values for image regression
                               image_fname,age
                               -----------------
                               image01,68
                               image02,18

directory (string): path to directory containing images
                    not required if image_column contains full filepaths
val_directory(strin): path to directory containing validation images.
                      only required if validation images are in different folder than train images
suffix(str): will be appended to each entry in image_column
             Used when the filenames in image_column do not contain file extensions.
             The extension in suffx should include &quot;.&quot;.
val_df (DataFrame): pandas dataframe for validation set

is_regression(bool): If True, task is treated as regression.
                     Used when there is single column of numeric values and
                     numeric values should be treated as numeric targets as opposed to class labels
target_size (tuple):  image dimensions
color_mode (string):  color mode
data_aug(ImageDataGenerator):  a keras.preprocessing.image.ImageDataGenerator
                              for data augmentation
val_pct(float):  proportion of training data to be used for validation
                 only used if val_filepath is None
random_state(int): random seed for train/test split

Returns:
batches: a tuple of two Iterators - one for train and one for test
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def images_from_df(
    train_df,
    image_column,
    label_columns=[],
    directory=None,
    val_directory=None,
    suffix=&#34;&#34;,
    val_df=None,
    is_regression=False,
    target_size=(224, 224),
    color_mode=&#34;rgb&#34;,
    data_aug=None,
    val_pct=0.1,
    random_state=None,
):

    &#34;&#34;&#34;
    ```
    Returns image generator (Iterator instance).
    Assumes output will be 2D one-hot-encoded labels for categorization.
    Note: This function preprocesses the input in preparation
          for a ResNet50 model.

    Args:
    train_df (DataFrame):  pandas dataframe for training dataset
    image_column (string): name of column containing the filenames of images
                           If values in image_column do not have a file extension,
                           the extension should be supplied with suffix argument.
                           If values in image_column are not full file paths,
                           then the path to directory containing images should be supplied
                           as directory argument.

    label_columns(list or str): list or str representing the columns that store labels
                                Labels can be in any one of the following formats:
                                1. a single column string string (or integer) labels

                                   image_fname,label
                                   -----------------
                                   image01,cat
                                   image02,dog

                                2. multiple columns for one-hot-encoded labels
                                   image_fname,cat,dog
                                   image01,1,0
                                   image02,0,1

                                3. a single column of numeric values for image regression
                                   image_fname,age
                                   -----------------
                                   image01,68
                                   image02,18

    directory (string): path to directory containing images
                        not required if image_column contains full filepaths
    val_directory(strin): path to directory containing validation images.
                          only required if validation images are in different folder than train images
    suffix(str): will be appended to each entry in image_column
                 Used when the filenames in image_column do not contain file extensions.
                 The extension in suffx should include &#34;.&#34;.
    val_df (DataFrame): pandas dataframe for validation set

    is_regression(bool): If True, task is treated as regression.
                         Used when there is single column of numeric values and
                         numeric values should be treated as numeric targets as opposed to class labels
    target_size (tuple):  image dimensions
    color_mode (string):  color mode
    data_aug(ImageDataGenerator):  a keras.preprocessing.image.ImageDataGenerator
                                  for data augmentation
    val_pct(float):  proportion of training data to be used for validation
                     only used if val_filepath is None
    random_state(int): random seed for train/test split

    Returns:
    batches: a tuple of two Iterators - one for train and one for test
    ```
    &#34;&#34;&#34;

    # read in train and test data
    train_df = train_df.copy()
    if val_df is not None:
        val_df = val_df.copy()
    else:
        train_df, val_df = train_test_split(
            train_df, test_size=val_pct, random_state=random_state
        )

    # transform labels
    ytransdf = U.YTransformDataFrame(label_columns, is_regression=is_regression)
    train_df = ytransdf.apply_train(train_df)
    val_df = ytransdf.apply_test(val_df)
    class_names = ytransdf.get_classes()
    label_columns = ytransdf.get_label_columns(squeeze=True)

    # get train and test data generators
    if directory:
        img_folder = directory
    else:
        img_folder = os.path.dirname(train_df[image_column].iloc[0])
    (train_datagen, test_datagen) = process_datagen(
        data_aug,
        train_directory=img_folder,
        target_size=target_size,
        color_mode=color_mode,
        flat_dir=True,
    )

    # fix file extensions, if necessary
    if suffix:
        train_df = train_df.copy()
        val_df = val_df.copy()
        train_df[image_column] = train_df.copy()[image_column].apply(
            lambda x: str(x) + suffix
        )
        val_df[image_column] = val_df.copy()[image_column].apply(
            lambda x: str(x) + suffix
        )

    # get generators
    batches_tr = train_datagen.flow_from_dataframe(
        train_df,
        directory=directory,
        x_col=image_column,
        y_col=label_columns,
        target_size=target_size,
        class_mode=&#34;other&#34;,
        shuffle=True,
        interpolation=&#34;bicubic&#34;,
        color_mode=color_mode,
    )
    batches_te = None
    if val_df is not None:
        d = val_directory if val_directory is not None else directory
        batches_te = test_datagen.flow_from_dataframe(
            val_df,
            directory=d,
            x_col=image_column,
            y_col=label_columns,
            target_size=target_size,
            class_mode=&#34;other&#34;,
            shuffle=False,
            interpolation=&#34;bicubic&#34;,
            color_mode=color_mode,
        )

    # setup preprocessor
    preproc = ImagePreprocessor(
        test_datagen, class_names, target_size=target_size, color_mode=color_mode
    )
    return (batches_tr, batches_te, preproc)</code></pre>
</details>
</dd>
<dt id="ktrain.vision.data.images_from_fname"><code class="name flex">
<span>def <span class="ident">images_from_fname</span></span>(<span>train_folder, pattern='([^/]+)_\\d+.jpg$', val_folder=None, is_regression=False, target_size=(224, 224), color_mode='rgb', data_aug=None, val_pct=0.1, random_state=None, verbose=1)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>Returns image generator (Iterator instance).

Args:
train_folder (str): directory containing images
pat (str):  regular expression to extract class from file name of each image
            Example: r'([^/]+)_\d+.jpg$' to match 'english_setter' in 'english_setter_140.jpg'
            By default, it will extract classes from file names of the form:
               &lt;class_name&gt;_&lt;numbers&gt;.jpg
val_folder (str): directory containing validation images. default:None
is_regression(bool): If True, task is treated as regression.
                     Used when there is single column of numeric values and
                     numeric values should be treated as numeric targets as opposed to class labels
target_size (tuple):  image dimensions
color_mode (string):  color mode
data_aug(ImageDataGenerator):  a keras.preprocessing.image.ImageDataGenerator
                              for data augmentation
val_pct(float):  proportion of training data to be used for validation
                 only used if val_folder is None
random_state(int): random seed for train/test split
verbose(bool):   verbosity

Returns:
batches: a tuple of two Iterators - one for train and one for test
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def images_from_fname(
    train_folder,
    pattern=r&#34;([^/]+)_\d+.jpg$&#34;,
    val_folder=None,
    is_regression=False,
    target_size=(224, 224),
    color_mode=&#34;rgb&#34;,
    data_aug=None,
    val_pct=0.1,
    random_state=None,
    verbose=1,
):

    &#34;&#34;&#34;
    ```
    Returns image generator (Iterator instance).

    Args:
    train_folder (str): directory containing images
    pat (str):  regular expression to extract class from file name of each image
                Example: r&#39;([^/]+)_\d+.jpg$&#39; to match &#39;english_setter&#39; in &#39;english_setter_140.jpg&#39;
                By default, it will extract classes from file names of the form:
                   &lt;class_name&gt;_&lt;numbers&gt;.jpg
    val_folder (str): directory containing validation images. default:None
    is_regression(bool): If True, task is treated as regression.
                         Used when there is single column of numeric values and
                         numeric values should be treated as numeric targets as opposed to class labels
    target_size (tuple):  image dimensions
    color_mode (string):  color mode
    data_aug(ImageDataGenerator):  a keras.preprocessing.image.ImageDataGenerator
                                  for data augmentation
    val_pct(float):  proportion of training data to be used for validation
                     only used if val_folder is None
    random_state(int): random seed for train/test split
    verbose(bool):   verbosity

    Returns:
    batches: a tuple of two Iterators - one for train and one for test
    ```
    &#34;&#34;&#34;

    image_column = &#34;image_name&#34;
    label_column = &#34;label&#34;
    train_df = _img_fnames_to_df(
        train_folder,
        pattern,
        image_column=image_column,
        label_column=label_column,
        verbose=verbose,
    )
    val_df = None
    if val_folder is not None:
        val_df = _img_fnames_to_df(
            val_folder,
            pattern,
            image_column=image_column,
            label_column=label_column,
            verbose=verbose,
        )
    return images_from_df(
        train_df,
        image_column,
        label_columns=label_column,
        directory=train_folder,
        val_directory=val_folder,
        val_df=val_df,
        is_regression=is_regression,
        target_size=target_size,
        color_mode=color_mode,
        data_aug=data_aug,
        val_pct=val_pct,
        random_state=random_state,
    )</code></pre>
</details>
</dd>
<dt id="ktrain.vision.data.images_from_folder"><code class="name flex">
<span>def <span class="ident">images_from_folder</span></span>(<span>datadir, target_size=(224, 224), classes=None, color_mode='rgb', train_test_names=['train', 'test'], data_aug=None, verbose=1)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>Returns image generator (Iterator instance).
Assumes output will be 2D one-hot-encoded labels for categorization.
Note: This function preprocesses the input in preparation
      for a ResNet50 model.

Args:
datadir (string): path to training (or validation/test) dataset
    Assumes folder follows this structure:
    ├── datadir
    │   ├── train
    │   │   ├── class0       # folder containing documents of class 0
    │   │   ├── class1       # folder containing documents of class 1
    │   │   ├── class2       # folder containing documents of class 2
    │   │   └── classN       # folder containing documents of class N
    │   └── test
    │       ├── class0       # folder containing documents of class 0
    │       ├── class1       # folder containing documents of class 1
    │       ├── class2       # folder containing documents of class 2
    │       └── classN       # folder containing documents of class N

target_size (tuple):  image dimensions
classes (list):  optional list of class subdirectories (e.g., ['cats','dogs'])
color_mode (string):  color mode
train_test_names(list): names for train and test subfolders
data_aug(ImageDataGenerator):  a keras.preprocessing.image.ImageDataGenerator
                              for data augmentation
verbose (bool):               verbosity

Returns:
batches: a tuple of two Iterators - one for train and one for test
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def images_from_folder(
    datadir,
    target_size=(224, 224),
    classes=None,
    color_mode=&#34;rgb&#34;,
    train_test_names=[&#34;train&#34;, &#34;test&#34;],
    data_aug=None,
    verbose=1,
):

    &#34;&#34;&#34;
    ```
    Returns image generator (Iterator instance).
    Assumes output will be 2D one-hot-encoded labels for categorization.
    Note: This function preprocesses the input in preparation
          for a ResNet50 model.

    Args:
    datadir (string): path to training (or validation/test) dataset
        Assumes folder follows this structure:
        ├── datadir
        │   ├── train
        │   │   ├── class0       # folder containing documents of class 0
        │   │   ├── class1       # folder containing documents of class 1
        │   │   ├── class2       # folder containing documents of class 2
        │   │   └── classN       # folder containing documents of class N
        │   └── test
        │       ├── class0       # folder containing documents of class 0
        │       ├── class1       # folder containing documents of class 1
        │       ├── class2       # folder containing documents of class 2
        │       └── classN       # folder containing documents of class N

    target_size (tuple):  image dimensions
    classes (list):  optional list of class subdirectories (e.g., [&#39;cats&#39;,&#39;dogs&#39;])
    color_mode (string):  color mode
    train_test_names(list): names for train and test subfolders
    data_aug(ImageDataGenerator):  a keras.preprocessing.image.ImageDataGenerator
                                  for data augmentation
    verbose (bool):               verbosity

    Returns:
    batches: a tuple of two Iterators - one for train and one for test
    ```
    &#34;&#34;&#34;

    # train/test names
    train_str = train_test_names[0]
    test_str = train_test_names[1]
    train_dir = os.path.join(datadir, train_str)
    test_dir = os.path.join(datadir, test_str)

    # color mode warning
    if PIL_INSTALLED:
        inferred_color_mode = detect_color_mode(train_dir)
        if inferred_color_mode is not None and (inferred_color_mode != color_mode):
            U.vprint(
                &#34;color_mode detected (%s) different than color_mode selected (%s)&#34;
                % (inferred_color_mode, color_mode),
                verbose=verbose,
            )

    # get train and test data generators
    (train_datagen, test_datagen) = process_datagen(
        data_aug,
        train_directory=train_dir,
        target_size=target_size,
        color_mode=color_mode,
    )
    batches_tr = train_datagen.flow_from_directory(
        train_dir,
        target_size=target_size,
        classes=classes,
        class_mode=&#34;categorical&#34;,
        shuffle=True,
        interpolation=&#34;bicubic&#34;,
        color_mode=color_mode,
    )

    batches_te = test_datagen.flow_from_directory(
        test_dir,
        target_size=target_size,
        classes=classes,
        class_mode=&#34;categorical&#34;,
        shuffle=False,
        interpolation=&#34;bicubic&#34;,
        color_mode=color_mode,
    )

    # setup preprocessor
    class_tup = sorted(batches_tr.class_indices.items(), key=operator.itemgetter(1))
    preproc = ImagePreprocessor(
        test_datagen,
        [x[0] for x in class_tup],
        target_size=target_size,
        color_mode=color_mode,
    )
    return (batches_tr, batches_te, preproc)</code></pre>
</details>
</dd>
<dt id="ktrain.vision.data.preprocess_csv"><code class="name flex">
<span>def <span class="ident">preprocess_csv</span></span>(<span>csv_in, csv_out, x_col='filename', y_col=None, sep=',', label_sep=' ', suffix='', split_by=None)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>Takes a CSV where the one column contains a file name and a column
containing a string representations of the class(es) like here:
image_name,tags
01, sunny|hot
02, cloudy|cold
03, cloudy|hot

.... and one-hot encodes the classes to produce a CSV as follows:
image_name, cloudy, cold, hot, sunny
01.jpg,0,0,1,1
02.jpg,1,1,0,0
03.jpg,1,0,1,0
Args:
    csv_in (str):  filepath to input CSV file
    csv_out (str): filepath to output CSV file
    x_col (str):  name of column containing file names
    y_col (str): name of column containing the classes
    sep (str): field delimiter of entire file (e.g., comma fore CSV)
    label_sep (str): delimiter for column containing classes
    suffix (str): adds suffix to x_col values
    split_by(str): name of column. A separate CSV will be
                   created for each value in column. Useful
                   for splitting a CSV based on whether a column
                   contains 'train' or 'valid'.
Return:
    list :  the list of clases (and csv_out will be new CSV file)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preprocess_csv(
    csv_in,
    csv_out,
    x_col=&#34;filename&#34;,
    y_col=None,
    sep=&#34;,&#34;,
    label_sep=&#34; &#34;,
    suffix=&#34;&#34;,
    split_by=None,
):
    &#34;&#34;&#34;
    ```
    Takes a CSV where the one column contains a file name and a column
    containing a string representations of the class(es) like here:
    image_name,tags
    01, sunny|hot
    02, cloudy|cold
    03, cloudy|hot

    .... and one-hot encodes the classes to produce a CSV as follows:
    image_name, cloudy, cold, hot, sunny
    01.jpg,0,0,1,1
    02.jpg,1,1,0,0
    03.jpg,1,0,1,0
    Args:
        csv_in (str):  filepath to input CSV file
        csv_out (str): filepath to output CSV file
        x_col (str):  name of column containing file names
        y_col (str): name of column containing the classes
        sep (str): field delimiter of entire file (e.g., comma fore CSV)
        label_sep (str): delimiter for column containing classes
        suffix (str): adds suffix to x_col values
        split_by(str): name of column. A separate CSV will be
                       created for each value in column. Useful
                       for splitting a CSV based on whether a column
                       contains &#39;train&#39; or &#39;valid&#39;.
    Return:
        list :  the list of clases (and csv_out will be new CSV file)
    ```
    &#34;&#34;&#34;
    if not y_col and not suffix:
        raise ValueError(&#34;one or both of y_col and suffix should be supplied&#34;)
    df = pd.read_csv(csv_in, sep=sep)
    f_csv_out = open(csv_out, &#34;w&#34;)
    writer = csv.writer(f_csv_out, delimiter=sep)
    if y_col:
        df[y_col] = df[y_col].apply(str)

    # write header
    if y_col:
        classes = set()
        for row in df.iterrows():
            data = row[1]
            tags = data[y_col].split(label_sep)
            classes.update(tags)
        classes = list(classes)
        classes.sort()
        writer.writerow([x_col] + classes)
    else:
        classes = df.columns[:-1]
        write.writerow(df.columns)

    # write rows
    for row in df.iterrows():
        data = row[1]
        data[x_col] = data[x_col] + suffix
        if y_col:
            out = list(data[[x_col]].values)
            tags = set(data[y_col].strip().split(label_sep))
            for c in classes:
                if c in tags:
                    out.append(1)
                else:
                    out.append(0)
        else:
            out = data
        writer.writerow(out)
    f_csv_out.close()
    return classes</code></pre>
</details>
</dd>
<dt id="ktrain.vision.data.preview_data_aug"><code class="name flex">
<span>def <span class="ident">preview_data_aug</span></span>(<span>img_path, data_aug, rows=1, n=4)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>Preview data augmentation (ImageDatagenerator)
on a supplied image.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preview_data_aug(img_path, data_aug, rows=1, n=4):
    &#34;&#34;&#34;
    ```
    Preview data augmentation (ImageDatagenerator)
    on a supplied image.
    ```
    &#34;&#34;&#34;
    if type(img_path) != type(&#34;&#34;) or not os.path.isfile(img_path):
        raise ValueError(&#34;img_path must be valid file path to image&#34;)
    idg = copy.copy(data_aug)
    idg.featurewise_center = False
    idg.featurewise_std_normalization = False
    idg.samplewise_center = False
    idg.samplewise_std_normalization = False
    idg.rescale = None
    idg.zca_whitening = False
    idg.preprocessing_function = None

    img = keras.preprocessing.image.load_img(img_path)
    x = keras.preprocessing.image.img_to_array(img)
    x = x / 255.0
    x = x.reshape((1,) + x.shape)
    i = 0
    ims = []
    for batch in idg.flow(x, batch_size=1):
        ims.append(np.squeeze(batch))
        i += 1
        if i &gt;= n:
            break
    U.plots(ims, rows=rows)
    return</code></pre>
</details>
</dd>
<dt id="ktrain.vision.data.preview_data_aug_OLD"><code class="name flex">
<span>def <span class="ident">preview_data_aug_OLD</span></span>(<span>img_path, data_aug, n=4)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>Preview data augmentation (ImageDatagenerator)
on a supplied image.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preview_data_aug_OLD(img_path, data_aug, n=4):
    &#34;&#34;&#34;
    ```
    Preview data augmentation (ImageDatagenerator)
    on a supplied image.
    ```
    &#34;&#34;&#34;
    if type(img_path) != type(&#34;&#34;) or not os.path.isfile(img_path):
        raise ValueError(&#34;img_path must be valid file path to image&#34;)
    idg = copy.copy(data_aug)
    idg.featurewise_center = False
    idg.featurewise_std_normalization = False
    idg.samplewise_center = False
    idg.samplewise_std_normalization = False
    idg.rescale = None
    idg.zca_whitening = False
    idg.preprocessing_function = None

    img = keras.preprocessing.image.load_img(img_path)
    x = keras.preprocessing.image.img_to_array(img)
    x = x / 255.0
    x = x.reshape((1,) + x.shape)
    i = 0
    for batch in idg.flow(x, batch_size=1):
        plt.figure()
        plt.imshow(np.squeeze(batch))
        i += 1
        if i &gt;= n:
            break
    return</code></pre>
</details>
</dd>
<dt id="ktrain.vision.data.process_datagen"><code class="name flex">
<span>def <span class="ident">process_datagen</span></span>(<span>data_aug, train_array=None, train_directory=None, target_size=None, color_mode='rgb', flat_dir=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_datagen(
    data_aug,
    train_array=None,
    train_directory=None,
    target_size=None,
    color_mode=&#34;rgb&#34;,
    flat_dir=False,
):
    # set generators for train and test
    if data_aug is not None:
        train_datagen = data_aug
        test_datagen = get_test_datagen(data_aug=data_aug)
    else:
        train_datagen = get_test_datagen()
        test_datagen = get_test_datagen()

    # compute statistics for normalization
    fit_datagens(
        train_datagen,
        test_datagen,
        train_array=train_array,
        train_directory=train_directory,
        target_size=target_size,
        color_mode=color_mode,
        flat_dir=flat_dir,
    )

    return (train_datagen, test_datagen)</code></pre>
</details>
</dd>
<dt id="ktrain.vision.data.sample_image_folder"><code class="name flex">
<span>def <span class="ident">sample_image_folder</span></span>(<span>train_directory, target_size, color_mode='rgb', flat_dir=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_image_folder(train_directory, target_size, color_mode=&#34;rgb&#34;, flat_dir=False):

    # adjust train_directory
    classes = None
    if flat_dir and train_directory is not None:
        folder = train_directory
        if folder[-1] != os.sep:
            folder += os.sep
        parent = os.path.dirname(os.path.dirname(folder))
        folder_name = os.path.basename(os.path.dirname(folder))
        train_directory = parent
        classes = [folder_name]

    # sample images
    batch_size = 100
    img_gen = keras.preprocessing.image.ImageDataGenerator()
    batches = img_gen.flow_from_directory(
        directory=train_directory,
        classes=classes,
        target_size=target_size,
        batch_size=batch_size,
        color_mode=color_mode,
        shuffle=True,
    )
    the_shape = batches[0][0].shape
    sample_size = the_shape[0]
    if K.image_data_format() == &#34;channels_first&#34;:
        num_channels = the_shape[1]
    else:
        num_channels = the_shape[-1]
    imgs, labels = next(batches)
    return imgs</code></pre>
</details>
</dd>
<dt id="ktrain.vision.data.show_image"><code class="name flex">
<span>def <span class="ident">show_image</span></span>(<span>img_path)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>Given file path to image, show it in Jupyter notebook
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_image(img_path):
    &#34;&#34;&#34;
    ```
    Given file path to image, show it in Jupyter notebook
    ```
    &#34;&#34;&#34;
    if not os.path.isfile(img_path):
        raise ValueError(&#34;%s is not valid file&#34; % (img_path))
    img = plt.imread(img_path)
    out = plt.imshow(img)
    return out</code></pre>
</details>
</dd>
<dt id="ktrain.vision.data.show_random_images"><code class="name flex">
<span>def <span class="ident">show_random_images</span></span>(<span>img_folder, n=4, rows=1)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>display random images from a img_folder
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_random_images(img_folder, n=4, rows=1):
    &#34;&#34;&#34;
    ```
    display random images from a img_folder
    ```
    &#34;&#34;&#34;
    fnames = []
    for ext in (&#34;*.gif&#34;, &#34;*.png&#34;, &#34;*.jpg&#34;):
        fnames.extend(glob.glob(os.path.join(img_folder, ext)))
    ims = []
    for i in range(n):
        img_path = random.choice(fnames)
        img = keras.preprocessing.image.load_img(img_path)
        x = keras.preprocessing.image.img_to_array(img)
        x = x / 255.0
        ims.append(x)
    U.plots(ims, rows=rows)
    return</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ktrain.vision" href="index.html">ktrain.vision</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ktrain.vision.data.datagen_needs_fit" href="#ktrain.vision.data.datagen_needs_fit">datagen_needs_fit</a></code></li>
<li><code><a title="ktrain.vision.data.detect_color_mode" href="#ktrain.vision.data.detect_color_mode">detect_color_mode</a></code></li>
<li><code><a title="ktrain.vision.data.fit_datagens" href="#ktrain.vision.data.fit_datagens">fit_datagens</a></code></li>
<li><code><a title="ktrain.vision.data.get_data_aug" href="#ktrain.vision.data.get_data_aug">get_data_aug</a></code></li>
<li><code><a title="ktrain.vision.data.get_test_datagen" href="#ktrain.vision.data.get_test_datagen">get_test_datagen</a></code></li>
<li><code><a title="ktrain.vision.data.images_from_array" href="#ktrain.vision.data.images_from_array">images_from_array</a></code></li>
<li><code><a title="ktrain.vision.data.images_from_csv" href="#ktrain.vision.data.images_from_csv">images_from_csv</a></code></li>
<li><code><a title="ktrain.vision.data.images_from_df" href="#ktrain.vision.data.images_from_df">images_from_df</a></code></li>
<li><code><a title="ktrain.vision.data.images_from_fname" href="#ktrain.vision.data.images_from_fname">images_from_fname</a></code></li>
<li><code><a title="ktrain.vision.data.images_from_folder" href="#ktrain.vision.data.images_from_folder">images_from_folder</a></code></li>
<li><code><a title="ktrain.vision.data.preprocess_csv" href="#ktrain.vision.data.preprocess_csv">preprocess_csv</a></code></li>
<li><code><a title="ktrain.vision.data.preview_data_aug" href="#ktrain.vision.data.preview_data_aug">preview_data_aug</a></code></li>
<li><code><a title="ktrain.vision.data.preview_data_aug_OLD" href="#ktrain.vision.data.preview_data_aug_OLD">preview_data_aug_OLD</a></code></li>
<li><code><a title="ktrain.vision.data.process_datagen" href="#ktrain.vision.data.process_datagen">process_datagen</a></code></li>
<li><code><a title="ktrain.vision.data.sample_image_folder" href="#ktrain.vision.data.sample_image_folder">sample_image_folder</a></code></li>
<li><code><a title="ktrain.vision.data.show_image" href="#ktrain.vision.data.show_image">show_image</a></code></li>
<li><code><a title="ktrain.vision.data.show_random_images" href="#ktrain.vision.data.show_random_images">show_random_images</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>
