<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ktrain.graph.sg_wrappers API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ktrain.graph.sg_wrappers</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from ..dataset import SequenceDataset
from ..imports import *

# import stellargraph
try:
    import stellargraph as sg
    from stellargraph.mapper import link_mappers, node_mappers
except:
    raise Exception(SG_ERRMSG)
if version.parse(sg.__version__) &lt; version.parse(&#34;0.8&#34;):
    raise Exception(SG_ERRMSG)


class NodeSequenceWrapper(node_mappers.NodeSequence, SequenceDataset):
    def __init__(self, node_seq):
        if not isinstance(node_seq, node_mappers.NodeSequence):
            raise ValueError(&#34;node_seq must by a stellargraph NodeSequence object&#34;)
        self.node_seq = node_seq
        self.targets = node_seq.targets
        self.generator = node_seq.generator
        self.ids = node_seq.ids
        self.__len__ = node_seq.__len__
        self.__getitem__ = node_seq.__getitem__
        self.on_epoch_end = node_seq.on_epoch_end
        self.indices = node_seq.indices

    def __setattr__(self, name, value):
        if name == &#34;batch_size&#34;:
            self.generator.batch_size = value
        elif name == &#34;data_size&#34;:
            self.node_seq.data_size = value
        elif name == &#34;shuffle&#34;:
            self.node_seq.shuffle = value
        elif name == &#34;head_node_types&#34;:
            self.node_seq.head_node_types = value
        elif name == &#34;_sampling_schema&#34;:
            self.node_seq._sample_schema = value
        else:
            self.__dict__[name] = value
        return

    def __getattr__(self, name):
        if name == &#34;batch_size&#34;:
            return self.generator.batch_size
        elif name == &#34;data_size&#34;:
            return self.node_seq.data_size
        elif name == &#34;shuffle&#34;:
            return self.node_seq.shuffle
        elif name == &#34;head_node_types&#34;:
            return self.node_seq.head_node_types
        elif name == &#34;_sampling_schema&#34;:
            return self.node_seq._sampling_schema
        elif name == &#34;reset&#34;:
            # stellargraph did not implement reset for its generators
            # return a zero-argument lambda that returns None
            return lambda: None
        elif name == &#34;graph&#34;:
            return self.generator.graph
        else:
            try:
                return self.__dict__[name]
            except:
                raise AttributeError
        return

    def nsamples(self):
        return self.targets.shape[0]

    def get_y(self):
        return self.targets

    def xshape(self):
        return self[0][0][0].shape[1:]  # returns 1st neighborhood only

    def nclasses(self):
        return self[0][1].shape[1]


class LinkSequenceWrapper(link_mappers.LinkSequence, SequenceDataset):
    def __init__(self, link_seq):
        if not isinstance(link_seq, link_mappers.LinkSequence):
            raise ValueError(&#34;link_seq must by a stellargraph LinkSequence object&#34;)
        self.link_seq = link_seq
        self.targets = link_seq.targets
        self.generator = link_seq.generator
        self.ids = link_seq.ids
        self.__len__ = link_seq.__len__
        self.__getitem__ = link_seq.__getitem__
        self.on_epoch_end = link_seq.on_epoch_end
        self.indices = link_seq.indices

    def __setattr__(self, name, value):
        if name == &#34;batch_size&#34;:
            self.generator.batch_size = value
        elif name == &#34;data_size&#34;:
            self.link_seq.data_size = value
        elif name == &#34;shuffle&#34;:
            self.link_seq.shuffle = value
        elif name == &#34;head_node_types&#34;:
            self.link_seq.head_node_types = value
        elif name == &#34;_sampling_schema&#34;:
            self.link_seq._sample_schema = value
        else:
            self.__dict__[name] = value
        return

    def __getattr__(self, name):
        if name == &#34;batch_size&#34;:
            return self.generator.batch_size
        elif name == &#34;data_size&#34;:
            return self.link_seq.data_size
        elif name == &#34;shuffle&#34;:
            return self.link_seq.shuffle
        elif name == &#34;head_node_types&#34;:
            return self.link_seq.head_node_types
        elif name == &#34;_sampling_schema&#34;:
            return self.link_seq._sampling_schema
        elif name == &#34;reset&#34;:
            # stellargraph did not implement reset for its generators
            # return a zero-argument lambda that returns None
            return lambda: None
        elif name == &#34;graph&#34;:
            return self.generator.graph
        else:
            try:
                return self.__dict__[name]
            except:
                raise AttributeError
        return

    def nsamples(self):
        return self.targets.shape[0]

    def get_y(self):
        return self.targets

    def xshape(self):
        return self[0][0][0].shape[1:]  # returns 1st neighborhood only

    def nclasses(self):
        return 2
        return self[0][1].shape[1]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ktrain.graph.sg_wrappers.LinkSequenceWrapper"><code class="flex name class">
<span>class <span class="ident">LinkSequenceWrapper</span></span>
<span>(</span><span>link_seq)</span>
</code></dt>
<dd>
<div class="desc"><p>Keras-compatible data generator to use with Keras methods :meth:<code>keras.Model.fit_generator</code>,
:meth:<code>keras.Model.evaluate_generator</code>, and :meth:<code>keras.Model.predict_generator</code>
This class generates data samples for link inference models
and should be created using the :meth:<code>flow</code> method of
:class:<code>GraphSAGELinkGenerator</code> or :class:<code>HinSAGELinkGenerator</code> or :class:<code>Attri2VecLinkGenerator</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>generator</code></strong></dt>
<dd>An instance of :class:<code>GraphSAGELinkGenerator</code> or :class:<code>HinSAGELinkGenerator</code> or </dd>
<dt>:class:<code>Attri2VecLinkGenerator</code>.</dt>
<dt><strong><code>ids</code></strong> :&ensp;<code>list</code> or <code>iterable</code></dt>
<dd>Link IDs to batch, each link id being a tuple of (src, dst) node ids.
(The graph nodes must have a "feature" attribute that is used as input to the GraphSAGE/Attri2Vec model.)
These are the links that are to be used to train or inference, and the embeddings
calculated for these links via a binary operator applied to their source and destination nodes,
are passed to the downstream task of link prediction or link attribute inference.
The source and target nodes of the links are used as head nodes for which subgraphs are sampled.
The subgraphs are sampled from all nodes.</dd>
<dt><strong><code>targets</code></strong> :&ensp;<code>list</code> or <code>iterable</code></dt>
<dd>Labels corresponding to the above links, e.g., 0 or 1 for the link prediction problem.</dd>
<dt><strong><code>shuffle</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True (default) the ids will be randomly shuffled every epoch.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LinkSequenceWrapper(link_mappers.LinkSequence, SequenceDataset):
    def __init__(self, link_seq):
        if not isinstance(link_seq, link_mappers.LinkSequence):
            raise ValueError(&#34;link_seq must by a stellargraph LinkSequence object&#34;)
        self.link_seq = link_seq
        self.targets = link_seq.targets
        self.generator = link_seq.generator
        self.ids = link_seq.ids
        self.__len__ = link_seq.__len__
        self.__getitem__ = link_seq.__getitem__
        self.on_epoch_end = link_seq.on_epoch_end
        self.indices = link_seq.indices

    def __setattr__(self, name, value):
        if name == &#34;batch_size&#34;:
            self.generator.batch_size = value
        elif name == &#34;data_size&#34;:
            self.link_seq.data_size = value
        elif name == &#34;shuffle&#34;:
            self.link_seq.shuffle = value
        elif name == &#34;head_node_types&#34;:
            self.link_seq.head_node_types = value
        elif name == &#34;_sampling_schema&#34;:
            self.link_seq._sample_schema = value
        else:
            self.__dict__[name] = value
        return

    def __getattr__(self, name):
        if name == &#34;batch_size&#34;:
            return self.generator.batch_size
        elif name == &#34;data_size&#34;:
            return self.link_seq.data_size
        elif name == &#34;shuffle&#34;:
            return self.link_seq.shuffle
        elif name == &#34;head_node_types&#34;:
            return self.link_seq.head_node_types
        elif name == &#34;_sampling_schema&#34;:
            return self.link_seq._sampling_schema
        elif name == &#34;reset&#34;:
            # stellargraph did not implement reset for its generators
            # return a zero-argument lambda that returns None
            return lambda: None
        elif name == &#34;graph&#34;:
            return self.generator.graph
        else:
            try:
                return self.__dict__[name]
            except:
                raise AttributeError
        return

    def nsamples(self):
        return self.targets.shape[0]

    def get_y(self):
        return self.targets

    def xshape(self):
        return self[0][0][0].shape[1:]  # returns 1st neighborhood only

    def nclasses(self):
        return 2
        return self[0][1].shape[1]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>stellargraph.mapper.link_mappers.LinkSequence</li>
<li><a title="ktrain.dataset.SequenceDataset" href="../dataset.html#ktrain.dataset.SequenceDataset">SequenceDataset</a></li>
<li><a title="ktrain.dataset.Dataset" href="../dataset.html#ktrain.dataset.Dataset">Dataset</a></li>
<li>tensorflow.python.keras.utils.data_utils.Sequence</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ktrain.graph.sg_wrappers.LinkSequenceWrapper.get_y"><code class="name flex">
<span>def <span class="ident">get_y</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_y(self):
    return self.targets</code></pre>
</details>
</dd>
<dt id="ktrain.graph.sg_wrappers.LinkSequenceWrapper.nsamples"><code class="name flex">
<span>def <span class="ident">nsamples</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nsamples(self):
    return self.targets.shape[0]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ktrain.dataset.SequenceDataset" href="../dataset.html#ktrain.dataset.SequenceDataset">SequenceDataset</a></b></code>:
<ul class="hlist">
<li><code><a title="ktrain.dataset.SequenceDataset.nclasses" href="../dataset.html#ktrain.dataset.Dataset.nclasses">nclasses</a></code></li>
<li><code><a title="ktrain.dataset.SequenceDataset.ondisk" href="../dataset.html#ktrain.dataset.Dataset.ondisk">ondisk</a></code></li>
<li><code><a title="ktrain.dataset.SequenceDataset.xshape" href="../dataset.html#ktrain.dataset.Dataset.xshape">xshape</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ktrain.graph.sg_wrappers.NodeSequenceWrapper"><code class="flex name class">
<span>class <span class="ident">NodeSequenceWrapper</span></span>
<span>(</span><span>node_seq)</span>
</code></dt>
<dd>
<div class="desc"><p>Keras-compatible data generator to use with the Keras
methods :meth:<code>keras.Model.fit_generator</code>, :meth:<code>keras.Model.evaluate_generator</code>,
and :meth:<code>keras.Model.predict_generator</code>.</p>
<p>This class generated data samples for node inference models
and should be created using the <code>.flow(&hellip;)</code> method of
:class:<code>GraphSAGENodeGenerator</code> or :class:<code>DirectedGraphSAGENodeGenerator</code>
or :class:<code>HinSAGENodeGenerator</code> or :class:<code>Attri2VecNodeGenerator</code>.</p>
<p>GraphSAGENodeGenerator, DirectedGraphSAGENodeGenerator,and HinSAGENodeGenerator
are classes that capture the graph structure and the feature vectors of each node.
These generator classes are used within the NodeSequence to generate
samples of k-hop neighbourhoods in the graph and to return to this
class the features from the sampled neighbourhoods.</p>
<p>Attri2VecNodeGenerator is the class that captures node feature vectors
of each node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>generator</code></strong></dt>
<dd>GraphSAGENodeGenerator, DirectedGraphSAGENodeGenerator or
HinSAGENodeGenerator or Attri2VecNodeGenerator. The generator object
containing the graph information.</dd>
<dt><strong><code>ids</code></strong></dt>
<dd>list
A list of the node_ids to be used as head-nodes in the
downstream task.</dd>
<dt><strong><code>targets</code></strong></dt>
<dd>list, optional (default=None)
A list of targets or labels to be used in the downstream
class.</dd>
<dt><strong><code>shuffle</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True (default) the ids will be randomly shuffled every epoch.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NodeSequenceWrapper(node_mappers.NodeSequence, SequenceDataset):
    def __init__(self, node_seq):
        if not isinstance(node_seq, node_mappers.NodeSequence):
            raise ValueError(&#34;node_seq must by a stellargraph NodeSequence object&#34;)
        self.node_seq = node_seq
        self.targets = node_seq.targets
        self.generator = node_seq.generator
        self.ids = node_seq.ids
        self.__len__ = node_seq.__len__
        self.__getitem__ = node_seq.__getitem__
        self.on_epoch_end = node_seq.on_epoch_end
        self.indices = node_seq.indices

    def __setattr__(self, name, value):
        if name == &#34;batch_size&#34;:
            self.generator.batch_size = value
        elif name == &#34;data_size&#34;:
            self.node_seq.data_size = value
        elif name == &#34;shuffle&#34;:
            self.node_seq.shuffle = value
        elif name == &#34;head_node_types&#34;:
            self.node_seq.head_node_types = value
        elif name == &#34;_sampling_schema&#34;:
            self.node_seq._sample_schema = value
        else:
            self.__dict__[name] = value
        return

    def __getattr__(self, name):
        if name == &#34;batch_size&#34;:
            return self.generator.batch_size
        elif name == &#34;data_size&#34;:
            return self.node_seq.data_size
        elif name == &#34;shuffle&#34;:
            return self.node_seq.shuffle
        elif name == &#34;head_node_types&#34;:
            return self.node_seq.head_node_types
        elif name == &#34;_sampling_schema&#34;:
            return self.node_seq._sampling_schema
        elif name == &#34;reset&#34;:
            # stellargraph did not implement reset for its generators
            # return a zero-argument lambda that returns None
            return lambda: None
        elif name == &#34;graph&#34;:
            return self.generator.graph
        else:
            try:
                return self.__dict__[name]
            except:
                raise AttributeError
        return

    def nsamples(self):
        return self.targets.shape[0]

    def get_y(self):
        return self.targets

    def xshape(self):
        return self[0][0][0].shape[1:]  # returns 1st neighborhood only

    def nclasses(self):
        return self[0][1].shape[1]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>stellargraph.mapper.node_mappers.NodeSequence</li>
<li><a title="ktrain.dataset.SequenceDataset" href="../dataset.html#ktrain.dataset.SequenceDataset">SequenceDataset</a></li>
<li><a title="ktrain.dataset.Dataset" href="../dataset.html#ktrain.dataset.Dataset">Dataset</a></li>
<li>tensorflow.python.keras.utils.data_utils.Sequence</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ktrain.graph.sg_wrappers.NodeSequenceWrapper.get_y"><code class="name flex">
<span>def <span class="ident">get_y</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_y(self):
    return self.targets</code></pre>
</details>
</dd>
<dt id="ktrain.graph.sg_wrappers.NodeSequenceWrapper.nsamples"><code class="name flex">
<span>def <span class="ident">nsamples</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nsamples(self):
    return self.targets.shape[0]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ktrain.dataset.SequenceDataset" href="../dataset.html#ktrain.dataset.SequenceDataset">SequenceDataset</a></b></code>:
<ul class="hlist">
<li><code><a title="ktrain.dataset.SequenceDataset.nclasses" href="../dataset.html#ktrain.dataset.Dataset.nclasses">nclasses</a></code></li>
<li><code><a title="ktrain.dataset.SequenceDataset.ondisk" href="../dataset.html#ktrain.dataset.Dataset.ondisk">ondisk</a></code></li>
<li><code><a title="ktrain.dataset.SequenceDataset.xshape" href="../dataset.html#ktrain.dataset.Dataset.xshape">xshape</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ktrain.graph" href="index.html">ktrain.graph</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ktrain.graph.sg_wrappers.LinkSequenceWrapper" href="#ktrain.graph.sg_wrappers.LinkSequenceWrapper">LinkSequenceWrapper</a></code></h4>
<ul class="">
<li><code><a title="ktrain.graph.sg_wrappers.LinkSequenceWrapper.get_y" href="#ktrain.graph.sg_wrappers.LinkSequenceWrapper.get_y">get_y</a></code></li>
<li><code><a title="ktrain.graph.sg_wrappers.LinkSequenceWrapper.nsamples" href="#ktrain.graph.sg_wrappers.LinkSequenceWrapper.nsamples">nsamples</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ktrain.graph.sg_wrappers.NodeSequenceWrapper" href="#ktrain.graph.sg_wrappers.NodeSequenceWrapper">NodeSequenceWrapper</a></code></h4>
<ul class="">
<li><code><a title="ktrain.graph.sg_wrappers.NodeSequenceWrapper.get_y" href="#ktrain.graph.sg_wrappers.NodeSequenceWrapper.get_y">get_y</a></code></li>
<li><code><a title="ktrain.graph.sg_wrappers.NodeSequenceWrapper.nsamples" href="#ktrain.graph.sg_wrappers.NodeSequenceWrapper.nsamples">nsamples</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>