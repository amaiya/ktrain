<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>ktrain.tabular.predictor API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ktrain.tabular.predictor</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from .. import utils as U
from ..imports import *
from ..predictor import Predictor
from .preprocessor import TabularPreprocessor


class TabularPredictor(Predictor):
    &#34;&#34;&#34;
    ```
    predictions for tabular data
    ```
    &#34;&#34;&#34;

    def __init__(self, model, preproc, batch_size=U.DEFAULT_BS):

        if not isinstance(model, keras.Model):
            raise ValueError(&#34;model must be of instance keras.Model&#34;)
        if (
            not isinstance(preproc, TabularPreprocessor)
            and type(preproc).__name__ != &#34;TabularPreprocessor&#34;
        ):
            raise ValueError(&#34;preproc must be a TabularPreprocessor object&#34;)
        self.model = model
        self.preproc = preproc
        self.c = self.preproc.get_classes()
        self.batch_size = batch_size

    def get_classes(self):
        return self.c

    def predict(self, df, return_proba=False):
        &#34;&#34;&#34;
        ```
        Makes predictions for a test dataframe
        Args:
          df(pd.DataFrame):  a pandas DataFrame in same format as DataFrame used for training model
          return_proba(bool): If True, return probabilities instead of predicted class labels
        ```
        &#34;&#34;&#34;
        if not isinstance(df, pd.DataFrame):
            raise ValueError(&#34;df must be a pd.DataFrame&#34;)
        df = df.copy()

        classification, multilabel = U.is_classifier(self.model)

        # get predictions
        tseq = self.preproc.preprocess_test(df, verbose=0)
        tseq.batch_size = self.batch_size
        preds = self.model.predict(tseq)
        result = (
            preds
            if return_proba or multilabel or not self.c
            else [self.c[np.argmax(pred)] for pred in preds]
        )
        if multilabel and not return_proba:
            result = [list(zip(self.c, r)) for r in result]
        return result

    def _predict_shap(self, X):
        n_cats = len(self.preproc.cat_names)
        n_conts = len(self.preproc.cont_names)

        # reformat for model
        batch_x = [X[:, i : i + 1] for i in range(n_cats)] + [X[:, -n_conts:]]
        result = self.model.predict(batch_x)
        return result

    def explain(
        self,
        test_df,
        row_index=None,
        row_num=None,
        class_id=None,
        background_size=50,
        nsamples=500,
    ):
        &#34;&#34;&#34;
        ```
        Explain the prediction of an example using SHAP.
        Args:
          df(pd.DataFrame): a pd.DataFrame of test data is same format as original training data DataFrame
                            The DataFrame does NOT need to contain all the original label columns
                            (e.g., the Survived column in Kaggle&#39;s Titatnic dataset) but  MUST contain
                            all the original predictor columns (e.g., un-normalized numerical variables, categorical
                            variables as strings).
          row_index(int): index of row in DataFrame to explain (e.g., PassengerID in Titanic dataset).
                          mutually-exclusive with row_id
          row_num(int): raw row number in DataFrame to explain (i.e., 0=first row, 1=second rows, etc.)
                         mutually-exclusive with row_index
          class_id(int): Only required for classification
          background_size(int): size of background data (SHAP parameter)
          nsamples(int): number of samples (SHAP parameter)
        ```
        &#34;&#34;&#34;
        try:
            import shap
        except ImportError:
            msg = (
                &#34;TabularPredictor.explain requires shap library. Please install with: pip install shap. &#34;
                + &#34;Conda users should use this command instead: conda install -c conda-forge shap&#34;
            )
            warnings.warn(msg)
            return

        classification, multilabel = U.is_classifier(self.model)
        if classification and class_id is None:
            raise ValueError(
                &#34;For classification models, please supply the class_id of the class you would like to explain.&#34;
                + &#34;It should be an index into the list returned by predictor.get_classes().&#34;
            )

        f = self._predict_shap

        # prune dataframe
        df_display = test_df.copy()
        df_display = df_display[self.preproc.pc]

        # add synthetic labels
        for lab in self.preproc.lc:
            df_display[lab] = np.zeros(df_display.shape[0], dtype=int)

        # convert DataFrame to TabularDataset with processed/normalized independent variables
        tabseq = self.preproc.preprocess_test(df_display, verbose=0)
        tabseq.batch_size = df_display.shape[0]
        df = pd.DataFrame(
            data=np.concatenate(tabseq[0][0], axis=1),
            columns=tabseq.cat_columns + tabseq.cont_columns,
            index=df_display.index,
        )

        # add new auto-engineered feature columns
        for col in [self.preproc.na_names + self.preproc.date_names]:
            df_display[col] = df[col]

        # sort display df correctly
        df_display = df_display[tabseq.cat_columns + tabseq.cont_columns]

        # select row
        if row_num is not None and row_index is not None:
            raise ValueError(
                &#34;row_num and row_index are mutually exclusive with eachother.&#34;
            )

        if row_index is not None:
            df_row = df[df.index.isin([row_index])].iloc[0, :]
            df_display_row = df_display[df_display.index.isin([row_index])].iloc[0, :]
            r_key = &#34;row_index&#34; if df.index.name is None else df.index.name
            r_val = row_index
        elif row_num is not None:
            df_row = df.iloc[row_num, :]
            df_display_row = df_display.iloc[row_num, :]
            r_key = &#34;row_num&#34;
            r_val = row_num
        # print(df_row)
        # print(df_display_row)

        # shap
        explainer = shap.KernelExplainer(f, df.iloc[:background_size, :])
        shap_values = explainer.shap_values(df_row, nsamples=nsamples, l1_reg=&#34;aic&#34;)
        expected_value = explainer.expected_value

        if not np.issubdtype(type(explainer.expected_value), np.floating):
            expected_value = explainer.expected_value[
                0 if class_id is None else class_id
            ]
        if type(shap_values) == list:
            shap_values = shap_values[0 if class_id is None else class_id]

        if classification:
            print(
                &#34;Explanation for class = %s (%s=%s): &#34;
                % (self.get_classes()[class_id], r_key, r_val)
            )
        plt.show(
            shap.force_plot(
                expected_value, shap_values, df_display_row, matplotlib=True
            )
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ktrain.tabular.predictor.TabularPredictor"><code class="flex name class">
<span>class <span class="ident">TabularPredictor</span></span>
<span>(</span><span>model, preproc, batch_size=32)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>predictions for tabular data
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TabularPredictor(Predictor):
    &#34;&#34;&#34;
    ```
    predictions for tabular data
    ```
    &#34;&#34;&#34;

    def __init__(self, model, preproc, batch_size=U.DEFAULT_BS):

        if not isinstance(model, keras.Model):
            raise ValueError(&#34;model must be of instance keras.Model&#34;)
        if (
            not isinstance(preproc, TabularPreprocessor)
            and type(preproc).__name__ != &#34;TabularPreprocessor&#34;
        ):
            raise ValueError(&#34;preproc must be a TabularPreprocessor object&#34;)
        self.model = model
        self.preproc = preproc
        self.c = self.preproc.get_classes()
        self.batch_size = batch_size

    def get_classes(self):
        return self.c

    def predict(self, df, return_proba=False):
        &#34;&#34;&#34;
        ```
        Makes predictions for a test dataframe
        Args:
          df(pd.DataFrame):  a pandas DataFrame in same format as DataFrame used for training model
          return_proba(bool): If True, return probabilities instead of predicted class labels
        ```
        &#34;&#34;&#34;
        if not isinstance(df, pd.DataFrame):
            raise ValueError(&#34;df must be a pd.DataFrame&#34;)
        df = df.copy()

        classification, multilabel = U.is_classifier(self.model)

        # get predictions
        tseq = self.preproc.preprocess_test(df, verbose=0)
        tseq.batch_size = self.batch_size
        preds = self.model.predict(tseq)
        result = (
            preds
            if return_proba or multilabel or not self.c
            else [self.c[np.argmax(pred)] for pred in preds]
        )
        if multilabel and not return_proba:
            result = [list(zip(self.c, r)) for r in result]
        return result

    def _predict_shap(self, X):
        n_cats = len(self.preproc.cat_names)
        n_conts = len(self.preproc.cont_names)

        # reformat for model
        batch_x = [X[:, i : i + 1] for i in range(n_cats)] + [X[:, -n_conts:]]
        result = self.model.predict(batch_x)
        return result

    def explain(
        self,
        test_df,
        row_index=None,
        row_num=None,
        class_id=None,
        background_size=50,
        nsamples=500,
    ):
        &#34;&#34;&#34;
        ```
        Explain the prediction of an example using SHAP.
        Args:
          df(pd.DataFrame): a pd.DataFrame of test data is same format as original training data DataFrame
                            The DataFrame does NOT need to contain all the original label columns
                            (e.g., the Survived column in Kaggle&#39;s Titatnic dataset) but  MUST contain
                            all the original predictor columns (e.g., un-normalized numerical variables, categorical
                            variables as strings).
          row_index(int): index of row in DataFrame to explain (e.g., PassengerID in Titanic dataset).
                          mutually-exclusive with row_id
          row_num(int): raw row number in DataFrame to explain (i.e., 0=first row, 1=second rows, etc.)
                         mutually-exclusive with row_index
          class_id(int): Only required for classification
          background_size(int): size of background data (SHAP parameter)
          nsamples(int): number of samples (SHAP parameter)
        ```
        &#34;&#34;&#34;
        try:
            import shap
        except ImportError:
            msg = (
                &#34;TabularPredictor.explain requires shap library. Please install with: pip install shap. &#34;
                + &#34;Conda users should use this command instead: conda install -c conda-forge shap&#34;
            )
            warnings.warn(msg)
            return

        classification, multilabel = U.is_classifier(self.model)
        if classification and class_id is None:
            raise ValueError(
                &#34;For classification models, please supply the class_id of the class you would like to explain.&#34;
                + &#34;It should be an index into the list returned by predictor.get_classes().&#34;
            )

        f = self._predict_shap

        # prune dataframe
        df_display = test_df.copy()
        df_display = df_display[self.preproc.pc]

        # add synthetic labels
        for lab in self.preproc.lc:
            df_display[lab] = np.zeros(df_display.shape[0], dtype=int)

        # convert DataFrame to TabularDataset with processed/normalized independent variables
        tabseq = self.preproc.preprocess_test(df_display, verbose=0)
        tabseq.batch_size = df_display.shape[0]
        df = pd.DataFrame(
            data=np.concatenate(tabseq[0][0], axis=1),
            columns=tabseq.cat_columns + tabseq.cont_columns,
            index=df_display.index,
        )

        # add new auto-engineered feature columns
        for col in [self.preproc.na_names + self.preproc.date_names]:
            df_display[col] = df[col]

        # sort display df correctly
        df_display = df_display[tabseq.cat_columns + tabseq.cont_columns]

        # select row
        if row_num is not None and row_index is not None:
            raise ValueError(
                &#34;row_num and row_index are mutually exclusive with eachother.&#34;
            )

        if row_index is not None:
            df_row = df[df.index.isin([row_index])].iloc[0, :]
            df_display_row = df_display[df_display.index.isin([row_index])].iloc[0, :]
            r_key = &#34;row_index&#34; if df.index.name is None else df.index.name
            r_val = row_index
        elif row_num is not None:
            df_row = df.iloc[row_num, :]
            df_display_row = df_display.iloc[row_num, :]
            r_key = &#34;row_num&#34;
            r_val = row_num
        # print(df_row)
        # print(df_display_row)

        # shap
        explainer = shap.KernelExplainer(f, df.iloc[:background_size, :])
        shap_values = explainer.shap_values(df_row, nsamples=nsamples, l1_reg=&#34;aic&#34;)
        expected_value = explainer.expected_value

        if not np.issubdtype(type(explainer.expected_value), np.floating):
            expected_value = explainer.expected_value[
                0 if class_id is None else class_id
            ]
        if type(shap_values) == list:
            shap_values = shap_values[0 if class_id is None else class_id]

        if classification:
            print(
                &#34;Explanation for class = %s (%s=%s): &#34;
                % (self.get_classes()[class_id], r_key, r_val)
            )
        plt.show(
            shap.force_plot(
                expected_value, shap_values, df_display_row, matplotlib=True
            )
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ktrain.predictor.Predictor" href="../predictor.html#ktrain.predictor.Predictor">Predictor</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ktrain.tabular.predictor.TabularPredictor.explain"><code class="name flex">
<span>def <span class="ident">explain</span></span>(<span>self, test_df, row_index=None, row_num=None, class_id=None, background_size=50, nsamples=500)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>Explain the prediction of an example using SHAP.
Args:
  df(pd.DataFrame): a pd.DataFrame of test data is same format as original training data DataFrame
                    The DataFrame does NOT need to contain all the original label columns
                    (e.g., the Survived column in Kaggle's Titatnic dataset) but  MUST contain
                    all the original predictor columns (e.g., un-normalized numerical variables, categorical
                    variables as strings).
  row_index(int): index of row in DataFrame to explain (e.g., PassengerID in Titanic dataset).
                  mutually-exclusive with row_id
  row_num(int): raw row number in DataFrame to explain (i.e., 0=first row, 1=second rows, etc.)
                 mutually-exclusive with row_index
  class_id(int): Only required for classification
  background_size(int): size of background data (SHAP parameter)
  nsamples(int): number of samples (SHAP parameter)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def explain(
    self,
    test_df,
    row_index=None,
    row_num=None,
    class_id=None,
    background_size=50,
    nsamples=500,
):
    &#34;&#34;&#34;
    ```
    Explain the prediction of an example using SHAP.
    Args:
      df(pd.DataFrame): a pd.DataFrame of test data is same format as original training data DataFrame
                        The DataFrame does NOT need to contain all the original label columns
                        (e.g., the Survived column in Kaggle&#39;s Titatnic dataset) but  MUST contain
                        all the original predictor columns (e.g., un-normalized numerical variables, categorical
                        variables as strings).
      row_index(int): index of row in DataFrame to explain (e.g., PassengerID in Titanic dataset).
                      mutually-exclusive with row_id
      row_num(int): raw row number in DataFrame to explain (i.e., 0=first row, 1=second rows, etc.)
                     mutually-exclusive with row_index
      class_id(int): Only required for classification
      background_size(int): size of background data (SHAP parameter)
      nsamples(int): number of samples (SHAP parameter)
    ```
    &#34;&#34;&#34;
    try:
        import shap
    except ImportError:
        msg = (
            &#34;TabularPredictor.explain requires shap library. Please install with: pip install shap. &#34;
            + &#34;Conda users should use this command instead: conda install -c conda-forge shap&#34;
        )
        warnings.warn(msg)
        return

    classification, multilabel = U.is_classifier(self.model)
    if classification and class_id is None:
        raise ValueError(
            &#34;For classification models, please supply the class_id of the class you would like to explain.&#34;
            + &#34;It should be an index into the list returned by predictor.get_classes().&#34;
        )

    f = self._predict_shap

    # prune dataframe
    df_display = test_df.copy()
    df_display = df_display[self.preproc.pc]

    # add synthetic labels
    for lab in self.preproc.lc:
        df_display[lab] = np.zeros(df_display.shape[0], dtype=int)

    # convert DataFrame to TabularDataset with processed/normalized independent variables
    tabseq = self.preproc.preprocess_test(df_display, verbose=0)
    tabseq.batch_size = df_display.shape[0]
    df = pd.DataFrame(
        data=np.concatenate(tabseq[0][0], axis=1),
        columns=tabseq.cat_columns + tabseq.cont_columns,
        index=df_display.index,
    )

    # add new auto-engineered feature columns
    for col in [self.preproc.na_names + self.preproc.date_names]:
        df_display[col] = df[col]

    # sort display df correctly
    df_display = df_display[tabseq.cat_columns + tabseq.cont_columns]

    # select row
    if row_num is not None and row_index is not None:
        raise ValueError(
            &#34;row_num and row_index are mutually exclusive with eachother.&#34;
        )

    if row_index is not None:
        df_row = df[df.index.isin([row_index])].iloc[0, :]
        df_display_row = df_display[df_display.index.isin([row_index])].iloc[0, :]
        r_key = &#34;row_index&#34; if df.index.name is None else df.index.name
        r_val = row_index
    elif row_num is not None:
        df_row = df.iloc[row_num, :]
        df_display_row = df_display.iloc[row_num, :]
        r_key = &#34;row_num&#34;
        r_val = row_num
    # print(df_row)
    # print(df_display_row)

    # shap
    explainer = shap.KernelExplainer(f, df.iloc[:background_size, :])
    shap_values = explainer.shap_values(df_row, nsamples=nsamples, l1_reg=&#34;aic&#34;)
    expected_value = explainer.expected_value

    if not np.issubdtype(type(explainer.expected_value), np.floating):
        expected_value = explainer.expected_value[
            0 if class_id is None else class_id
        ]
    if type(shap_values) == list:
        shap_values = shap_values[0 if class_id is None else class_id]

    if classification:
        print(
            &#34;Explanation for class = %s (%s=%s): &#34;
            % (self.get_classes()[class_id], r_key, r_val)
        )
    plt.show(
        shap.force_plot(
            expected_value, shap_values, df_display_row, matplotlib=True
        )
    )</code></pre>
</details>
</dd>
<dt id="ktrain.tabular.predictor.TabularPredictor.get_classes"><code class="name flex">
<span>def <span class="ident">get_classes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_classes(self):
    return self.c</code></pre>
</details>
</dd>
<dt id="ktrain.tabular.predictor.TabularPredictor.predict"><code class="name flex">
<span>def <span class="ident">predict</span></span>(<span>self, df, return_proba=False)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>Makes predictions for a test dataframe
Args:
  df(pd.DataFrame):  a pandas DataFrame in same format as DataFrame used for training model
  return_proba(bool): If True, return probabilities instead of predicted class labels
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predict(self, df, return_proba=False):
    &#34;&#34;&#34;
    ```
    Makes predictions for a test dataframe
    Args:
      df(pd.DataFrame):  a pandas DataFrame in same format as DataFrame used for training model
      return_proba(bool): If True, return probabilities instead of predicted class labels
    ```
    &#34;&#34;&#34;
    if not isinstance(df, pd.DataFrame):
        raise ValueError(&#34;df must be a pd.DataFrame&#34;)
    df = df.copy()

    classification, multilabel = U.is_classifier(self.model)

    # get predictions
    tseq = self.preproc.preprocess_test(df, verbose=0)
    tseq.batch_size = self.batch_size
    preds = self.model.predict(tseq)
    result = (
        preds
        if return_proba or multilabel or not self.c
        else [self.c[np.argmax(pred)] for pred in preds]
    )
    if multilabel and not return_proba:
        result = [list(zip(self.c, r)) for r in result]
    return result</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ktrain.predictor.Predictor" href="../predictor.html#ktrain.predictor.Predictor">Predictor</a></b></code>:
<ul class="hlist">
<li><code><a title="ktrain.predictor.Predictor.create_onnx_session" href="../predictor.html#ktrain.predictor.Predictor.create_onnx_session">create_onnx_session</a></code></li>
<li><code><a title="ktrain.predictor.Predictor.export_model_to_onnx" href="../predictor.html#ktrain.predictor.Predictor.export_model_to_onnx">export_model_to_onnx</a></code></li>
<li><code><a title="ktrain.predictor.Predictor.export_model_to_tflite" href="../predictor.html#ktrain.predictor.Predictor.export_model_to_tflite">export_model_to_tflite</a></code></li>
<li><code><a title="ktrain.predictor.Predictor.save" href="../predictor.html#ktrain.predictor.Predictor.save">save</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ktrain.tabular" href="index.html">ktrain.tabular</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ktrain.tabular.predictor.TabularPredictor" href="#ktrain.tabular.predictor.TabularPredictor">TabularPredictor</a></code></h4>
<ul class="">
<li><code><a title="ktrain.tabular.predictor.TabularPredictor.explain" href="#ktrain.tabular.predictor.TabularPredictor.explain">explain</a></code></li>
<li><code><a title="ktrain.tabular.predictor.TabularPredictor.get_classes" href="#ktrain.tabular.predictor.TabularPredictor.get_classes">get_classes</a></code></li>
<li><code><a title="ktrain.tabular.predictor.TabularPredictor.predict" href="#ktrain.tabular.predictor.TabularPredictor.predict">predict</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>