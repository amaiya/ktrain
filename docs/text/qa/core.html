<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>ktrain.text.qa.core API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ktrain.text.qa.core</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from ...imports import *
from ... import utils as U
from .. import textutils as TU
from .. import preprocessor as tpp


from whoosh import index
from whoosh.fields import *
from whoosh import qparser
from whoosh.qparser import QueryParser


#from transformers import TFBertForQuestionAnswering
#from transformers import BertTokenizer
from transformers import TFAutoModelForQuestionAnswering
from transformers import AutoTokenizer
LOWCONF = -10000

def _answers2df(answers):
    dfdata = []
    for a in answers:
        answer_text = a[&#39;answer&#39;]
        snippet_html = &#39;&lt;div&gt;&#39; +a[&#39;sentence_beginning&#39;] + &#34; &lt;font color=&#39;red&#39;&gt;&#34;+a[&#39;answer&#39;]+&#34;&lt;/font&gt; &#34;+a[&#39;sentence_end&#39;]+&#39;&lt;/div&gt;&#39;
        confidence = a[&#39;confidence&#39;]
        doc_key = a[&#39;reference&#39;]
        dfdata.append([answer_text, snippet_html, confidence, doc_key])
    df = pd.DataFrame(dfdata, columns = [&#39;Candidate Answer&#39;, &#39;Context&#39;,  &#39;Confidence&#39;, &#39;Document Reference&#39;])
    if &#34;\t&#34; in answers[0][&#39;reference&#39;]:
        df[&#39;Document Reference&#39;] = df[&#39;Document Reference&#39;].apply(lambda x: &#39;&lt;a href=&#34;{}&#34; target=&#34;_blank&#34;&gt;{}&lt;/a&gt;&#39;.format(x.split(&#39;\t&#39;)[1], x.split(&#39;\t&#39;)[0]))
    return df



def display_answers(answers):
    if not answers: return
    df = _answers2df(answers)
    from IPython.core.display import display, HTML
    return display(HTML(df.to_html(render_links=True, escape=False)))


def _process_question(question, include_np=False):
    if include_np:
        try:
            # attempt to use extract_noun_phrases first if textblob is installed
            np_list = [&#39;&#34;%s&#34;&#39; % (np) for np in TU.extract_noun_phrases(question) if len(np.split()) &gt; 1]
            q_tokens = TU.tokenize(question, join_tokens=False)
            q_tokens.extend(np_list)
            return &#34; &#34;.join(q_tokens)
        except:
            import warnings
            warnings.warn(&#39;TextBlob is not currently installed, so falling back to include_np=False with no extra question processing. &#39;+\
                          &#39;To install: pip install textblob&#39;)
            return TU.tokenize(question, join_tokens=True)
    else:
        return TU.tokenize(question, join_tokens=True)



class QA(ABC):
    &#34;&#34;&#34;
    Base class for QA
    &#34;&#34;&#34;

    def __init__(self, bert_squad_model=&#39;bert-large-uncased-whole-word-masking-finetuned-squad&#39;,
                 bert_emb_model=&#39;bert-base-uncased&#39;):
        self.model_name = bert_squad_model
        try:
            self.model = TFAutoModelForQuestionAnswering.from_pretrained(self.model_name)
        except:
            self.model = TFAutoModelForQuestionAnswering.from_pretrained(self.model_name, from_pt=True)
        self.tokenizer = AutoTokenizer.from_pretrained(self.model_name)
        self.maxlen = 512
        self.te = tpp.TransformerEmbedding(bert_emb_model, layers=[-2])


    @abstractmethod
    def search(self, query):
        pass

    def predict_squad(self, documents, question):
        &#34;&#34;&#34; 
        Generates candidate answers to the &lt;question&gt; provided given &lt;documents&gt; as contexts.
        &#34;&#34;&#34;
        if isinstance(documents, str): documents = [documents]
        sequences = [[question, d] for d in documents]
        batch = self.tokenizer.batch_encode_plus(sequences, return_tensors=&#39;tf&#39;, max_length=512, truncation=&#39;only_second&#39;, padding=True)
        tokens_batch = list( map(self.tokenizer.convert_ids_to_tokens, batch[&#39;input_ids&#39;]))

        # Added from: https://github.com/huggingface/transformers/commit/16ce15ed4bd0865d24a94aa839a44cf0f400ef50
        if U.get_hf_model_name(self.model_name) in  [&#39;xlm&#39;, &#39;roberta&#39;, &#39;distilbert&#39;]:
           start_scores, end_scores = self.model(batch[&#39;input_ids&#39;], attention_mask=batch[&#39;attention_mask&#39;], return_dict=False)
        else:
           start_scores, end_scores = self.model(batch[&#39;input_ids&#39;], attention_mask=batch[&#39;attention_mask&#39;], 
                                                 token_type_ids=batch[&#39;token_type_ids&#39;], return_dict=False)
        start_scores = start_scores[:,1:-1]
        end_scores = end_scores[:,1:-1]
        answer_starts = np.argmax(start_scores, axis=1)
        answer_ends = np.argmax(end_scores, axis=1)

        answers = []
        for i, tokens in enumerate(tokens_batch):
            answer_start = answer_starts[i]
            answer_end = answer_ends[i]
            answer = self._reconstruct_text(tokens, answer_start, answer_end+2)
            if answer.startswith(&#39;. &#39;) or answer.startswith(&#39;, &#39;):
                answer = answer[2:]  
            sep_index = tokens.index(&#39;[SEP]&#39;)
            full_txt_tokens = tokens[sep_index+1:]
            paragraph_bert = self._reconstruct_text(full_txt_tokens)

            ans={}
            ans[&#39;answer&#39;] = answer
            if answer.startswith(&#39;[CLS]&#39;) or answer_end &lt; sep_index or answer.endswith(&#39;[SEP]&#39;):
                ans[&#39;confidence&#39;] = LOWCONF
            else:
                #confidence = torch.max(start_scores) + torch.max(end_scores)
                #confidence = np.log(confidence.item())
                ans[&#39;confidence&#39;] = start_scores[i,answer_start]+end_scores[i,answer_end]
            ans[&#39;start&#39;] = answer_start
            ans[&#39;end&#39;] = answer_end
            ans[&#39;context&#39;] = paragraph_bert
            answers.append(ans)
        #if len(answers) == 1: answers = answers[0]
        return answers




    def _reconstruct_text(self, tokens, start=0, stop=-1):
        &#34;&#34;&#34;
        Reconstruct text of *either* question or answer
        &#34;&#34;&#34;
        tokens = tokens[start: stop]
        #if &#39;[SEP]&#39; in tokens:
            #sepind = tokens.index(&#39;[SEP]&#39;)
            #tokens = tokens[sepind+1:]
        txt = &#39; &#39;.join(tokens)
        txt = txt.replace(&#39;[SEP]&#39;, &#39;&#39;) # added for batch_encode_plus - removes [SEP] before [PAD]
        txt = txt.replace(&#39;[PAD]&#39;, &#39;&#39;) # added for batch_encode_plus - removes [PAD]
        txt = txt.replace(&#39; ##&#39;, &#39;&#39;)
        txt = txt.replace(&#39;##&#39;, &#39;&#39;)
        txt = txt.strip()
        txt = &#34; &#34;.join(txt.split())
        txt = txt.replace(&#39; .&#39;, &#39;.&#39;)
        txt = txt.replace(&#39;( &#39;, &#39;(&#39;)
        txt = txt.replace(&#39; )&#39;, &#39;)&#39;)
        txt = txt.replace(&#39; - &#39;, &#39;-&#39;)
        txt_list = txt.split(&#39; , &#39;)
        txt = &#39;&#39;
        length = len(txt_list)
        if length == 1:
            return txt_list[0]
        new_list =[]
        for i,t in enumerate(txt_list):
            if i &lt; length -1:
                if t[-1].isdigit() and txt_list[i+1][0].isdigit():
                    new_list += [t,&#39;,&#39;]
                else:
                    new_list += [t, &#39;, &#39;]
            else:
                new_list += [t]
        return &#39;&#39;.join(new_list)


    def _expand_answer(self, answer):
        &#34;&#34;&#34;
        expand answer to include more of the context
        &#34;&#34;&#34;
        full_abs = answer[&#39;context&#39;]
        bert_ans = answer[&#39;answer&#39;]
        split_abs = full_abs.split(bert_ans)
        sent_beginning = split_abs[0][split_abs[0].rfind(&#39;.&#39;)+1:]
        if len(split_abs) == 1:
            sent_end_pos = len(full_abs)
            sent_end =&#39;&#39;
        else:
            sent_end_pos = split_abs[1].find(&#39;. &#39;)+1
            if sent_end_pos == 0:
                sent_end = split_abs[1]
            else:
                sent_end = split_abs[1][:sent_end_pos]
            
        answer[&#39;full_answer&#39;] = sent_beginning+bert_ans+sent_end
        answer[&#39;full_answer&#39;] = answer[&#39;full_answer&#39;].strip()
        answer[&#39;sentence_beginning&#39;] = sent_beginning
        answer[&#39;sentence_end&#39;] = sent_end
        return answer



    def ask(self, question, batch_size=8, n_docs_considered=10, n_answers=50, 
            rerank_threshold=0.015, include_np=False):
        &#34;&#34;&#34;
        ```
        submit question to obtain candidate answers

        Args:
          question(str): question in the form of a string
          batch_size(int):  number of question-context pairs fed to model at each iteration
                            Default:8
                            Increase for faster answer-retrieval.
                            Decrease to reduce memory (if out-of-memory errors occur).
          n_docs_considered(int): number of top search results that will
                                  be searched for answer
                                  default:10
          n_answers(int): maximum number of candidate answers to return
                          default:50
          rerank_threshold(int): rerank top answers with confidence &gt;= rerank_threshold
                                 based on semantic similarity between question and answer.
                                 This can help bump the correct answer closer to the top.
                                 default:0.015.
                                 If None, no re-ranking is performed.
          include_np(bool):  If True, noun phrases will be extracted from question and included
                             in query that retrieves documents likely to contain candidate answers.
                             This may be useful if you ask a question about artificial intelligence
                             and the answers returned pertain just to intelligence, for example.
                             Note: include_np=True requires textblob be installed.
                             Default:False
        Returns:
          list
        ```
        &#34;&#34;&#34;
        # locate candidate document contexts
        paragraphs = []
        refs = []
        #doc_results = self.search(question, limit=n_docs_considered)
        doc_results = self.search(_process_question(question, include_np=include_np), limit=n_docs_considered)
        if not doc_results: 
            warnings.warn(&#39;No documents matched words in question&#39;)
            return []
        # extract paragraphs as contexts
        contexts = []
        refs = []
        for doc_result in doc_results:
            rawtext = doc_result.get(&#39;rawtext&#39;, &#39;&#39;)
            reference = doc_result.get(&#39;reference&#39;, &#39;&#39;)
            if len(self.tokenizer.tokenize(rawtext)) &lt; self.maxlen:
                contexts.append(rawtext)
                refs.append(reference)
            else:
                paragraphs = TU.paragraph_tokenize(rawtext, join_sentences=True)
                contexts.extend(paragraphs)
                refs.extend([reference] * len(paragraphs))


        #for doc_result in doc_results:
            #rawtext = doc_result.get(&#39;rawtext&#39;, &#39;&#39;)
            #reference = doc_result.get(&#39;reference&#39;, &#39;&#39;)
            #if len(self.tokenizer.tokenize(rawtext)) &lt; self.maxlen:
                #paragraphs.append(rawtext)
                #refs.append(reference)
                #continue
            #plist = TU.paragraph_tokenize(rawtext, join_sentences=True)
            #paragraphs.extend(plist)
            #refs.extend([reference]*len(plist))


        # batchify contexts
        #return contexts
        if batch_size  &gt; len(contexts): batch_size = len(contexts)
        #if len(contexts) &gt;= 100 and batch_size==8:
            #warnings.warn(&#39;TIP: Try increasing batch_size to speedup ask predictions&#39;)
        num_chunks = math.ceil(len(contexts)/batch_size)
        context_batches = list( U.list2chunks(contexts, n=num_chunks) )


        # locate candidate answers
        answers = []
        mb = master_bar(range(1))
        answer_batches = []
        for i in mb:
            idx = 0
            for batch_id, contexts in enumerate(progress_bar(context_batches, parent=mb)):
                answer_batch = self.predict_squad(contexts, question)
                answer_batches.extend(answer_batch)
                for answer in answer_batch:
                    idx+=1
                    if not answer[&#39;answer&#39;] or answer[&#39;confidence&#39;] &lt;-100: continue
                    answer[&#39;confidence&#39;] = answer[&#39;confidence&#39;].numpy()
                    answer[&#39;reference&#39;] = refs[idx-1]
                    answer = self._expand_answer(answer)
                    answers.append(answer)

                mb.child.comment = f&#39;generating candidate answers&#39;

        if not answers: return answers # fix for #307
        answers = sorted(answers, key = lambda k:k[&#39;confidence&#39;], reverse=True)
        if n_answers is not None:
            answers = answers[:n_answers]

        # transform confidence scores
        confidences = [a[&#39;confidence&#39;] for a in answers]
        max_conf = max(confidences)
        total = 0.0
        exp_scores = []
        for c in confidences:
            s = np.exp(c-max_conf)
            exp_scores.append(s)
        total = sum(exp_scores)
        for idx,c in enumerate(confidences):
            answers[idx][&#39;confidence&#39;] = exp_scores[idx]/total

        if rerank_threshold is None:
            return answers

        # re-rank
        top_confidences = [a[&#39;confidence&#39;] for idx, a in enumerate(answers) if a[&#39;confidence&#39;]&gt; rerank_threshold]
        v1 = self.te.embed(question, word_level=False)
        for idx, answer in enumerate(answers):
            #if idx &gt;= rerank_top_n: 
            if answer[&#39;confidence&#39;] &lt;= rerank_threshold:
                answer[&#39;similarity_score&#39;] = 0.0
                continue
            v2 = self.te.embed(answer[&#39;full_answer&#39;], word_level=False)
            score = v1 @ v2.T / (np.linalg.norm(v1)*np.linalg.norm(v2))
            answer[&#39;similarity_score&#39;] = float(np.squeeze(score))
            answer[&#39;confidence&#39;] = top_confidences[idx]
        answers = sorted(answers, key = lambda k:(k[&#39;similarity_score&#39;], k[&#39;confidence&#39;]), reverse=True)
        for idx, confidence in enumerate(top_confidences):
            answers[idx][&#39;confidence&#39;] = confidence


        return answers


    def display_answers(self, answers):
        return display_answers(answers)



class SimpleQA(QA):
    &#34;&#34;&#34;
    SimpleQA: Question-Answering on a list of texts
    &#34;&#34;&#34;
    def __init__(self, index_dir, 
                 bert_squad_model=&#39;bert-large-uncased-whole-word-masking-finetuned-squad&#39;,
                 bert_emb_model=&#39;bert-base-uncased&#39;):
        &#34;&#34;&#34;
        ```
        SimpleQA constructor
        Args:
          index_dir(str):  path to index directory created by SimpleQA.initialze_index
          bert_squad_model(str): name of BERT SQUAD model to use
          bert_emb_model(str): BERT model to use to generate embeddings for semantic similarity
        ```
        &#34;&#34;&#34;

        self.index_dir = index_dir
        try:
            ix = index.open_dir(self.index_dir)
        except:
            raise ValueError(&#39;index_dir has not yet been created - please call SimpleQA.initialize_index(&#34;%s&#34;)&#39; % (self.index_dir))
        super().__init__(bert_squad_model=bert_squad_model, bert_emb_model=bert_emb_model)


    def _open_ix(self):
        return index.open_dir(self.index_dir)


    @classmethod
    def initialize_index(cls, index_dir):
        schema = Schema(reference=ID(stored=True), content=TEXT, rawtext=TEXT(stored=True))
        if not os.path.exists(index_dir):
            os.makedirs(index_dir)
        else:
            raise ValueError(&#39;There is already an existing directory or file with path %s&#39; % (index_dir))
        ix = index.create_in(index_dir, schema)
        return ix

    @classmethod
    def index_from_list(cls, docs, index_dir, commit_every=1024, breakup_docs=True,
                        procs=1, limitmb=256, multisegment=False, min_words=20, references=None):
        &#34;&#34;&#34;
        ```
        index documents from list.
        The procs, limitmb, and especially multisegment arguments can be used to 
        speed up indexing, if it is too slow.  Please see the whoosh documentation
        for more information on these parameters:  https://whoosh.readthedocs.io/en/latest/batch.html
        Args:
          docs(list): list of strings representing documents
          index_dir(str): path to index directory (see initialize_index)
          commit_every(int): commet after adding this many documents
          breakup_docs(bool): break up documents into smaller paragraphs and treat those as the documents.
                              This can potentially improve the speed at which answers are returned by the ask method
                              when documents being searched are longer.
          procs(int): number of processors
          limitmb(int): memory limit in MB for each process
          multisegment(bool): new segments written instead of merging
          min_words(int):  minimum words for a document (or paragraph extracted from document when breakup_docs=True) to be included in index.
                           Useful for pruning contexts that are unlikely to contain useful answers
          references(list): List of strings containing a reference (e.g., file name) for each document in docs.
                            Each string is treated as a label for the document (e.g., file name, MD5 hash, etc.):
                               Example:  [&#39;some_file.pdf&#39;, &#39;some_other_file,pdf&#39;, ...]
                            Strings can also be hyperlinks in which case the label and URL should be separated by a single tab character:
                               Example: [&#39;ktrain_article\thttps://arxiv.org/pdf/2004.10703v4.pdf&#39;, ...]

                            These references will be returned in the output of the ask method.
                            If strings are  hyperlinks, then they will automatically be made clickable when the display_answers function
                            displays candidate answers in a pandas DataFRame.

                            If references is None, the index of element in docs is used as reference.
        ```
        &#34;&#34;&#34;
        if not isinstance(docs, (np.ndarray, list)): raise ValueError(&#39;docs must be a list of strings&#39;)
        if references is not None and not isinstance(references, (np.ndarray, list)): raise ValueError(&#39;references must be a list of strings&#39;)
        if references is not None and len(references) != len(docs): raise ValueError(&#39;lengths of docs and references must be equal&#39;)

        ix = index.open_dir(index_dir)
        writer = ix.writer(procs=procs, limitmb=limitmb, multisegment=multisegment)

        mb = master_bar(range(1))
        for i in mb:
            for idx, doc in enumerate(progress_bar(docs, parent=mb)):
                reference = &#34;%s&#34; % (idx) if references is None else references[idx]

                if breakup_docs:
                    small_docs = TU.paragraph_tokenize(doc, join_sentences=True, lang=&#39;en&#39;)
                    refs = [reference] * len(small_docs)
                    for i, small_doc in enumerate(small_docs):
                        if len(small_doc.split()) &lt; min_words: continue
                        content = small_doc
                        reference = refs[i]
                        writer.add_document(reference=reference, content=content, rawtext=content)
                else:
                    if len(doc.split()) &lt; min_words: continue
                    content = doc 
                    writer.add_document(reference=reference, content=content, rawtext=content)

                idx +=1
                if idx % commit_every == 0:
                    writer.commit()
                    #writer = ix.writer()
                    writer = ix.writer(procs=procs, limitmb=limitmb, multisegment=multisegment)
                mb.child.comment = f&#39;indexing documents&#39;
            writer.commit()
            #mb.write(f&#39;Finished indexing documents&#39;)
        return


    @classmethod
    def index_from_folder(cls, folder_path, index_dir,  use_text_extraction=False, commit_every=1024, breakup_docs=True, 
                          min_words=20, encoding=&#39;utf-8&#39;, procs=1, limitmb=256, multisegment=False, verbose=1):
        &#34;&#34;&#34;
        ```
        index all plain text documents within a folder.
        The procs, limitmb, and especially multisegment arguments can be used to 
        speed up indexing, if it is too slow.  Please see the whoosh documentation
        for more information on these parameters:  https://whoosh.readthedocs.io/en/latest/batch.html

        Args:
          folder_path(str): path to folder containing plain text documents (e.g., .txt files)
          index_dir(str): path to index directory (see initialize_index)
          use_text_extraction(bool): If True, the  `textract` package will be used to index text from various
                                     file types including PDF, MS Word, and MS PowerPoint (in addition to plain text files).
                                     If False, only plain text files will be indexed.
          commit_every(int): commet after adding this many documents
          breakup_docs(bool): break up documents into smaller paragraphs and treat those as the documents.
                              This can potentially improve the speed at which answers are returned by the ask method
                              when documents being searched are longer.
          min_words(int):  minimum words for a document (or paragraph extracted from document when breakup_docs=True) to be included in index.
                           Useful for pruning contexts that are unlikely to contain useful answers
          encoding(str): encoding to use when reading document files from disk
          procs(int): number of processors
          limitmb(int): memory limit in MB for each process
          multisegment(bool): new segments written instead of merging
          verbose(bool): verbosity
        ```
        &#34;&#34;&#34;
        if use_text_extraction:
            try:
                import textract
            except ImportError:
                raise Exception(&#39;use_text_extraction=True requires textract:   pip install textract&#39;)


        if not os.path.isdir(folder_path): raise ValueError(&#39;folder_path is not a valid folder&#39;)
        if folder_path[-1] != os.sep: folder_path += os.sep
        ix = index.open_dir(index_dir)
        writer = ix.writer(procs=procs, limitmb=limitmb, multisegment=multisegment)
        for idx, fpath in enumerate(TU.extract_filenames(folder_path)):
            reference = &#34;%s&#34; % (fpath.join(fpath.split(folder_path)[1:]))
            if TU.is_txt(fpath):
                with open(fpath, &#39;r&#39;, encoding=encoding) as f:
                    doc = f.read()
            else:
                if use_text_extraction:
                    try:
                        doc = textract.process(fpath)
                        doc = doc.decode(&#39;utf-8&#39;, &#39;ignore&#39;)
                    except:
                        if verbose:
                            warnings.warn(&#39;Could not extract text from %s&#39; % (fpath))
                        continue
                else:
                    continue

            if breakup_docs:
                small_docs = TU.paragraph_tokenize(doc, join_sentences=True, lang=&#39;en&#39;)
                refs = [reference] * len(small_docs)
                for i, small_doc in enumerate(small_docs):
                    if len(small_doc.split()) &lt; min_words: continue
                    content = small_doc
                    reference = refs[i]
                    writer.add_document(reference=reference, content=content, rawtext=content)
            else:
                if len(doc.split()) &lt; min_words: continue
                content = doc
                writer.add_document(reference=reference, content=content, rawtext=content)

            idx +=1
            if idx % commit_every == 0:
                writer.commit()
                writer = ix.writer(procs=procs, limitmb=limitmb, multisegment=multisegment)
                if verbose: print(&#34;%s docs indexed&#34; % (idx))
        writer.commit()
        return


    def search(self, query, limit=10):
        &#34;&#34;&#34;
        ```
        search index for query
        Args:
          query(str): search query
          limit(int):  number of top search results to return
        Returns:
          list of dicts with keys: reference, rawtext
        ```
        &#34;&#34;&#34;
        ix = self._open_ix()
        with ix.searcher() as searcher:
            query_obj = QueryParser(&#34;content&#34;, ix.schema, group=qparser.OrGroup).parse(query)
            results = searcher.search(query_obj, limit=limit)
            docs = []
            output = [dict(r) for r in results]
            return output</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ktrain.text.qa.core.display_answers"><code class="name flex">
<span>def <span class="ident">display_answers</span></span>(<span>answers)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_answers(answers):
    if not answers: return
    df = _answers2df(answers)
    from IPython.core.display import display, HTML
    return display(HTML(df.to_html(render_links=True, escape=False)))</code></pre>
</details>
</dd>
<dt id="ktrain.text.qa.core.pack_byte"><code class="name flex">
<span>def <span class="ident">pack_byte</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>S.pack(v1, v2, &hellip;) -&gt; bytes</p>
<p>Return a bytes object containing values v1, v2, &hellip; packed according
to the format string S.format.
See help(struct) for more on format
strings.</p></div>
</dd>
<dt id="ktrain.text.qa.core.unpack_byte"><code class="name flex">
<span>def <span class="ident">unpack_byte</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>S.unpack(buffer) -&gt; (v1, v2, &hellip;)</p>
<p>Return a tuple containing values unpacked according to the format
string S.format.
The buffer's size in bytes must be S.size.
See
help(struct) for more on format strings.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ktrain.text.qa.core.QA"><code class="flex name class">
<span>class <span class="ident">QA</span></span>
<span>(</span><span>bert_squad_model='bert-large-uncased-whole-word-masking-finetuned-squad', bert_emb_model='bert-base-uncased')</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for QA</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class QA(ABC):
    &#34;&#34;&#34;
    Base class for QA
    &#34;&#34;&#34;

    def __init__(self, bert_squad_model=&#39;bert-large-uncased-whole-word-masking-finetuned-squad&#39;,
                 bert_emb_model=&#39;bert-base-uncased&#39;):
        self.model_name = bert_squad_model
        try:
            self.model = TFAutoModelForQuestionAnswering.from_pretrained(self.model_name)
        except:
            self.model = TFAutoModelForQuestionAnswering.from_pretrained(self.model_name, from_pt=True)
        self.tokenizer = AutoTokenizer.from_pretrained(self.model_name)
        self.maxlen = 512
        self.te = tpp.TransformerEmbedding(bert_emb_model, layers=[-2])


    @abstractmethod
    def search(self, query):
        pass

    def predict_squad(self, documents, question):
        &#34;&#34;&#34; 
        Generates candidate answers to the &lt;question&gt; provided given &lt;documents&gt; as contexts.
        &#34;&#34;&#34;
        if isinstance(documents, str): documents = [documents]
        sequences = [[question, d] for d in documents]
        batch = self.tokenizer.batch_encode_plus(sequences, return_tensors=&#39;tf&#39;, max_length=512, truncation=&#39;only_second&#39;, padding=True)
        tokens_batch = list( map(self.tokenizer.convert_ids_to_tokens, batch[&#39;input_ids&#39;]))

        # Added from: https://github.com/huggingface/transformers/commit/16ce15ed4bd0865d24a94aa839a44cf0f400ef50
        if U.get_hf_model_name(self.model_name) in  [&#39;xlm&#39;, &#39;roberta&#39;, &#39;distilbert&#39;]:
           start_scores, end_scores = self.model(batch[&#39;input_ids&#39;], attention_mask=batch[&#39;attention_mask&#39;], return_dict=False)
        else:
           start_scores, end_scores = self.model(batch[&#39;input_ids&#39;], attention_mask=batch[&#39;attention_mask&#39;], 
                                                 token_type_ids=batch[&#39;token_type_ids&#39;], return_dict=False)
        start_scores = start_scores[:,1:-1]
        end_scores = end_scores[:,1:-1]
        answer_starts = np.argmax(start_scores, axis=1)
        answer_ends = np.argmax(end_scores, axis=1)

        answers = []
        for i, tokens in enumerate(tokens_batch):
            answer_start = answer_starts[i]
            answer_end = answer_ends[i]
            answer = self._reconstruct_text(tokens, answer_start, answer_end+2)
            if answer.startswith(&#39;. &#39;) or answer.startswith(&#39;, &#39;):
                answer = answer[2:]  
            sep_index = tokens.index(&#39;[SEP]&#39;)
            full_txt_tokens = tokens[sep_index+1:]
            paragraph_bert = self._reconstruct_text(full_txt_tokens)

            ans={}
            ans[&#39;answer&#39;] = answer
            if answer.startswith(&#39;[CLS]&#39;) or answer_end &lt; sep_index or answer.endswith(&#39;[SEP]&#39;):
                ans[&#39;confidence&#39;] = LOWCONF
            else:
                #confidence = torch.max(start_scores) + torch.max(end_scores)
                #confidence = np.log(confidence.item())
                ans[&#39;confidence&#39;] = start_scores[i,answer_start]+end_scores[i,answer_end]
            ans[&#39;start&#39;] = answer_start
            ans[&#39;end&#39;] = answer_end
            ans[&#39;context&#39;] = paragraph_bert
            answers.append(ans)
        #if len(answers) == 1: answers = answers[0]
        return answers




    def _reconstruct_text(self, tokens, start=0, stop=-1):
        &#34;&#34;&#34;
        Reconstruct text of *either* question or answer
        &#34;&#34;&#34;
        tokens = tokens[start: stop]
        #if &#39;[SEP]&#39; in tokens:
            #sepind = tokens.index(&#39;[SEP]&#39;)
            #tokens = tokens[sepind+1:]
        txt = &#39; &#39;.join(tokens)
        txt = txt.replace(&#39;[SEP]&#39;, &#39;&#39;) # added for batch_encode_plus - removes [SEP] before [PAD]
        txt = txt.replace(&#39;[PAD]&#39;, &#39;&#39;) # added for batch_encode_plus - removes [PAD]
        txt = txt.replace(&#39; ##&#39;, &#39;&#39;)
        txt = txt.replace(&#39;##&#39;, &#39;&#39;)
        txt = txt.strip()
        txt = &#34; &#34;.join(txt.split())
        txt = txt.replace(&#39; .&#39;, &#39;.&#39;)
        txt = txt.replace(&#39;( &#39;, &#39;(&#39;)
        txt = txt.replace(&#39; )&#39;, &#39;)&#39;)
        txt = txt.replace(&#39; - &#39;, &#39;-&#39;)
        txt_list = txt.split(&#39; , &#39;)
        txt = &#39;&#39;
        length = len(txt_list)
        if length == 1:
            return txt_list[0]
        new_list =[]
        for i,t in enumerate(txt_list):
            if i &lt; length -1:
                if t[-1].isdigit() and txt_list[i+1][0].isdigit():
                    new_list += [t,&#39;,&#39;]
                else:
                    new_list += [t, &#39;, &#39;]
            else:
                new_list += [t]
        return &#39;&#39;.join(new_list)


    def _expand_answer(self, answer):
        &#34;&#34;&#34;
        expand answer to include more of the context
        &#34;&#34;&#34;
        full_abs = answer[&#39;context&#39;]
        bert_ans = answer[&#39;answer&#39;]
        split_abs = full_abs.split(bert_ans)
        sent_beginning = split_abs[0][split_abs[0].rfind(&#39;.&#39;)+1:]
        if len(split_abs) == 1:
            sent_end_pos = len(full_abs)
            sent_end =&#39;&#39;
        else:
            sent_end_pos = split_abs[1].find(&#39;. &#39;)+1
            if sent_end_pos == 0:
                sent_end = split_abs[1]
            else:
                sent_end = split_abs[1][:sent_end_pos]
            
        answer[&#39;full_answer&#39;] = sent_beginning+bert_ans+sent_end
        answer[&#39;full_answer&#39;] = answer[&#39;full_answer&#39;].strip()
        answer[&#39;sentence_beginning&#39;] = sent_beginning
        answer[&#39;sentence_end&#39;] = sent_end
        return answer



    def ask(self, question, batch_size=8, n_docs_considered=10, n_answers=50, 
            rerank_threshold=0.015, include_np=False):
        &#34;&#34;&#34;
        ```
        submit question to obtain candidate answers

        Args:
          question(str): question in the form of a string
          batch_size(int):  number of question-context pairs fed to model at each iteration
                            Default:8
                            Increase for faster answer-retrieval.
                            Decrease to reduce memory (if out-of-memory errors occur).
          n_docs_considered(int): number of top search results that will
                                  be searched for answer
                                  default:10
          n_answers(int): maximum number of candidate answers to return
                          default:50
          rerank_threshold(int): rerank top answers with confidence &gt;= rerank_threshold
                                 based on semantic similarity between question and answer.
                                 This can help bump the correct answer closer to the top.
                                 default:0.015.
                                 If None, no re-ranking is performed.
          include_np(bool):  If True, noun phrases will be extracted from question and included
                             in query that retrieves documents likely to contain candidate answers.
                             This may be useful if you ask a question about artificial intelligence
                             and the answers returned pertain just to intelligence, for example.
                             Note: include_np=True requires textblob be installed.
                             Default:False
        Returns:
          list
        ```
        &#34;&#34;&#34;
        # locate candidate document contexts
        paragraphs = []
        refs = []
        #doc_results = self.search(question, limit=n_docs_considered)
        doc_results = self.search(_process_question(question, include_np=include_np), limit=n_docs_considered)
        if not doc_results: 
            warnings.warn(&#39;No documents matched words in question&#39;)
            return []
        # extract paragraphs as contexts
        contexts = []
        refs = []
        for doc_result in doc_results:
            rawtext = doc_result.get(&#39;rawtext&#39;, &#39;&#39;)
            reference = doc_result.get(&#39;reference&#39;, &#39;&#39;)
            if len(self.tokenizer.tokenize(rawtext)) &lt; self.maxlen:
                contexts.append(rawtext)
                refs.append(reference)
            else:
                paragraphs = TU.paragraph_tokenize(rawtext, join_sentences=True)
                contexts.extend(paragraphs)
                refs.extend([reference] * len(paragraphs))


        #for doc_result in doc_results:
            #rawtext = doc_result.get(&#39;rawtext&#39;, &#39;&#39;)
            #reference = doc_result.get(&#39;reference&#39;, &#39;&#39;)
            #if len(self.tokenizer.tokenize(rawtext)) &lt; self.maxlen:
                #paragraphs.append(rawtext)
                #refs.append(reference)
                #continue
            #plist = TU.paragraph_tokenize(rawtext, join_sentences=True)
            #paragraphs.extend(plist)
            #refs.extend([reference]*len(plist))


        # batchify contexts
        #return contexts
        if batch_size  &gt; len(contexts): batch_size = len(contexts)
        #if len(contexts) &gt;= 100 and batch_size==8:
            #warnings.warn(&#39;TIP: Try increasing batch_size to speedup ask predictions&#39;)
        num_chunks = math.ceil(len(contexts)/batch_size)
        context_batches = list( U.list2chunks(contexts, n=num_chunks) )


        # locate candidate answers
        answers = []
        mb = master_bar(range(1))
        answer_batches = []
        for i in mb:
            idx = 0
            for batch_id, contexts in enumerate(progress_bar(context_batches, parent=mb)):
                answer_batch = self.predict_squad(contexts, question)
                answer_batches.extend(answer_batch)
                for answer in answer_batch:
                    idx+=1
                    if not answer[&#39;answer&#39;] or answer[&#39;confidence&#39;] &lt;-100: continue
                    answer[&#39;confidence&#39;] = answer[&#39;confidence&#39;].numpy()
                    answer[&#39;reference&#39;] = refs[idx-1]
                    answer = self._expand_answer(answer)
                    answers.append(answer)

                mb.child.comment = f&#39;generating candidate answers&#39;

        if not answers: return answers # fix for #307
        answers = sorted(answers, key = lambda k:k[&#39;confidence&#39;], reverse=True)
        if n_answers is not None:
            answers = answers[:n_answers]

        # transform confidence scores
        confidences = [a[&#39;confidence&#39;] for a in answers]
        max_conf = max(confidences)
        total = 0.0
        exp_scores = []
        for c in confidences:
            s = np.exp(c-max_conf)
            exp_scores.append(s)
        total = sum(exp_scores)
        for idx,c in enumerate(confidences):
            answers[idx][&#39;confidence&#39;] = exp_scores[idx]/total

        if rerank_threshold is None:
            return answers

        # re-rank
        top_confidences = [a[&#39;confidence&#39;] for idx, a in enumerate(answers) if a[&#39;confidence&#39;]&gt; rerank_threshold]
        v1 = self.te.embed(question, word_level=False)
        for idx, answer in enumerate(answers):
            #if idx &gt;= rerank_top_n: 
            if answer[&#39;confidence&#39;] &lt;= rerank_threshold:
                answer[&#39;similarity_score&#39;] = 0.0
                continue
            v2 = self.te.embed(answer[&#39;full_answer&#39;], word_level=False)
            score = v1 @ v2.T / (np.linalg.norm(v1)*np.linalg.norm(v2))
            answer[&#39;similarity_score&#39;] = float(np.squeeze(score))
            answer[&#39;confidence&#39;] = top_confidences[idx]
        answers = sorted(answers, key = lambda k:(k[&#39;similarity_score&#39;], k[&#39;confidence&#39;]), reverse=True)
        for idx, confidence in enumerate(top_confidences):
            answers[idx][&#39;confidence&#39;] = confidence


        return answers


    def display_answers(self, answers):
        return display_answers(answers)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ktrain.text.qa.core.SimpleQA" href="#ktrain.text.qa.core.SimpleQA">SimpleQA</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ktrain.text.qa.core.QA.ask"><code class="name flex">
<span>def <span class="ident">ask</span></span>(<span>self, question, batch_size=8, n_docs_considered=10, n_answers=50, rerank_threshold=0.015, include_np=False)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>submit question to obtain candidate answers

Args:
  question(str): question in the form of a string
  batch_size(int):  number of question-context pairs fed to model at each iteration
                    Default:8
                    Increase for faster answer-retrieval.
                    Decrease to reduce memory (if out-of-memory errors occur).
  n_docs_considered(int): number of top search results that will
                          be searched for answer
                          default:10
  n_answers(int): maximum number of candidate answers to return
                  default:50
  rerank_threshold(int): rerank top answers with confidence &gt;= rerank_threshold
                         based on semantic similarity between question and answer.
                         This can help bump the correct answer closer to the top.
                         default:0.015.
                         If None, no re-ranking is performed.
  include_np(bool):  If True, noun phrases will be extracted from question and included
                     in query that retrieves documents likely to contain candidate answers.
                     This may be useful if you ask a question about artificial intelligence
                     and the answers returned pertain just to intelligence, for example.
                     Note: include_np=True requires textblob be installed.
                     Default:False
Returns:
  list
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ask(self, question, batch_size=8, n_docs_considered=10, n_answers=50, 
        rerank_threshold=0.015, include_np=False):
    &#34;&#34;&#34;
    ```
    submit question to obtain candidate answers

    Args:
      question(str): question in the form of a string
      batch_size(int):  number of question-context pairs fed to model at each iteration
                        Default:8
                        Increase for faster answer-retrieval.
                        Decrease to reduce memory (if out-of-memory errors occur).
      n_docs_considered(int): number of top search results that will
                              be searched for answer
                              default:10
      n_answers(int): maximum number of candidate answers to return
                      default:50
      rerank_threshold(int): rerank top answers with confidence &gt;= rerank_threshold
                             based on semantic similarity between question and answer.
                             This can help bump the correct answer closer to the top.
                             default:0.015.
                             If None, no re-ranking is performed.
      include_np(bool):  If True, noun phrases will be extracted from question and included
                         in query that retrieves documents likely to contain candidate answers.
                         This may be useful if you ask a question about artificial intelligence
                         and the answers returned pertain just to intelligence, for example.
                         Note: include_np=True requires textblob be installed.
                         Default:False
    Returns:
      list
    ```
    &#34;&#34;&#34;
    # locate candidate document contexts
    paragraphs = []
    refs = []
    #doc_results = self.search(question, limit=n_docs_considered)
    doc_results = self.search(_process_question(question, include_np=include_np), limit=n_docs_considered)
    if not doc_results: 
        warnings.warn(&#39;No documents matched words in question&#39;)
        return []
    # extract paragraphs as contexts
    contexts = []
    refs = []
    for doc_result in doc_results:
        rawtext = doc_result.get(&#39;rawtext&#39;, &#39;&#39;)
        reference = doc_result.get(&#39;reference&#39;, &#39;&#39;)
        if len(self.tokenizer.tokenize(rawtext)) &lt; self.maxlen:
            contexts.append(rawtext)
            refs.append(reference)
        else:
            paragraphs = TU.paragraph_tokenize(rawtext, join_sentences=True)
            contexts.extend(paragraphs)
            refs.extend([reference] * len(paragraphs))


    #for doc_result in doc_results:
        #rawtext = doc_result.get(&#39;rawtext&#39;, &#39;&#39;)
        #reference = doc_result.get(&#39;reference&#39;, &#39;&#39;)
        #if len(self.tokenizer.tokenize(rawtext)) &lt; self.maxlen:
            #paragraphs.append(rawtext)
            #refs.append(reference)
            #continue
        #plist = TU.paragraph_tokenize(rawtext, join_sentences=True)
        #paragraphs.extend(plist)
        #refs.extend([reference]*len(plist))


    # batchify contexts
    #return contexts
    if batch_size  &gt; len(contexts): batch_size = len(contexts)
    #if len(contexts) &gt;= 100 and batch_size==8:
        #warnings.warn(&#39;TIP: Try increasing batch_size to speedup ask predictions&#39;)
    num_chunks = math.ceil(len(contexts)/batch_size)
    context_batches = list( U.list2chunks(contexts, n=num_chunks) )


    # locate candidate answers
    answers = []
    mb = master_bar(range(1))
    answer_batches = []
    for i in mb:
        idx = 0
        for batch_id, contexts in enumerate(progress_bar(context_batches, parent=mb)):
            answer_batch = self.predict_squad(contexts, question)
            answer_batches.extend(answer_batch)
            for answer in answer_batch:
                idx+=1
                if not answer[&#39;answer&#39;] or answer[&#39;confidence&#39;] &lt;-100: continue
                answer[&#39;confidence&#39;] = answer[&#39;confidence&#39;].numpy()
                answer[&#39;reference&#39;] = refs[idx-1]
                answer = self._expand_answer(answer)
                answers.append(answer)

            mb.child.comment = f&#39;generating candidate answers&#39;

    if not answers: return answers # fix for #307
    answers = sorted(answers, key = lambda k:k[&#39;confidence&#39;], reverse=True)
    if n_answers is not None:
        answers = answers[:n_answers]

    # transform confidence scores
    confidences = [a[&#39;confidence&#39;] for a in answers]
    max_conf = max(confidences)
    total = 0.0
    exp_scores = []
    for c in confidences:
        s = np.exp(c-max_conf)
        exp_scores.append(s)
    total = sum(exp_scores)
    for idx,c in enumerate(confidences):
        answers[idx][&#39;confidence&#39;] = exp_scores[idx]/total

    if rerank_threshold is None:
        return answers

    # re-rank
    top_confidences = [a[&#39;confidence&#39;] for idx, a in enumerate(answers) if a[&#39;confidence&#39;]&gt; rerank_threshold]
    v1 = self.te.embed(question, word_level=False)
    for idx, answer in enumerate(answers):
        #if idx &gt;= rerank_top_n: 
        if answer[&#39;confidence&#39;] &lt;= rerank_threshold:
            answer[&#39;similarity_score&#39;] = 0.0
            continue
        v2 = self.te.embed(answer[&#39;full_answer&#39;], word_level=False)
        score = v1 @ v2.T / (np.linalg.norm(v1)*np.linalg.norm(v2))
        answer[&#39;similarity_score&#39;] = float(np.squeeze(score))
        answer[&#39;confidence&#39;] = top_confidences[idx]
    answers = sorted(answers, key = lambda k:(k[&#39;similarity_score&#39;], k[&#39;confidence&#39;]), reverse=True)
    for idx, confidence in enumerate(top_confidences):
        answers[idx][&#39;confidence&#39;] = confidence


    return answers</code></pre>
</details>
</dd>
<dt id="ktrain.text.qa.core.QA.display_answers"><code class="name flex">
<span>def <span class="ident">display_answers</span></span>(<span>self, answers)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_answers(self, answers):
    return display_answers(answers)</code></pre>
</details>
</dd>
<dt id="ktrain.text.qa.core.QA.predict_squad"><code class="name flex">
<span>def <span class="ident">predict_squad</span></span>(<span>self, documents, question)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates candidate answers to the <question> provided given <documents> as contexts.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predict_squad(self, documents, question):
    &#34;&#34;&#34; 
    Generates candidate answers to the &lt;question&gt; provided given &lt;documents&gt; as contexts.
    &#34;&#34;&#34;
    if isinstance(documents, str): documents = [documents]
    sequences = [[question, d] for d in documents]
    batch = self.tokenizer.batch_encode_plus(sequences, return_tensors=&#39;tf&#39;, max_length=512, truncation=&#39;only_second&#39;, padding=True)
    tokens_batch = list( map(self.tokenizer.convert_ids_to_tokens, batch[&#39;input_ids&#39;]))

    # Added from: https://github.com/huggingface/transformers/commit/16ce15ed4bd0865d24a94aa839a44cf0f400ef50
    if U.get_hf_model_name(self.model_name) in  [&#39;xlm&#39;, &#39;roberta&#39;, &#39;distilbert&#39;]:
       start_scores, end_scores = self.model(batch[&#39;input_ids&#39;], attention_mask=batch[&#39;attention_mask&#39;], return_dict=False)
    else:
       start_scores, end_scores = self.model(batch[&#39;input_ids&#39;], attention_mask=batch[&#39;attention_mask&#39;], 
                                             token_type_ids=batch[&#39;token_type_ids&#39;], return_dict=False)
    start_scores = start_scores[:,1:-1]
    end_scores = end_scores[:,1:-1]
    answer_starts = np.argmax(start_scores, axis=1)
    answer_ends = np.argmax(end_scores, axis=1)

    answers = []
    for i, tokens in enumerate(tokens_batch):
        answer_start = answer_starts[i]
        answer_end = answer_ends[i]
        answer = self._reconstruct_text(tokens, answer_start, answer_end+2)
        if answer.startswith(&#39;. &#39;) or answer.startswith(&#39;, &#39;):
            answer = answer[2:]  
        sep_index = tokens.index(&#39;[SEP]&#39;)
        full_txt_tokens = tokens[sep_index+1:]
        paragraph_bert = self._reconstruct_text(full_txt_tokens)

        ans={}
        ans[&#39;answer&#39;] = answer
        if answer.startswith(&#39;[CLS]&#39;) or answer_end &lt; sep_index or answer.endswith(&#39;[SEP]&#39;):
            ans[&#39;confidence&#39;] = LOWCONF
        else:
            #confidence = torch.max(start_scores) + torch.max(end_scores)
            #confidence = np.log(confidence.item())
            ans[&#39;confidence&#39;] = start_scores[i,answer_start]+end_scores[i,answer_end]
        ans[&#39;start&#39;] = answer_start
        ans[&#39;end&#39;] = answer_end
        ans[&#39;context&#39;] = paragraph_bert
        answers.append(ans)
    #if len(answers) == 1: answers = answers[0]
    return answers</code></pre>
</details>
</dd>
<dt id="ktrain.text.qa.core.QA.search"><code class="name flex">
<span>def <span class="ident">search</span></span>(<span>self, query)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def search(self, query):
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ktrain.text.qa.core.SimpleQA"><code class="flex name class">
<span>class <span class="ident">SimpleQA</span></span>
<span>(</span><span>index_dir, bert_squad_model='bert-large-uncased-whole-word-masking-finetuned-squad', bert_emb_model='bert-base-uncased')</span>
</code></dt>
<dd>
<div class="desc"><p>SimpleQA: Question-Answering on a list of texts</p>
<pre><code>SimpleQA constructor
Args:
  index_dir(str):  path to index directory created by SimpleQA.initialze_index
  bert_squad_model(str): name of BERT SQUAD model to use
  bert_emb_model(str): BERT model to use to generate embeddings for semantic similarity
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SimpleQA(QA):
    &#34;&#34;&#34;
    SimpleQA: Question-Answering on a list of texts
    &#34;&#34;&#34;
    def __init__(self, index_dir, 
                 bert_squad_model=&#39;bert-large-uncased-whole-word-masking-finetuned-squad&#39;,
                 bert_emb_model=&#39;bert-base-uncased&#39;):
        &#34;&#34;&#34;
        ```
        SimpleQA constructor
        Args:
          index_dir(str):  path to index directory created by SimpleQA.initialze_index
          bert_squad_model(str): name of BERT SQUAD model to use
          bert_emb_model(str): BERT model to use to generate embeddings for semantic similarity
        ```
        &#34;&#34;&#34;

        self.index_dir = index_dir
        try:
            ix = index.open_dir(self.index_dir)
        except:
            raise ValueError(&#39;index_dir has not yet been created - please call SimpleQA.initialize_index(&#34;%s&#34;)&#39; % (self.index_dir))
        super().__init__(bert_squad_model=bert_squad_model, bert_emb_model=bert_emb_model)


    def _open_ix(self):
        return index.open_dir(self.index_dir)


    @classmethod
    def initialize_index(cls, index_dir):
        schema = Schema(reference=ID(stored=True), content=TEXT, rawtext=TEXT(stored=True))
        if not os.path.exists(index_dir):
            os.makedirs(index_dir)
        else:
            raise ValueError(&#39;There is already an existing directory or file with path %s&#39; % (index_dir))
        ix = index.create_in(index_dir, schema)
        return ix

    @classmethod
    def index_from_list(cls, docs, index_dir, commit_every=1024, breakup_docs=True,
                        procs=1, limitmb=256, multisegment=False, min_words=20, references=None):
        &#34;&#34;&#34;
        ```
        index documents from list.
        The procs, limitmb, and especially multisegment arguments can be used to 
        speed up indexing, if it is too slow.  Please see the whoosh documentation
        for more information on these parameters:  https://whoosh.readthedocs.io/en/latest/batch.html
        Args:
          docs(list): list of strings representing documents
          index_dir(str): path to index directory (see initialize_index)
          commit_every(int): commet after adding this many documents
          breakup_docs(bool): break up documents into smaller paragraphs and treat those as the documents.
                              This can potentially improve the speed at which answers are returned by the ask method
                              when documents being searched are longer.
          procs(int): number of processors
          limitmb(int): memory limit in MB for each process
          multisegment(bool): new segments written instead of merging
          min_words(int):  minimum words for a document (or paragraph extracted from document when breakup_docs=True) to be included in index.
                           Useful for pruning contexts that are unlikely to contain useful answers
          references(list): List of strings containing a reference (e.g., file name) for each document in docs.
                            Each string is treated as a label for the document (e.g., file name, MD5 hash, etc.):
                               Example:  [&#39;some_file.pdf&#39;, &#39;some_other_file,pdf&#39;, ...]
                            Strings can also be hyperlinks in which case the label and URL should be separated by a single tab character:
                               Example: [&#39;ktrain_article\thttps://arxiv.org/pdf/2004.10703v4.pdf&#39;, ...]

                            These references will be returned in the output of the ask method.
                            If strings are  hyperlinks, then they will automatically be made clickable when the display_answers function
                            displays candidate answers in a pandas DataFRame.

                            If references is None, the index of element in docs is used as reference.
        ```
        &#34;&#34;&#34;
        if not isinstance(docs, (np.ndarray, list)): raise ValueError(&#39;docs must be a list of strings&#39;)
        if references is not None and not isinstance(references, (np.ndarray, list)): raise ValueError(&#39;references must be a list of strings&#39;)
        if references is not None and len(references) != len(docs): raise ValueError(&#39;lengths of docs and references must be equal&#39;)

        ix = index.open_dir(index_dir)
        writer = ix.writer(procs=procs, limitmb=limitmb, multisegment=multisegment)

        mb = master_bar(range(1))
        for i in mb:
            for idx, doc in enumerate(progress_bar(docs, parent=mb)):
                reference = &#34;%s&#34; % (idx) if references is None else references[idx]

                if breakup_docs:
                    small_docs = TU.paragraph_tokenize(doc, join_sentences=True, lang=&#39;en&#39;)
                    refs = [reference] * len(small_docs)
                    for i, small_doc in enumerate(small_docs):
                        if len(small_doc.split()) &lt; min_words: continue
                        content = small_doc
                        reference = refs[i]
                        writer.add_document(reference=reference, content=content, rawtext=content)
                else:
                    if len(doc.split()) &lt; min_words: continue
                    content = doc 
                    writer.add_document(reference=reference, content=content, rawtext=content)

                idx +=1
                if idx % commit_every == 0:
                    writer.commit()
                    #writer = ix.writer()
                    writer = ix.writer(procs=procs, limitmb=limitmb, multisegment=multisegment)
                mb.child.comment = f&#39;indexing documents&#39;
            writer.commit()
            #mb.write(f&#39;Finished indexing documents&#39;)
        return


    @classmethod
    def index_from_folder(cls, folder_path, index_dir,  use_text_extraction=False, commit_every=1024, breakup_docs=True, 
                          min_words=20, encoding=&#39;utf-8&#39;, procs=1, limitmb=256, multisegment=False, verbose=1):
        &#34;&#34;&#34;
        ```
        index all plain text documents within a folder.
        The procs, limitmb, and especially multisegment arguments can be used to 
        speed up indexing, if it is too slow.  Please see the whoosh documentation
        for more information on these parameters:  https://whoosh.readthedocs.io/en/latest/batch.html

        Args:
          folder_path(str): path to folder containing plain text documents (e.g., .txt files)
          index_dir(str): path to index directory (see initialize_index)
          use_text_extraction(bool): If True, the  `textract` package will be used to index text from various
                                     file types including PDF, MS Word, and MS PowerPoint (in addition to plain text files).
                                     If False, only plain text files will be indexed.
          commit_every(int): commet after adding this many documents
          breakup_docs(bool): break up documents into smaller paragraphs and treat those as the documents.
                              This can potentially improve the speed at which answers are returned by the ask method
                              when documents being searched are longer.
          min_words(int):  minimum words for a document (or paragraph extracted from document when breakup_docs=True) to be included in index.
                           Useful for pruning contexts that are unlikely to contain useful answers
          encoding(str): encoding to use when reading document files from disk
          procs(int): number of processors
          limitmb(int): memory limit in MB for each process
          multisegment(bool): new segments written instead of merging
          verbose(bool): verbosity
        ```
        &#34;&#34;&#34;
        if use_text_extraction:
            try:
                import textract
            except ImportError:
                raise Exception(&#39;use_text_extraction=True requires textract:   pip install textract&#39;)


        if not os.path.isdir(folder_path): raise ValueError(&#39;folder_path is not a valid folder&#39;)
        if folder_path[-1] != os.sep: folder_path += os.sep
        ix = index.open_dir(index_dir)
        writer = ix.writer(procs=procs, limitmb=limitmb, multisegment=multisegment)
        for idx, fpath in enumerate(TU.extract_filenames(folder_path)):
            reference = &#34;%s&#34; % (fpath.join(fpath.split(folder_path)[1:]))
            if TU.is_txt(fpath):
                with open(fpath, &#39;r&#39;, encoding=encoding) as f:
                    doc = f.read()
            else:
                if use_text_extraction:
                    try:
                        doc = textract.process(fpath)
                        doc = doc.decode(&#39;utf-8&#39;, &#39;ignore&#39;)
                    except:
                        if verbose:
                            warnings.warn(&#39;Could not extract text from %s&#39; % (fpath))
                        continue
                else:
                    continue

            if breakup_docs:
                small_docs = TU.paragraph_tokenize(doc, join_sentences=True, lang=&#39;en&#39;)
                refs = [reference] * len(small_docs)
                for i, small_doc in enumerate(small_docs):
                    if len(small_doc.split()) &lt; min_words: continue
                    content = small_doc
                    reference = refs[i]
                    writer.add_document(reference=reference, content=content, rawtext=content)
            else:
                if len(doc.split()) &lt; min_words: continue
                content = doc
                writer.add_document(reference=reference, content=content, rawtext=content)

            idx +=1
            if idx % commit_every == 0:
                writer.commit()
                writer = ix.writer(procs=procs, limitmb=limitmb, multisegment=multisegment)
                if verbose: print(&#34;%s docs indexed&#34; % (idx))
        writer.commit()
        return


    def search(self, query, limit=10):
        &#34;&#34;&#34;
        ```
        search index for query
        Args:
          query(str): search query
          limit(int):  number of top search results to return
        Returns:
          list of dicts with keys: reference, rawtext
        ```
        &#34;&#34;&#34;
        ix = self._open_ix()
        with ix.searcher() as searcher:
            query_obj = QueryParser(&#34;content&#34;, ix.schema, group=qparser.OrGroup).parse(query)
            results = searcher.search(query_obj, limit=limit)
            docs = []
            output = [dict(r) for r in results]
            return output</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ktrain.text.qa.core.QA" href="#ktrain.text.qa.core.QA">QA</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="ktrain.text.qa.core.SimpleQA.index_from_folder"><code class="name flex">
<span>def <span class="ident">index_from_folder</span></span>(<span>folder_path, index_dir, use_text_extraction=False, commit_every=1024, breakup_docs=True, min_words=20, encoding='utf-8', procs=1, limitmb=256, multisegment=False, verbose=1)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>index all plain text documents within a folder.
The procs, limitmb, and especially multisegment arguments can be used to 
speed up indexing, if it is too slow.  Please see the whoosh documentation
for more information on these parameters:  https://whoosh.readthedocs.io/en/latest/batch.html

Args:
  folder_path(str): path to folder containing plain text documents (e.g., .txt files)
  index_dir(str): path to index directory (see initialize_index)
  use_text_extraction(bool): If True, the  `textract` package will be used to index text from various
                             file types including PDF, MS Word, and MS PowerPoint (in addition to plain text files).
                             If False, only plain text files will be indexed.
  commit_every(int): commet after adding this many documents
  breakup_docs(bool): break up documents into smaller paragraphs and treat those as the documents.
                      This can potentially improve the speed at which answers are returned by the ask method
                      when documents being searched are longer.
  min_words(int):  minimum words for a document (or paragraph extracted from document when breakup_docs=True) to be included in index.
                   Useful for pruning contexts that are unlikely to contain useful answers
  encoding(str): encoding to use when reading document files from disk
  procs(int): number of processors
  limitmb(int): memory limit in MB for each process
  multisegment(bool): new segments written instead of merging
  verbose(bool): verbosity
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def index_from_folder(cls, folder_path, index_dir,  use_text_extraction=False, commit_every=1024, breakup_docs=True, 
                      min_words=20, encoding=&#39;utf-8&#39;, procs=1, limitmb=256, multisegment=False, verbose=1):
    &#34;&#34;&#34;
    ```
    index all plain text documents within a folder.
    The procs, limitmb, and especially multisegment arguments can be used to 
    speed up indexing, if it is too slow.  Please see the whoosh documentation
    for more information on these parameters:  https://whoosh.readthedocs.io/en/latest/batch.html

    Args:
      folder_path(str): path to folder containing plain text documents (e.g., .txt files)
      index_dir(str): path to index directory (see initialize_index)
      use_text_extraction(bool): If True, the  `textract` package will be used to index text from various
                                 file types including PDF, MS Word, and MS PowerPoint (in addition to plain text files).
                                 If False, only plain text files will be indexed.
      commit_every(int): commet after adding this many documents
      breakup_docs(bool): break up documents into smaller paragraphs and treat those as the documents.
                          This can potentially improve the speed at which answers are returned by the ask method
                          when documents being searched are longer.
      min_words(int):  minimum words for a document (or paragraph extracted from document when breakup_docs=True) to be included in index.
                       Useful for pruning contexts that are unlikely to contain useful answers
      encoding(str): encoding to use when reading document files from disk
      procs(int): number of processors
      limitmb(int): memory limit in MB for each process
      multisegment(bool): new segments written instead of merging
      verbose(bool): verbosity
    ```
    &#34;&#34;&#34;
    if use_text_extraction:
        try:
            import textract
        except ImportError:
            raise Exception(&#39;use_text_extraction=True requires textract:   pip install textract&#39;)


    if not os.path.isdir(folder_path): raise ValueError(&#39;folder_path is not a valid folder&#39;)
    if folder_path[-1] != os.sep: folder_path += os.sep
    ix = index.open_dir(index_dir)
    writer = ix.writer(procs=procs, limitmb=limitmb, multisegment=multisegment)
    for idx, fpath in enumerate(TU.extract_filenames(folder_path)):
        reference = &#34;%s&#34; % (fpath.join(fpath.split(folder_path)[1:]))
        if TU.is_txt(fpath):
            with open(fpath, &#39;r&#39;, encoding=encoding) as f:
                doc = f.read()
        else:
            if use_text_extraction:
                try:
                    doc = textract.process(fpath)
                    doc = doc.decode(&#39;utf-8&#39;, &#39;ignore&#39;)
                except:
                    if verbose:
                        warnings.warn(&#39;Could not extract text from %s&#39; % (fpath))
                    continue
            else:
                continue

        if breakup_docs:
            small_docs = TU.paragraph_tokenize(doc, join_sentences=True, lang=&#39;en&#39;)
            refs = [reference] * len(small_docs)
            for i, small_doc in enumerate(small_docs):
                if len(small_doc.split()) &lt; min_words: continue
                content = small_doc
                reference = refs[i]
                writer.add_document(reference=reference, content=content, rawtext=content)
        else:
            if len(doc.split()) &lt; min_words: continue
            content = doc
            writer.add_document(reference=reference, content=content, rawtext=content)

        idx +=1
        if idx % commit_every == 0:
            writer.commit()
            writer = ix.writer(procs=procs, limitmb=limitmb, multisegment=multisegment)
            if verbose: print(&#34;%s docs indexed&#34; % (idx))
    writer.commit()
    return</code></pre>
</details>
</dd>
<dt id="ktrain.text.qa.core.SimpleQA.index_from_list"><code class="name flex">
<span>def <span class="ident">index_from_list</span></span>(<span>docs, index_dir, commit_every=1024, breakup_docs=True, procs=1, limitmb=256, multisegment=False, min_words=20, references=None)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>index documents from list.
The procs, limitmb, and especially multisegment arguments can be used to 
speed up indexing, if it is too slow.  Please see the whoosh documentation
for more information on these parameters:  https://whoosh.readthedocs.io/en/latest/batch.html
Args:
  docs(list): list of strings representing documents
  index_dir(str): path to index directory (see initialize_index)
  commit_every(int): commet after adding this many documents
  breakup_docs(bool): break up documents into smaller paragraphs and treat those as the documents.
                      This can potentially improve the speed at which answers are returned by the ask method
                      when documents being searched are longer.
  procs(int): number of processors
  limitmb(int): memory limit in MB for each process
  multisegment(bool): new segments written instead of merging
  min_words(int):  minimum words for a document (or paragraph extracted from document when breakup_docs=True) to be included in index.
                   Useful for pruning contexts that are unlikely to contain useful answers
  references(list): List of strings containing a reference (e.g., file name) for each document in docs.
                    Each string is treated as a label for the document (e.g., file name, MD5 hash, etc.):
                       Example:  ['some_file.pdf', 'some_other_file,pdf', ...]
                    Strings can also be hyperlinks in which case the label and URL should be separated by a single tab character:
                       Example: ['ktrain_article        https://arxiv.org/pdf/2004.10703v4.pdf', ...]

                    These references will be returned in the output of the ask method.
                    If strings are  hyperlinks, then they will automatically be made clickable when the display_answers function
                    displays candidate answers in a pandas DataFRame.

                    If references is None, the index of element in docs is used as reference.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def index_from_list(cls, docs, index_dir, commit_every=1024, breakup_docs=True,
                    procs=1, limitmb=256, multisegment=False, min_words=20, references=None):
    &#34;&#34;&#34;
    ```
    index documents from list.
    The procs, limitmb, and especially multisegment arguments can be used to 
    speed up indexing, if it is too slow.  Please see the whoosh documentation
    for more information on these parameters:  https://whoosh.readthedocs.io/en/latest/batch.html
    Args:
      docs(list): list of strings representing documents
      index_dir(str): path to index directory (see initialize_index)
      commit_every(int): commet after adding this many documents
      breakup_docs(bool): break up documents into smaller paragraphs and treat those as the documents.
                          This can potentially improve the speed at which answers are returned by the ask method
                          when documents being searched are longer.
      procs(int): number of processors
      limitmb(int): memory limit in MB for each process
      multisegment(bool): new segments written instead of merging
      min_words(int):  minimum words for a document (or paragraph extracted from document when breakup_docs=True) to be included in index.
                       Useful for pruning contexts that are unlikely to contain useful answers
      references(list): List of strings containing a reference (e.g., file name) for each document in docs.
                        Each string is treated as a label for the document (e.g., file name, MD5 hash, etc.):
                           Example:  [&#39;some_file.pdf&#39;, &#39;some_other_file,pdf&#39;, ...]
                        Strings can also be hyperlinks in which case the label and URL should be separated by a single tab character:
                           Example: [&#39;ktrain_article\thttps://arxiv.org/pdf/2004.10703v4.pdf&#39;, ...]

                        These references will be returned in the output of the ask method.
                        If strings are  hyperlinks, then they will automatically be made clickable when the display_answers function
                        displays candidate answers in a pandas DataFRame.

                        If references is None, the index of element in docs is used as reference.
    ```
    &#34;&#34;&#34;
    if not isinstance(docs, (np.ndarray, list)): raise ValueError(&#39;docs must be a list of strings&#39;)
    if references is not None and not isinstance(references, (np.ndarray, list)): raise ValueError(&#39;references must be a list of strings&#39;)
    if references is not None and len(references) != len(docs): raise ValueError(&#39;lengths of docs and references must be equal&#39;)

    ix = index.open_dir(index_dir)
    writer = ix.writer(procs=procs, limitmb=limitmb, multisegment=multisegment)

    mb = master_bar(range(1))
    for i in mb:
        for idx, doc in enumerate(progress_bar(docs, parent=mb)):
            reference = &#34;%s&#34; % (idx) if references is None else references[idx]

            if breakup_docs:
                small_docs = TU.paragraph_tokenize(doc, join_sentences=True, lang=&#39;en&#39;)
                refs = [reference] * len(small_docs)
                for i, small_doc in enumerate(small_docs):
                    if len(small_doc.split()) &lt; min_words: continue
                    content = small_doc
                    reference = refs[i]
                    writer.add_document(reference=reference, content=content, rawtext=content)
            else:
                if len(doc.split()) &lt; min_words: continue
                content = doc 
                writer.add_document(reference=reference, content=content, rawtext=content)

            idx +=1
            if idx % commit_every == 0:
                writer.commit()
                #writer = ix.writer()
                writer = ix.writer(procs=procs, limitmb=limitmb, multisegment=multisegment)
            mb.child.comment = f&#39;indexing documents&#39;
        writer.commit()
        #mb.write(f&#39;Finished indexing documents&#39;)
    return</code></pre>
</details>
</dd>
<dt id="ktrain.text.qa.core.SimpleQA.initialize_index"><code class="name flex">
<span>def <span class="ident">initialize_index</span></span>(<span>index_dir)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def initialize_index(cls, index_dir):
    schema = Schema(reference=ID(stored=True), content=TEXT, rawtext=TEXT(stored=True))
    if not os.path.exists(index_dir):
        os.makedirs(index_dir)
    else:
        raise ValueError(&#39;There is already an existing directory or file with path %s&#39; % (index_dir))
    ix = index.create_in(index_dir, schema)
    return ix</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ktrain.text.qa.core.SimpleQA.search"><code class="name flex">
<span>def <span class="ident">search</span></span>(<span>self, query, limit=10)</span>
</code></dt>
<dd>
<div class="desc"><pre><code>search index for query
Args:
  query(str): search query
  limit(int):  number of top search results to return
Returns:
  list of dicts with keys: reference, rawtext
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search(self, query, limit=10):
    &#34;&#34;&#34;
    ```
    search index for query
    Args:
      query(str): search query
      limit(int):  number of top search results to return
    Returns:
      list of dicts with keys: reference, rawtext
    ```
    &#34;&#34;&#34;
    ix = self._open_ix()
    with ix.searcher() as searcher:
        query_obj = QueryParser(&#34;content&#34;, ix.schema, group=qparser.OrGroup).parse(query)
        results = searcher.search(query_obj, limit=limit)
        docs = []
        output = [dict(r) for r in results]
        return output</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ktrain.text.qa.core.QA" href="#ktrain.text.qa.core.QA">QA</a></b></code>:
<ul class="hlist">
<li><code><a title="ktrain.text.qa.core.QA.ask" href="#ktrain.text.qa.core.QA.ask">ask</a></code></li>
<li><code><a title="ktrain.text.qa.core.QA.predict_squad" href="#ktrain.text.qa.core.QA.predict_squad">predict_squad</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ktrain.text.qa" href="index.html">ktrain.text.qa</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ktrain.text.qa.core.display_answers" href="#ktrain.text.qa.core.display_answers">display_answers</a></code></li>
<li><code><a title="ktrain.text.qa.core.pack_byte" href="#ktrain.text.qa.core.pack_byte">pack_byte</a></code></li>
<li><code><a title="ktrain.text.qa.core.unpack_byte" href="#ktrain.text.qa.core.unpack_byte">unpack_byte</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ktrain.text.qa.core.QA" href="#ktrain.text.qa.core.QA">QA</a></code></h4>
<ul class="">
<li><code><a title="ktrain.text.qa.core.QA.ask" href="#ktrain.text.qa.core.QA.ask">ask</a></code></li>
<li><code><a title="ktrain.text.qa.core.QA.display_answers" href="#ktrain.text.qa.core.QA.display_answers">display_answers</a></code></li>
<li><code><a title="ktrain.text.qa.core.QA.predict_squad" href="#ktrain.text.qa.core.QA.predict_squad">predict_squad</a></code></li>
<li><code><a title="ktrain.text.qa.core.QA.search" href="#ktrain.text.qa.core.QA.search">search</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ktrain.text.qa.core.SimpleQA" href="#ktrain.text.qa.core.SimpleQA">SimpleQA</a></code></h4>
<ul class="">
<li><code><a title="ktrain.text.qa.core.SimpleQA.index_from_folder" href="#ktrain.text.qa.core.SimpleQA.index_from_folder">index_from_folder</a></code></li>
<li><code><a title="ktrain.text.qa.core.SimpleQA.index_from_list" href="#ktrain.text.qa.core.SimpleQA.index_from_list">index_from_list</a></code></li>
<li><code><a title="ktrain.text.qa.core.SimpleQA.initialize_index" href="#ktrain.text.qa.core.SimpleQA.initialize_index">initialize_index</a></code></li>
<li><code><a title="ktrain.text.qa.core.SimpleQA.search" href="#ktrain.text.qa.core.SimpleQA.search">search</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>